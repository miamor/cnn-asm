lea ebp, [var] . lea eax, [var] . xchg esi, ebx . dec ecx . imul ebp, edx . inc ebx . imul ebx, edx . lea edx, [var] . mov dh, var . sub ch, var . push 0 . pop ebx . jbe var . test bl, ch . imul ecx, edx . js var . or ch, bh . and ch, var . mov ebp, var . mov al, bl . sub cl, var . add ebx, var . mov edi, var . and ecx, var . sub ebx, var . inc edi . sbb edi, ebx . dec ebp . test ecx, edi . imul edi, edi, var . mov esi, ebp . add edx, var . cmp ebx, var . jb var . mov eax, var . or eax, var . test dh, var . sub al, var . call var . pop ebp . movsx edi, di . sbb al, var . and bl, bl . cmp ebx, var . movsx esi, bl . lea edi, [var] . test edx, var . imul ebx, eax, var . dec esi . xor dh, var . sub eax, eax . mov bl, bl . xor bh, dl . test cl, var . add eax, var . mov ebx, var . imul ecx, ecx . xor eax, var . mov ch, al . xchg bh, dh . xadd ebp, eax . js var . imul ebx, ecx . inc edx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov eax, dword [var] . mov cx, word [eax] . inc eax . inc eax . test cx, cx . jne var . sub eax, dword [var] . sar eax, 1 . dec eax . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov edx, dword [var] . mov ecx, dword [var] . test edx, edx . je var . xor eax, eax . mov al, byte [var] . test al, al . jne var . cmp edx, var . jb var . cmp dword [var], 0 . je var . jmp var . push edi . mov edi, ecx . cmp edx, 4 . jb var . neg ecx . and ecx, 3 . je var . sub edx, ecx . mov byte [edi], al . add edi, 1 . sub ecx, 1 . jne var . mov ecx, eax . shl eax, 8 . add eax, ecx . mov ecx, eax . shl eax, var . add eax, ecx . mov ecx, edx . and edx, 3 . shr ecx, 2 . je var . rep stosd dword es:[edi], eax . test edx, edx
push ebp . mov ebp, esp . sub esp, var . push edi . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . jmp var . mov eax, dword [var] . add eax, 1 . mov dword [var], eax . cmp dword [var], var . jae var . jmp var . mov dword [var], 0 . jmp var . mov ecx, dword [var] . add ecx, 1 . mov dword [var], ecx . cmp dword [var], var . jae var . jmp var . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl
call var . mov dword [var], eax . wait . iretd . mov dl, var . shl byte [ebp - var], cl . sahf . mov edi, var . dec esp . push ebp . mov cl, var . fmul st(1), st(0) . pop ds . in al, dx . or eax, var . inc ebp . xchg byte [ecx], al . retf . ret var . je var . stc . ficomp word [ebx] . pop ss . mov bl, var . and byte [eax + var], ch . dec esi . mov dword [var], eax . stosb byte es:[edi], al . dec ebp . daa . cli . xor dword [ecx - var], esp . daa . sub dword [ecx - var], esp . xchg eax, esi . mov bl, var . push ss . invalid . mov byte [var], al . invalid . daa . xchg eax, esi . cmpsb byte [esi], byte ptr es:[edi] . push esi . dec edx . js var . mul dword [esi + var] . scasd eax, dword es:[edi] . dec edx . test eax, var . daa . outsb dx, byte [esi] . cmp eax, var . idiv ecx . wait . iretd . mov dl, var . shl byte [ebp - var], cl . sahf . mov edi, var . dec esp . push ebp . mov cl, var . fmul st(1), st(0)
call var . mov dword [ebp - 4], eax . mov dword [esp], eax . mov eax, ebx . mov edx, esp . push ebp . xor ebp, eax . call var . sub dword [var], var . call var . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . mov eax, dword [esp] . mov ecx, dword [esp + 4] . mov edx, var . mul edx . imul ecx, ecx, var . add edx, ecx . mov dword [esp], eax . mov dword [esp + 4], edx . lea esp, [ebp - 4] . pop esi . pop ebp . ret . push ebp . mov ebp, esp . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + 8], eax . jmp var . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, var . call eax . ja var . out dx, eax . xor byte [ecx + var], var . invalid . invalid . pop edx . add eax, var . not bl . idiv byte [ebx] . ljmp var:var . cdq . sub al, var . test eax, var
imul ebx . mov edx, esp . mov ecx, ebp . mov eax, ebx . cmp edx, var . mov dword [var], edx . mov dword [var], ebp . mov dword [var], eax . jg var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . push eax . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, var . mov ah, byte [edx + ecx] . sub edi, ecx . sub ah, al . mov dword [ebp - var], edi . mov byte [esi + ecx], ah . add esp, 4 . pop esi . pop edi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . mov dword [esp + var], var . mov dword [esp + var], var . lea eax, [esp + var] . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . mov dword [esp + var], eax . mov dword [esp + 8], ecx . mov dword [esp + 4], edx . jmp var . mov eax, dword [sym.imp.USER32.dll_TrackPopupMenuEx] . call eax . in al, dx . in eax, var . inc esi . loop var . outsb dx, byte [esi] . and byte [edx], bh . add dh, ah . int var . outsb dx, byte [esi] . popfd . retf var
call var . mov dword [var], edi . mov dword [var], esi . mov dword [ebp - 4], eax . mov dword [esp], eax . mov eax, ebx . mov edx, esp . push ebp . xor ebp, eax . call var . sub dword [var], var . call var . mov dword [ebp - 8], eax . arpl word es:[ebx - var], bp . lea esi, [ebp + var] . adc ch, byte [ebx + var] . xor byte [ebx + ebx*4 + var], al . sar byte [edi + var], 1 . inc eax . invalid . stosb byte es:[edi], al . jl var . invalid . invalid . neg dword [eax - var] . invalid . movsd dword es:[edi], dword ptr [esi] . bound edx, qword [edi] . aam var . sar byte [ebx - var], cl . jp var . cdq . adc dword [edi - var], edx . test eax, var . xor dword [edx + ebx*2], eax . push ss . sbb bl, byte [ebx + ecx*4 - var] . pop dword [eax + var] . movsb byte es:[edi], byte ptr [esi] . stosb byte es:[edi], al . inc esi . xchg eax, esp . pop es . xchg eax, edi . and eax, var . add byte [ebp - var], al . hlt . pop esi . inc eax . invalid . mov ah, var . mov esi, var . je var . out dx, eax . cwde . mov byte [ebx - var], ch . fmulp st(3) . cdq . lea esi, [ebp + var] . adc ch, byte [ebx + var] . xor byte [ebx + ebx*4 + var], al . sar byte [edi + var], 1 . inc eax . invalid
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . xor eax, eax . push eax . push eax . push eax . push eax . call var . ret . push esi . push edi . mov edi, dword [var] . mov esi, ecx . mov ecx, edi . mov dword [esi], edi . call var . mov dword [esi + 8], eax . mov dword [esi + var], edx . mov eax, dword [edi + var] . mov dword [esi + var], eax . pop edi . mov eax, esi . pop esi . ret 4 . mov eax, ecx . mov ecx, dword [eax] . mov edx, dword [eax + var] . cmp edx, dword [ecx + var] . jne var . push 0 . push dword [eax + var] . push dword [eax + 8] . call var . ret . push esi . mov esi, ecx . mov eax, dword [esi] . test eax, eax . je var . push eax . call dword [sym.imp.KERNEL32.dll_FreeLibrary] . and dword [esi], 0 . and dword [esi + 8], 0 . and dword [esi + var], 0 . pop esi . ret . push esi . mov esi, ecx . cmp byte [esi + 4], 0 . jne var . push str.Crypt32.dll . call dword [sym.imp.KERNEL32.dll_LoadLibraryW] . mov dword [esi], eax . test eax, eax . je var . push edi . mov edi, dword [sym.imp.KERNEL32.dll_GetProcAddress] . push str.CryptProtectMemory . push eax . call edi . push str.CryptUnprotectMemory . push dword [esi] . mov dword [esi + 8], eax . call edi . mov dword [esi + var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, dword [var] . sub eax, 0 . je var . sub eax, 4 . add eax, 4 . call var . pop dword [var] . jmp var . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push eax . mov eax, dword [var] . add eax, var . mov dword [var], eax . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . add esp, 4 . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . call var . mov ecx, 1 . mov dword [var], var . mov eax, dword [eax + var] . cmp eax, 6 . mov dword [var], ecx . jb var . call var . mov dword [esp], eax . call var . cmp word [eax + var], 6 . setb dl . and dl, 1
call var . jmp var . push dword [var] . call dword [sym.imp.KERNEL32.dll_DecodePointer] . test eax, eax . je var . call eax . push var . call var . push 1 . push 0 . call var . add esp, var . jmp var . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 3] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 4] . mov ecx, dword [var] . sub eax, ecx . ret . int
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . in eax, dx . cld . ljmp var . dec ebx . sub al, var . jbe var . mov al, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec edi . insb byte es:[edi], dx . popal . jbe var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . sbb eax, var . xchg ecx, ebx . invalid . inc eax . test byte [eax], dh . jle var . pushal . bound ecx, qword [ebx + eax - var] . mov dword [var], eax . push esp . dec edi . popfd . mov ss, word [edi - var] . nop . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx - var], cl . jb var . lodsb al, byte [esi] . leave . daa . inc ebp . mov esp, var . push ebx . jno var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . add byte [esi], al . push eax . add dword [edx], var . outsb dx, byte [esi] . jo var . jo var . insb byte es:[edi], dx . popal . jb var . je var . add byte [edi], cl . aaa . add eax, dword [eax] . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add eax, var . in eax, dx . in eax, var . inc ebx . lodsd eax, dword [esi] . loopne var . add dl, byte [eax] . invalid . aaa . sub byte [ecx], var . push esp . inc ebp . and bl, bh . int var . wait . push ebp . cmp byte [edi - var], cl . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], dl . imul ecx, dword [eax], var . adc cl, byte [esi + var] . dec esp . mov dl, var . jge var . scasd eax, dword es:[edi] . or dl, byte [var] . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx], al . push es . push eax . xchg eax, ebx . add ah, byte [ebx + var] . popal . je var . jb var . insb byte es:[edi], dx . insb byte es:[edi], dx . jne var . cmp dword [eax], eax . add byte cs:[ebx], 0 . add byte [eax], al . add byte [ecx], al . add byte [ebx], al . add byte [ebx + ebx + var], dh . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + var], bl . inc eax . add byte [eax + edx + var], bh . add byte [eax], al . mov al, var . xchg byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . or byte [eax + eax*2], dl . add byte [ecx], al
push ebp . push esp . or ecx, var . mov eax, ecx . and eax, var . cmp eax, 1 . je var . pop ecx . add ecx, 4 . pop dword [var] . mov dword [var], ecx . mov ecx, ebx . mov dword [var], ecx . call var . cmp ecx, ebp . je var . mov eax, ebx . sub eax, 6 . shl eax, 3 . push eax . xor eax, eax . mov ebp, ebx . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push eax . call var . mov ecx, 1 . cmp eax, 0 . mov dword [var], ecx . jne var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . add esp, 4 . pop ebp . ret . int . int . int . int . int . int . int . int . int . int
push esi . lea edx, [var] . add edx, var . mov dword [edx], ebp . xor esi, esi . pop ecx . lea edx, [var] . mov dword [edx], ecx . mov esi, ecx . mov ecx, esp . lea edx, [var] . push edi . mov dword [edx], ecx . pop ecx . lea edx, [var] . mov dword [edx], ecx . lea edx, [var] . add edx, var . mov dword [edx], ebx . lea eax, [var] . add eax, var . jmp eax . xor eax, eax . ret . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . xor esi, esi . mov dword [var], var . cmp edx, 0 . sete bl . cmp ecx, 0 . sete bh . or bl, bh . test bl, 1 . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], esi . jne var . jmp var . lea esp, [var] . pop esi . pop ebx . pop ebp . ret . mov eax, dword [var] . add eax, 1 . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . mov dword [var], eax . je var . jmp var . mov eax, dword [var] . mov ecx, var
push ebp . mov ebp, esp . mov ecx, var . push 0 . push 0 . dec ecx . jne var . push ebx . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . push var . push 0 . push 0 . call var . mov ebx, eax . call sub.kernel32.dll_GetLastError . cmp eax, var . jne var . push ebx . call sub.kernel32.dll_CloseHandle . push var . call sub.kernel32.dll_Sleep . jmp var . push ebx . call sub.kernel32.dll_CloseHandle . push var . push 0 . push 0 . call var . mov ebx, eax . call sub.kernel32.dll_GetLastError . cmp eax, var . jne var . push ebx . call sub.kernel32.dll_CloseHandle . lea eax, [var] . call var . mov edx, dword [var] . mov eax, var . call var . cmp dword [var], 0 . je var . mov eax, dword [var] . call var . push eax . lea eax, [var] . call var . lea eax, [var] . mov edx, var . call var . mov eax, dword [var] . mov edx, dword [var] . pop ecx . call var . lea eax, [var] . call var . mov edx, dword [var] . mov eax, var . call var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . xor edx, edx . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add cl, byte [var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor dl, byte [ebx] . mov eax, eax . add al, byte [eax] . mov eax, eax . add byte [varh], cl . inc eax
push ebp . mov ebp, esp . sub esp, var . push edi . mov edx, edx . mov edx, dword [var] . mov edx, edx . mov dword [var], edx . mov dword [var], ebp . mov byte [var], 0 . mov dword [var], str.i111111c76p3050f558_98b5_11cf_bb82_00aa00bdce0bf . push 4 . push var . call var . add esp, 8 . mov dword [var], 0 . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + 6], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + 8], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var] . mov edx, dword [var] . mov word [edx + ecx*2 + var], ax . movzx eax, byte [var] . add eax, var . mov ecx, dword [var]
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . lea eax, [var] . push eax . push 0 . push dword [var] . push dword [var] . push dword [var] . call var . add esp, var . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . lea eax, [var] . push eax . push dword [var] . call var . pop ecx . pop ecx . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . push edi . mov edi, dword [var] . mov eax, edi . sub eax, 0 . je var . dec eax . je var . dec eax . je var . dec eax . je var . dec eax . je var . mov ecx, dword [var] . mov eax, dword [var] . push ebx . push var . pop edx . jmp var . mov esi, dword [eax] . cmp esi, dword [ecx] . je var . movzx esi, byte [eax] . movzx ebx, byte [ecx] . sub esi, ebx . je var . xor ebx, ebx . test esi, esi . setg bl . lea ebx, [ebx + ebx - 1] . mov esi, ebx . test esi, esi . jne var . movzx esi, byte [eax + 1]
mov dword [var], esp . push esi . mov edx, var . lea ecx, [var] . mov dword [ecx + edx + 1], ebx . mov ecx, var . sub ecx, var . lea edx, [var] . mov dword [edx + ecx + var], ebp . mov ecx, esp . mov eax, ecx . mov ecx, 4 . add eax, ecx . test eax, eax . je var . mov ecx, 0 . lea edx, [var] . mov dword [edx], edi . lea edx, [var] . pop ecx . add edx, 2 . mov dword [edx], ecx . xor ecx, var . cmp ecx, 2 . je var . call var . mov dword [var], eax . xor eax, eax . pop esp . add eax, var . mov dword [var], eax . nop . dec esi . fdivr st(3) . popal . and dword [var], esp . out dx, al . stc . cwde . cmc . xor dl, ch . int var . mov esi, var . mov esp, dword [ebp*8 + var] . dec edi . hlt . or dword [edi], edi . stc . mov edx, var . outsb dx, byte [esi] . sub ebx, dword [esi + var] . invalid . cmc . loop var . nop . mov dh, var . idiv cl . daa . push 9 . ljmp var:var . and ebp, dword [ebp + var] . ret var . cmc . fstp st(4), st(0)
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . fcom st(0), st(0) . test byte [edx - var], var . cmp eax, var . arpl word [eax], ax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax + eax], al . add byte [eax], al . dec ebp . pop ecx . inc ebx . dec eax . inc ecx . inc ebp . dec esp . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . pop es . shl dword [eax + var], 1 . dec esi . inc ebp . wait . inc ebx . dec edi . jae var . loopne var . mov al, byte [var] . mov ebp, var . js var . aad var . and al, var . pop ds . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, var . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var] . cmp eax, dword [edx + var] . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . pop eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . mov dword cs:[var], eax . xchg eax, edx . inc esi . test byte [eax], cl . cmp byte [ebp + var], dh . add dword [ecx + var], var . add byte [eax], al . add byte [edi], dl . adc al, byte [eax + eax] . xor esp, dword [esi] . push eax . jb var . push var . arpl word [ecx + esi], si . add byte [var], dl . dec ebp . popal . and byte gs:[esi + var], cl . outsb dx, byte [esi] . and byte [bx + si + var], dl . insd dword es:[edi], dx . and byte [eax + var], dl . popal . imul esp, dword [eax], var . add byte [eax + eax], bl . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . push es . mov byte [ebp + ebp + var], dh . cdq . mov ebp, var . push var . fcomp qword [eax + var] . mov eax, var . dec ebp . test dword [edx], eax . sahf . sub dword [ebp + var], var . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . mov dword [var], eax . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push edi . push esi . push ebx . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - var], var . mov esi, eax . imul esi, esi . mov edi, eax . imul edi, edi . mov ebx, eax . imul ebx, ebx . imul ebx, edi . imul esi, esi . cmp esi, ebx . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . je var . jmp var . mov eax, dword [ebp - var] . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . cmp dword [ebp - var], eax . je var . jmp var . jmp var . mov eax, dword [ebp - var] . add eax, var . mov ecx, dword [ebp - var] . cmp ecx, eax . je var . jmp var . mov eax, dword [ebp - var] . add eax, var . mov dword [ebp - var], eax . jmp var . mov eax, dword [ebp - var] . xor eax, var . mov ecx, dword [ebp - var] . add ecx, eax . mov eax, dword [ebp - var] . add eax, ecx . mov edx, dword [ebp - var] . add edx, ecx . mov ecx, dword [ebp - var] . cmp eax, ecx . setae bl . mov eax, dword [ebp - var] . cmp edx, eax
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
call var . jmp var . push ebp . mov ebp, esp . push esi . mov esi, dword [var] . push edi . or edi, var . test esi, esi . jne var . call var . mov dword [eax], var . call var . or eax, edi . jmp var . test byte [esi + var], var . je var . push esi . call var . push esi . mov edi, eax . call var . push esi . call var . push eax . call var . add esp, var . test eax, eax . jns var . or edi, var . jmp var . cmp dword [esi + var], 0 . je var . push dword [esi + var] . call var . and dword [esi + var], 0 . pop ecx . and dword [esi + var], 0 . mov eax, edi . pop edi . pop esi . pop ebp . ret . push var . push var . call var . or edi, var . mov dword [var], edi . xor eax, eax . mov esi, dword [var] . test esi, esi . setne al . test eax, eax . jne var . call var . mov dword [eax], var . call var . mov eax, edi . call var . ret . test byte [esi + var], var . je var . and dword [esi + var], 0 . jmp var
call var . cmp eax, 4 . je var . mov dword [var], eax . ret . pop edx . add edx, ecx . test eax, eax . mov dword [var], edx . jne var . pop dword [var] . mov eax, var . add esp, var . cmp ecx, 0 . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . push eax . lea eax, section..data . mov ecx, dword [ebp - 4] . add ecx, var . mov dword [ebp - 4], ecx . add esp, 4 . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [esp + var] . mov dword [esp + var], var . mov dword [esp + var], var . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . lea esi, [esp + var] . mov dword [esp + var], 0 . mov dword [esp + var], 0 . mov dword [esp + var], eax . mov dword [esp + var], ecx . mov dword [esp + 8], edx . mov dword [esp + 4], esi . jmp var . mov eax, dword [sym.imp.USER32.dll_InsertMenuA] . call eax . cmp byte [ebx], cl
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov eax, ebp . mov ecx, var . mov ebp, esp . mov eax, esp . push 4 . lea esp, [var] . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call main . test eax, eax . jne var . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call main . cmp eax, 0 . jne var . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call main . test eax, eax . jne var . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call main . cmp eax, 0 . jne var . push var . push var . call sub.kernel32.dll_lstrcpyW . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call main . cmp eax, 0
call var . jmp var . push ebp . mov ebp, esp . test byte [ebp + 8], 1 . push esi . mov esi, ecx . mov dword [esi], vtable.type_info.0 . je var . push var . push esi . call var . pop ecx . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . push ebp . mov ebp, esp . push ecx . push esi . push dword [ebp + 8] . mov esi, ecx . mov dword [ebp - 4], esi . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . mov esp, ebp . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push dword [ExceptionInfo] . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . pop ebp . ret . ├ 251: loc.00414a0e (int2_t var, int2_t var) . push ebp . mov ebp, esp . sub esp, var . push var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi - var], bh . dec edi . sub dword [ebx - var], eax . pushfd . add ch, byte [edx + edx*4 - var] . sbb bl, ch . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . insb byte es:[edi], dx . popal . jae var . push var . popal . insb byte es:[edi], dx . jo var . bound ebp, qword [ecx + edi*2] . and byte [esi], ah . dec eax . xor dword [0], ecx . pop es . add byte [eax], al . add al, ah . and al, byte [eax] . pop es . add byte [eax], al . add byte [edx + var], dl . add byte [eax], al . push eax . and al, byte [eax] . add dword [eax], eax . add eax, dword [eax] . cld . sbb eax, var . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add al, ah . push ds . inc eax . add ah, bh . push eax . dec ebx . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edi + 3], dl . fidiv dword [esi + var] . inc ebx . cmovs edx, dword [esi + var] . and esi, dword [eax + var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . jae var . jb var . jb var . imul ebp, dword [esi], 0 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], al . add byte [eax], al . add ah, al . sub dword [eax], eax . pop es . add byte [eax], al . add al, ch . and dword [eax], eax . pop es . add byte [eax], al . add byte [eax + var], bl . add byte [eax], al . add byte [ecx], bh . inc eax . add byte [edi], al . add byte [eax], al . add ah, ch . and byte [eax], al . pop es . add byte [eax], al . add byte [eax + var], ch . add byte [eax], al . dec eax . and byte [eax], al . add dword [eax], eax . add al, byte [eax] . test byte [var], bl . add byte [eax], al . invalid . invalid . invalid . invalid . invalid
call var . jmp var . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
call var . jmp var . push var . push var . call var . and dword [var], 0 . mov esi, dword [var] . cmp esi, dword [var] . ja var . push 4 . call var . pop ecx . and dword [var], 0 . push esi . call var . pop ecx . mov dword [var], eax . mov dword [var], var . call var . mov eax, dword [var] . call var . ret . push 4 . call var . pop ecx . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, dword [var] . cmp esi, var . ja var . push ebx . push edi . mov edi, dword [sym.imp.KERNEL32.dll_HeapAlloc] . cmp dword [var], 0 . jne var . call var . push var . call var . push var . call var . pop ecx . pop ecx . mov eax, dword [var] . cmp eax, 1 . jne var . test esi, esi . je var . mov eax, esi . jmp var . xor eax, eax . inc eax . push eax . jmp var . cmp eax, 3 . jne var . push esi . call var . pop ecx . test eax, eax . jne var . test esi, esi
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . inc ecx . add ebx, ebx
mov eax, dword [var] . xor eax, eax . call var . jmp var . mov dword [ebp - 4], eax . jae var . call var . xor cl, byte [edx] . add bl, byte [ebp - var] . ja var . jbe var . cwde . cmp eax, ebp . insd dword es:[edi], dx . jmp var . xchg eax, esp . sub al, bh . shr dword [edx + ecx*4], 1 . pop esp . xor dh, bh . ret . add dword [edi], var . adc esp, dword [edi - var] . push edi . add edi, esp . jmp var . push cs . imul ebp, dword [esi + edi*4], var . xor al, var . fbld tbyte [ebp + var] . push esp . and eax, var . mov dword [var], eax . lodsb al, byte [esi] . lcall var:var . test byte [esi - var], ch . invalid . xor byte [edi + var], cl . inc esi . pop edx . xchg cl, dh . aaa . adc eax, var . mov eax, dword [var] . out var, eax . dec edx . adc dword [edi], var . mov esi, var . je var . sub edx, dword [ecx - var] . loope var . fisub dword [esi - var] . inc esi . cmc . ja var . mov byte [eax + ebp - var], dl . scasb al, byte es:[edi] . jl var . out dx, al . ficomp word [ecx + eax*4 + var] . outsb dx, byte [esi] . sub byte [ebx - var], var . dec esi . mov ebp, cs
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414132 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . cmp eax, var . sub dword [eax], eax . inc ecx . xchg eax, ebx . fidiv dword [ecx] . into . retf . inc esi . jmp var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . jae var . dec ecx . arpl word [ecx + var], sp . add byte gs:[ebx + var], ch . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add edi, dword [edi + var] . stc . retf var . push var . mov eax, var . pop esi . stosd dword es:[edi], eax . or al, var . dec eax . mov cl, var . movsd dword es:[edi], dword ptr [esi] . push ecx . push varffffffa8 . rcl ecx, 1 . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push var . push var . call var . call var . movzx esi, ax . push 2 . call var . pop ecx . mov eax, var . cmp word [var], ax . je var . xor ebx, ebx . jmp var . mov eax, dword [var] . cmp dword [eax + var], var . jne var . mov ecx, var . cmp word [eax + var], cx . jne var . xor ebx, ebx . cmp dword [eax + var], var . jbe var . cmp dword [eax + var], ebx . setne bl . mov dword [var], ebx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . and dword [var], 0 . call var . test eax, eax . jns var . push var . call var . pop ecx . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . test eax, eax . jns var . push 8 . call var . pop ecx . call var . test eax, eax . jns var . push 9 . call var . pop ecx . push 1
call var . mov dword [var], eax . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . mov dword [var], ebx . push esp . sub dword [var], 8 . mov dword [var], edi . mov dword [var], esi . add dword [var], 8 . mov eax, dword [var] . add dword [var], 4 . jmp var . retf var . dec edi . cmc . ret . cmc . mov dl, byte [edx] . adc al, var . aam var . sbb ebx, esp . jnp var . xor dl, var . dec ecx . invalid . leave . wait . ja var . mov esp, var . pop es . sub edx, edi . test eax, var . lcall var:var . inc esp . aaa . lds edx, [edx] . ja var . or eax, dword [edx + var] . jmp var . cmp eax, var . loopne var . retf . pop ds . xchg eax, edx . xchg eax, ebx . jge var . shr dword [ebx], 1 . dec ecx . push edx . inc edx . invalid . xchg eax, ebp . mov ebx, var . mov dword [edx + var], ebp . test byte [esi - var], bh . push ds . add eax, var . fsubr qword [var] . dec edi . cmc . ret
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var]
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . or ebp, var . jmp var . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . mov dword [var], eax . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . push esi . push edi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov esi, var . mov dword [ebp - var], var . sub esi, dword [ebp - var] . cmp eax, esi . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . je var . jmp var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . je var . jmp var . xor eax, eax . mov dword [ebp - var], eax . jmp var . jmp var . xor eax, eax . mov ecx, var . mov edx, dword [ebp - var] . and edx, var . sub ecx, dword [ebp - var] . cmp edx, ecx . mov dword [ebp - var], edx . mov dword [ebp - var], eax . je var . jmp var . mov eax, dword [ebp - var] . add esp, var . pop edi . pop esi . pop ebx . pop ebp . ret . mov eax, dword [ebp - var] . mov ecx, var . mov edx, dword [ebp - var] . add edx, eax
push ebp . push ebx . mov eax, var . lea ecx, str.oCA . mov dword [ecx + eax], esi . mov eax, var . mov ecx, dword [var] . lea edx, [var] . mov dword [edx + eax], ecx . mov ecx, esp . inc ecx . xchg eax, ecx . inc eax . lea edx, [var] . add eax, 7 . xor ecx, ecx . add ecx, var . dec eax . mov dword [edx + ecx], eax . lea edx, [var] . mov dword [edx], edi . lea edx, [var] . inc edx . pop ecx . inc edx . mov dword [edx], ecx . pop eax . call var . test eax, eax . call var . mov eax, 1 . ret . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . push esi . push ebx . push edi . and esp, var . sub esp, var . mov eax, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . xor ebx, ebx . mov esi, var . xor ecx, var . mov edi, eax . add edi, var . sub ecx, var . mov dword [esp + var], eax . setb al . test edx, edx . mov ah, bl . mov byte [esp + var], ah . mov dword [esp + var], esi . mov dword [esp + var], ecx . mov dword [esp + var], edi . mov byte [esp + var], al . je var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov edi, edi . push ebp . mov ebp, esp . cmp dword [var], 1 . jne var . call var . push dword [var] . mov ecx, dword [var] . mov edx, dword [var] . call var . pop ecx . pop ebp . ret var . ├ 262: loc.1001641e (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_IsDebuggerPresent] . mov dword [var], eax . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . cmp dword [var], 0 . jne var . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . lcall var . dec ebx . mov es, ebx . dec ebp . pop edx . movsb byte es:[edi], byte ptr [esi] . or bh, byte [ebp + var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . inc ecx . inc edi . inc ecx . dec esi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add al, var . xchg eax, esp . jg var . invalid . salc . iretd . dec edx . mov edi, var . js var . push edx . xchg eax, ecx . inc ecx . adc dword [ebx - var], ebp . ja var . dec edi . test byte [ecx], ch . cmp eax, ebp . pop dx . sub eax, var . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.DLL_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . xor esi, esi . push esi . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.DLL_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.DLL_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi . push esi . call dword [sym.imp.KERNEL32.DLL_GetModuleHandleA] . push eax . call main . mov dword [var], eax . push eax
push 8 . mov eax, esi . mov dword [var], eax . mov dword [var], edi . push ebp . push esp . push ebx . call var . mov dword [var], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [var] . mov ecx, var . lea edx, [esp + var] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], var . mov byte [esp + var], var . mov esi, dword [esp + var] . mov edi, dword [esp + var] . xor edi, var . mov dword [esp + var], esi . mov dword [esp + var], edi . mov bl, byte [esp + var] . xor bl, var . mov byte [esp + var], bl . sub ecx, dword [esp + var] . mov dword [esp], edx . mov dword [esp + 4], eax . mov dword [esp + 8], ecx . mov dword [esp + var], edx . call var . mov bl, byte [esp + var] . xor bl, var . cmp byte [esp + var], bl . je var . jmp var . mov eax, dword [esp + var] . mov dword [esp], eax . mov eax, dword [esp + var] . mov dword [esp + 4], eax . call var . mov dword [var], eax . jmp var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . add eax, var . adc ecx, var . mov edx, dword [esp + var] . mov esi, dword [esp + var] . mov dword [esp + var], eax . mov dword [esp + var], ecx . mov dword [esp + var], edx . mov dword [esp + var], esi . call var . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . xor eax, ecx
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx + 6], dl . adc eax, var . inc ecx . invalid . jae var . push ds . xchg byte [ecx - var], al . sub eax, dword [eax] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx], al . xchg byte [eax - var], dl . add dword [ebx + var], esi . imul ebp, dword [esi + var], var . imul esp, dword [ebp + var], 0 . wait . bound eax, qword [ebx] . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or ecx, esi . xor eax, var . jp var . mov al, var . mov dh, var . fcom st(1) . test al, 3 . ret var . xlatb . ja var . jns var . test al, var . invalid . push var . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add cl, cl . invalid . lcall var:var . in eax, dx . popal . and al, var . mov ebx, 0 . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push ebx . push eax . inc ebp . inc ecx . push edx . inc edi . push edx . inc ecx . push ebx . push ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add edx, dword [esi] . xchg eax, ecx . mov edx, var . inc ecx . mov cl, var . xlatb . jb var . loopne var . xor eax, var . fstp dword [esi + var] . mov byte [var], al . mov word [ebx - var], fs . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . xor eax, eax . push eax . push eax . push eax . push eax . call var . ret . push esi . push edi . mov edi, dword [var] . mov esi, ecx . mov ecx, edi . mov dword [esi], edi . call var . mov dword [esi + 8], eax . mov dword [esi + var], edx . mov eax, dword [edi + var] . mov dword [esi + var], eax . pop edi . mov eax, esi . pop esi . ret 4 . mov eax, ecx . mov ecx, dword [eax] . mov edx, dword [eax + var] . cmp edx, dword [ecx + var] . jne var . push 0 . push dword [eax + var] . push dword [eax + 8] . call var . ret . push esi . mov esi, ecx . mov eax, dword [esi] . test eax, eax . je var . push eax . call dword [sym.imp.KERNEL32.dll_FreeLibrary] . and dword [esi], 0 . and dword [esi + 8], 0 . and dword [esi + var], 0 . pop esi . ret . push esi . mov esi, ecx . cmp byte [esi + 4], 0 . jne var . push str.Crypt32.dll . call dword [sym.imp.KERNEL32.dll_LoadLibraryW] . mov dword [esi], eax . test eax, eax . je var . push edi . mov edi, dword [sym.imp.KERNEL32.dll_GetProcAddress] . push str.CryptProtectMemory . push eax . call edi . push str.CryptUnprotectMemory . push dword [esi] . mov dword [esi + 8], eax . call edi . mov dword [esi + var], eax
call var . jmp var . jmp dword [var] . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . bnd ret . mov ecx, dword [var] . xor ecx, ebp . bnd call var . bnd jmp var . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . insd dword es:[edi], dx . daa . imul eax, dword [varh], var . xor dl, byte ds:[ecx] . xor al, byte [eax] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + var], cl . insb byte es:[edi], dx . popal . je var . jb var . popal . jae var . add byte [eax], al . add byte [eax], al . add byte [edi + esi*2 + var], dl . je var . push var . add byte [eax], al . pop es . add byte [eax], al . add ah, dl . dec esp . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax + var], cl . add byte [eax], al . add byte [eax], bl . dec esp . inc eax . add byte [esi], al . add byte [eax], al . add byte [ecx + ecx*2], ah . inc eax . add byte [edi], al . add byte [eax], al . add al, dh . dec eax . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax + ecx*2], cl . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax], dh
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + edx*8 + var], al . dec ebp . test eax, var . push eax . hlt . bound esi, qword [edi - var] . pushal . and al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . or cl, al . inc eax . add byte [ebp + var], al . insb byte es:[edi], dx . popal . push var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add byte [ebx + var], al . in al, var . mov cl, var . fmul qword [edx + ebx*4 - var] . stc . sbb ebx, var . retf . mov edi, var . pop ds . xchg eax, ebx . je var . mov esp, var . dec edx . fdiv dword [edx + esi*2] . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . xor ecx, ecx . add ecx, 5 . mov eax, edi . dec ecx . sub esp, ecx . mov dword [esp], eax . mov eax, ebx . mov edx, esp . push ebp . xor ecx, ecx . add ecx, var . mov eax, edi . dec ecx . dec edx . add edx, ecx . inc edx . push edx . push ebp . mov ebp, esp . mov ecx, dword [var] . je var . sub edx, 4 . pop ebp . add esp, var . call var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . mov dword [esp + 4], 0 . mov dword [esp], var . xor eax, eax . mov cl, al . test cl, cl . jne var . jmp var . mov eax, dword [sym.imp.KERNEL32.dll_lstrlenA] . mov dword [var], eax . mov esp, ebp . pop ebp . ret . inc eax . ljmp var:var . je var . xor eax, var . mov dh, var . test al, var . retf . popfd . push ds . xchg eax, ebx . pop ss . call var . out 3, al . mov ebx, var . clc . inc ecx . mov byte [var], al . and byte [ecx], al . outsd dx, dword [esi] . dec eax
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 3] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 4] . mov ecx, dword [var] . sub eax, ecx . ret . mov edi, edi . push ebp
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, var . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var] . cmp eax, dword [edx + var] . jne var
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
pushal . mov esi, var . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
call var . jmp var . int . int . int . push esi . mov eax, dword [var] . or eax, eax . jne var . mov ecx, dword [var] . mov eax, dword [var] . xor edx, edx . div ecx . mov ebx, eax . mov eax, dword [var] . div ecx . mov esi, eax . mov eax, ebx . mul dword [var] . mov ecx, eax . mov eax, esi . mul dword [var] . add edx, ecx . jmp var . mov ecx, eax . mov ebx, dword [var] . mov edx, dword [var] . mov eax, dword [var] . shr ecx, 1 . rcr ebx, 1 . shr edx, 1 . rcr eax, 1 . or ecx, ecx . jne var . div ebx . mov esi, eax . mul dword [var] . mov ecx, eax . mov eax, dword [var] . mul esi . add edx, ecx . jb var . cmp edx, dword [var] . ja var . jb var . cmp eax, dword [var] . jbe var . dec esi . sub eax, dword [var] . sbb edx, dword [var] . xor ebx, ebx . sub eax, dword [var] . sbb edx, dword [var] . neg edx . neg eax . sbb edx, 0 . mov ecx, edx . mov edx, ebx . mov ebx, ecx . mov ecx, eax . mov eax, esi . pop esi . ret var . sub eax, var
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var]
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
call var . jmp var . push ebp . mov ebp, esp . push ecx . push esi . push dword [ebp + 8] . mov esi, ecx . mov dword [ebp - 4], esi . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . mov esp, ebp . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . lea eax, [ecx + 4] . mov dword [ecx], vtable.std::exception.0 . push eax . call var . pop ecx . ret . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . jmp dword [var] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . mov eax, 5 . push edi . dec eax . mov ecx, eax . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [var] . mov dword [var], eax . call var . mov ecx, dword [var] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
mov eax, dword [var] . call var . ret . ret . int . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . lea eax, [var] . mov ecx, dword [esp] . or ecx, var . mov dword [esp], ecx . mov esp, ebp . pop ebp . ret . int . push ebp . mov ebp, esp . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], var . mov ecx, dword [var] . add ecx, var . mov edx, dword [var] . cmp ecx, edx . mov dword [var], eax . mov dword [esp], edx . jbe var . xor eax, eax . mov ecx, var . mov edx, dword [var] . mov esi, dword [edx + var] . add edx, esi . mov edi, dword [var] . mov esi, dword [edi + esi] . sub ecx, dword [var] . cmp esi, ecx . cmove eax, edx . lea esp, [var] . pop esi . pop edi . pop ebp . ret . mov eax, var . mov dword [var], var . mov ecx, dword [esp] . imul edx, ecx, var . mov esi, dword [var] . mov dword [var], edx . cmp eax, esi . jbe var . jmp var . int . int . int . int . int
mov eax, dword [sym.imp.ADVAPI32.dll_IsTokenRestricted] . mov dword [var], eax . mov ecx, dword [var] . push ebx . push esi . push edi . call var . cmp eax, 4 . mov edx, dword [ecx] . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, section.DATA . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + 4], var . mov ah, byte [edx + ecx] . sub ah, al . mov dword [esp + 4], var . mov byte [esi + ecx], ah . mov ecx, dword [esp + 8] . mov edx, dword [esp + var] . not ecx . not edx . mov dword [esp + var], edx . mov dword [esp + 8], ecx . lea esp, [ebp - 4] . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], var . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . mov esi, dword [esp + var] . mov dword [esp + var], var . mov dword [esp + var], 0 . imul edi, ecx, var . mov dword [esp + var], edi . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov edi, ecx . xor edi, var . mov dword [esp + var], edi
push ebp . mov ebp, esp . add eax, var . adc edx, var . mov ebx, edi . and ebx, var . jbe var . inc eax . mov edi, edx . dec ebx . mov esp, ebp . pop ebp . jmp loc.00435b20 . or al, var . add byte [edx], al . adc edx, ecx . lahf . test al, var . mov dr0, edi . rol dword [ebx - var], cl . sub cl, al . and edi, dword [ebp - var] . add al, var . outsb dx, byte [esi] . add eax, var . fld xword [eax + var] . invalid . leave . inc ecx . invalid . sub al, var . push ds . xor ch, ch . push var . xlatb . cli . nop . mov ah, var . cli . imul edx, dword [eax - var], var . invalid . inc dword [ebx - var] . pop edi . out dx, al . pushal . mov bl, var . ret . mov esp, ebp . pop ebp . jmp var . xor eax, var . sahf . outsb dx, byte [esi] . sti . add esp, esp . movsb byte es:[edi], byte ptr [esi] . invalid . mov al, 1 . dec ecx . jno var . mov dword [var], eax . rcr byte [var], 1 . xchg eax, esp . push edi
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov edi, dword [eax + 4] . mov esi, ebx . mov edx, var . mov ecx, edi . xor eax, eax . lock cmpxchg dword [edx], ecx . test eax, eax . je var . cmp eax, edi . jne var . xor esi, esi . inc esi . cmp dword [var], 1 . jne var . push var . call sub.msvcrt.dll__amsg_exit . pop ecx . jmp var . push var . call dword [sym.imp.KERNEL32.dll_Sleep] . jmp var . cmp dword [var], ebx . jne var . mov dword [var], 1 . push var . push var . call var . pop ecx . pop ecx . test eax, eax . je var . jmp var . mov dword [var], 1 . cmp dword [var], 1 . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test esi, esi . jne var . xor eax, eax . mov ecx, var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 9 . mov dword [var], eax . call var . mov dword [var], eax . push ebp . lea eax, [psfi] . push var . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov ebx, var . push eax . push ebx . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . push var . mov dword [var], eax . pop edi . mov eax, ebx . cmp word [var], di . jne var . mov esi, edi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov ecx, eax . mov dword [var], ecx . jmp var . push var . pop edx . cmp ax, dx . jne var . inc ecx . inc ecx . cmp word [ecx], dx . je var . cmp word [ecx], di . mov dword [var], edx . jne var
call var . jmp var . int . int . int . int . int . int . int . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 3] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 4] . mov ecx, dword [var] . sub eax, ecx . ret . int . int . int . int . int . push ebp
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . xor ecx, ecx . cmp eax, dword [ecx*8 + var] . je var . inc ecx . cmp ecx, var . jb var . lea ecx, [eax - var] . cmp ecx, var . ja var . push var . pop eax . pop ebp . ret . mov eax, dword [ecx*8 + var] . pop ebp . ret . add eax, var . push var . pop ecx . cmp ecx, eax . sbb eax, eax . and eax, ecx . add eax, 8 . pop ebp . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, 8 . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, var . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . call var . mov ecx, dword [var] . push ecx . mov dword [eax], ecx . call var . pop ecx . mov esi, eax . call var . mov dword [eax], esi . pop esi . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . pushfd . test eax, var . fiadd word [esi - var] . invalid . leave . test dword [esi - var], esi . cmp ebp, dword [edx] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push eax . outsd dx, dword [esi] . jb var . insd dword es:[edi], dx . popal . outsb dx, byte [esi] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax + eax], bl . push esp . and eax, dword [eax] . add byte [eax], al . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add al, ch . sub byte [eax], al . test dl, dl . dec ecx . add byte [eax], al . add byte [eax], al . add byte [eax + var], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], ah . inc eax . add byte [ecx], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 9 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
lea esi, [ebx] . jmp loc.00402987 . test eax, eax . xor eax, eax . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [esp + var] . xor ecx, ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . mov word [esp + var], var . mov edx, dword [esp + var] . mov esi, dword [esp + var] . mov dword [esp + var], ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . movzx edi, word [esp + var] . mov bx, di . or edi, var . mov word [esp + var], di . mov edi, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, var . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . sub eax, ecx . mov ecx, dword [esp + var] . sbb ecx, edi . mov dword [esp + var], eax . mov dword [esp + var], ecx . mov byte [esp + var], var . mov eax, dword [esp + var] . mov ecx, var . sub ecx, eax . mov ecx, dword fs:[ecx] . mov word [esp + var], bx . mov eax, dword [ecx + var] . add eax, var . mov cl, byte [esp + var] . mov dword [esp + var], var . mov edi, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, var . sub eax, edi . mov edi, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . sbb edi, eax . mov dword [esp + var], esi . mov word [esp + var], bx . mov dword [esp + var], edx . mov dword [esp + var], edi . mov byte [esp + var], cl . jb var
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . call var . call var . call var . call var . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, var . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var] . cmp eax, dword [edx + var] . jne var . lea edx, [var] . mov eax, dword [var] . mov ecx, dword [eax] . call dword [ecx + 4] . cmp dword [var], 0 . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . cmpsb byte [esi], byte ptr es:[edi] . ficom dword [eax] . and al, var . test cl, bl . inc esp . mov al, byte [var] . out dx, al . xchg eax, edi . mov dh, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], dl . inc ecx . push edx . xor eax, dword [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add eax, var . mov edx, var . test esp, var . mov ah, var . or byte [edx + edi*4 - var], ah . cwde . lcall var . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax - var], al . push esp . mov ebx, var . movsd dword es:[edi], dword ptr [esi] . cmpsd dword [esi], dword ptr es:[edi] . xlatb . sbb dword [ecx], edx . push ss . xchg byte [edi], dh . add byte [eax], al . add dword [eax], eax . add byte [eax], al . xor byte [ecx], dh . inc edx . sub eax, var . jb var . jb var . jae var . xor eax, var . xor byte [eax], dh . jge var . add byte [eax], al . add byte [ecx], al . add byte [edx], bl . add byte [eax + var], ah . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add al, bl . and eax, var . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax], ah . pushfd . jno var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . pushal . adc dword [eax], eax . add dword [eax], eax . pop ds
pushal . call var . jmp var . push ebp . ret . call var . eb5d jmp var . pop ebp . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [var], 0 . mov dword [var], ebx . jne var . lea eax, [var] . push eax . call dword [var] . mov dword [var], eax . mov esi, eax . lea edi, [var] . push edi . push esi . call dword [var] . stosd dword es:[edi], eax . mov al, 0 . scasb al, byte es:[edi] . jne var . cmp byte [edi], al . jne var . lea eax, [var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[esi + var], dl . jb var . jne var . insb byte es:[edi], dx . push eax . jb var . je var . arpl word [eax + eax], si . mov ebx, dword [ebp + var] . or ebx, ebx . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4]
sub esp, var . push ebx . push ebp . push esi . xor esi, esi . push edi . mov dword [var], esi . mov ebx, str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push esi . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push esi . lea eax, [psfi] . push var . push eax . push esi . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . mov ebp, var . push ebp . push var . call dword [sym.imp.KERNEL32.dll_GetTempPathA] . call var . test eax, eax . jne var . push var . push ebp . call dword [sym.imp.KERNEL32.dll_GetWindowsDirectoryA] . push str.Temp . push ebp . call var . call var . test eax, eax . je var . mov edi, var . push edi . call dword [sym.imp.KERNEL32.dll_DeleteFileA] . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . push eax . push edi . call var . push 0 . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . mov cl, byte [eax] . test cl, cl . je var . cmp cl, var
push ebp . push esp . xor ecx, ecx . mov dword [var], ebx . add ecx, 4 . cmp ecx, 1 . je var . pop eax . add eax, ecx . pop dword [var] . mov dword [var], eax . cmp ecx, 0 . jne var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . call var . mov ecx, dword [var] . mov edx, dword [var] . sub ecx, var . setb bl . mov dword [var], eax . xor eax, eax . test edx, edx . mov bh, al . mov dword [var], ecx . mov byte [var], bh . mov byte [var], bl . je var . mov al, byte [var] . mov byte [var], al . mov al, byte [var] . test al, al . jne var . jmp var . mov eax, dword [var] . lea esp, [var] . pop ebx . pop ebp . ret . mov eax, var . mov ecx, var . mov edx, dword [var]
call var . sub eax, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], bh . pushal . sbb al, byte [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . var . var . var . add byte [eax], al . add byte [eax], al . dec ebx . inc ebp . push edx . dec esi . inc ebp . dec esp . xor esi, dword [edx] . insb byte es:[edi], dx . insb byte es:[edi], dx . add byte [eax], al . add byte [eax], al . inc edi . je var . jb var . arpl word [ecx + var], ax . jb var . jae var . add byte [eax], al . add byte [edi + var], al . je var . outsd dx, dword [esi] . jne var . dec eax . popal . outsb dx, byte [esi] . insb byte es:[edi], dx . inc ecx . add byte [eax], al . add byte [edi + ebp*2 + var], cl . dec esp . imul esp, dword [edx + var], var . add byte [edx - var], ah . push ecx . add byte [eax], al . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . mov dword [var], eax . push es . fmul qword [ecx - var] . lcall var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . inc ebx . push ebp . dec esp . dec esp . dec ecx . push ebx . xor al, byte [eax] . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or edx, esp . pop es . in eax, var . int var . jp var . lahf . mov bl, byte es:[esi + var] . jl var . mov ch, var . test byte [edi + var], ah . inc esi . test eax, var . loopne var . push eax . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . 0000 add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, dword [var] . call var . ret . ret . int . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . int . int . int . int . int . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, var . mov edx, var . mov dword [var], var . mov esi, dword [var] . mov edi, esi . or edi, var . mov dword [var], edi . mov dword [var], var . mov edi, dword [var] . mov ebx, dword [var] . mov dword [var], eax . mov eax, var . mov dword [var], 0 . mov dword [var], var . sub edx, esi . mov dword [var], edx . cmp ecx, eax . mov dword [var], ebx . mov dword [var], edi . jbe var . jmp var . xor eax, eax . mov ecx, dword [var] . mov edx, dword [ecx + var] . add ecx, edx . mov esi, dword [var] . mov edx, dword [esi + edx] . mov edi, dword [var] . add edi, var . mov dword [var], 0 . mov dword [var], var . cmp edx, edi . cmove eax, ecx . lea esp, [var] . pop esi . pop ebx . pop edi . pop ebp . ret
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], bh . or dword [ebx + esi + var], eax . mov edi, var . cmp al, var . add byte es:[eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . outsb dx, byte [esi] . and byte [var], bh . dec edi . inc esp . dec ebx . dec edi . push esi . pop ecx . push edx . dec edi . push esi . cmp byte [eax], al . inc ebx . insb byte es:[edi], dx . imul esp, dword [ebp], var . int . xor dword [eax], eax . pop es . wait . cli . jae var . dec esp . in eax, var . dec edx . mov dl, var . sub esp, dword [ecx] . sub eax, var . inc ebx . dec ebp . mov al, var . jg var . dec esi . lahf . std . mov dword [var], eax . push var . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . mov eax, var . mov ecx, var . mov edx, var . call var . mov eax, var . mov ecx, 9 . mov edx, 9 . call var . mov eax, var . mov ecx, 3 . mov edx, 3 . call var . mov eax, var . mov ecx, 3 . mov edx, 3 . call var . mov eax, dword [var] . mov ecx, var . mov edx, var . call var . call var . lea edx, [var] . xor eax, eax . call var . mov eax, dword [var] . call var . cmp eax, var . jle var . call var . call var . mov eax, var . mov ecx, 3 . mov edx, 3 . call var . call var . test eax, eax . je var . lea edx, [var] . xor eax, eax . call var . mov eax, dword [var] . push eax . lea eax, [var] . mov edx, var . mov ecx, 3 . call var . mov edx, dword [var] . pop eax . call var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, var . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . add byte [eax], al . mov al, 4 . add al, byte [eax] . invalid . invalid . invalid . call dword [ecx] . add byte [eax], al . add byte [ebx], dl . outsd dx, dword [esi] . add byte [esi], ah . je var . xor eax, dword [eax] . xor al, byte [eax] . and byte [eax], al . inc esp . add byte [edi], ch . ja var . outsb dx, byte [esi] . add byte [eax + eax + var], ch . add byte [ecx], ah . add byte fs:[ebp], ah . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx + var], cl . test byte [edx], dl . dec edi . pushfd . fiadd dword [edx + esi*4 + var] . cmpsd dword ds:[esi], dword ptr es:[edi] . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec ebp . imul esp, dword [ebx + var], var . popal . xor byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], al . add byte [eax], al . add byte [eax + var], ch . add byte [eax], al . add byte [eax + var], al . add byte [eax], al . add byte [eax], ch . and dword [eax], eax . pop es . add byte [eax], al . add al, bl . and byte [eax], al . pop es . add byte [eax], al . add byte [eax + var], dh . add byte [ecx], al . add byte [edx], al . add byte [eax + var], dl . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [esi + ebx + var], al . add byte [eax + eax*4], bh
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00413dd2 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec ebp . and byte [ecx], dh . xor esi, dword [edi - var] . dec esi . xchg eax, edi . loop var . insd dword es:[edi], dx . or al, var . or al, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . and byte [eax], ah . and byte [eax], ah . cmp eax, var . js var . add byte gs:[edx], cl . add byte [eax], al . add byte [eax], al . push es . add byte [eax], al . add ah, ch . sub byte [eax], al . pop es . add byte [eax], al . add byte [ecx + var], bh . add byte [eax], al . and dword fs:[eax], eax . pop es . add byte [eax], al . add byte [eax], dl . and dword [eax], eax . pop es . add byte [eax], al . add ah, cl . and byte [eax], al . pop es . add byte [eax], al . add byte [eax + var], ch . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax], bl . and byte [eax], al . add dword [eax], eax . add al, byte [eax] . jl var . inc eax . add byte [eax], al . add byte [eax], al . add bh, bh
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx], al . loop var . mov al, byte cs:[var] . stosb byte es:[edi], al . invalid . salc . aas . jb var . mov esp, 0 . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . add byte [esi], al . push eax . add dword [ecx], var . popal . jns var . insb byte es:[edi], dx . imul ebp, dword [esi + var], var . xor dword [eax], eax . daa . add eax, dword [eax] . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . adc cl, byte [edx] . cwde . pop esi . test al, var . xchg eax, ebx . dec esi . mov dh, var . adc dl, bh . out var, al . and dword [edi + 1], var . xlatb . mov ecx, var . shl byte ss:[eax + var], cl . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push ebp . mov ebp, esp . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push dword [ExceptionInfo] . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . pop ebp . ret . ├ 251: loc.00410599 (int2_t var, int2_t var) . push ebp . mov ebp, esp . sub esp, var . push var . call sub.KERNEL32.dll_IsProcessorFeaturePresent . test eax, eax . je var . push 2 . pop ecx . int var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov dword [var], 1 . push 4 . pop eax . imul eax, eax, 0 . mov dword [eax + var], 2 . push 4 . pop eax . imul eax, eax, 0 . mov ecx, dword [var] . mov dword [ebp + eax - 8], ecx . push 4 . pop eax . shl eax, 0 . mov ecx, dword [section..data]
call var . jmp var . ├ 262: loc.00403caf (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_IsDebuggerPresent] . mov dword [var], eax . push 1 . call var . pop ecx . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . cmp dword [var], 0 . jne var . push 1 . call var . pop ecx . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . leave . ret . sub eax, var . je var . sub eax, 4 . je var . sub eax, var . je var . dec eax . je var
xor dword [var], esi . xor dword [var], eax . call var . mov dword [var], eax . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . mov esi, var . mov edi, dword [var] . mov ebx, dword [var] . mov dword [var], eax . mov eax, var . mov dword [var], eax . mov eax, edi . mov dword [var], ecx . mov ecx, dword [var] . mov dword [var], edx . mul ecx . imul ecx, ebx, var . add edx, ecx . mov dword [var], eax . mov dword [var], edx . mov dword [var], var . mov eax, dword [var] . sub esi, eax . mov dword [var], var . mov dword [var], esi . mov ecx, dword [var] . cmp ecx, 0 . mov dword [var], ebx . mov dword [var], edi . mov dword [var], eax . je var . jmp var . mov eax, dword [var] . mov ecx, dword [var] . imul eax, ecx . mov edx, dword [var] . mov dword [var], eax . mov eax, edx . mul edx . mov esi, dword [var] . add edx, esi . add edx, esi . mov edi, dword [var] . mov dword [var], eax . mov dword [var], edx . mov eax, dword [var] . xor eax, var . mov edx, dword [var] . mov dword [var], ecx . mov dword [var], eax . xor eax, eax . mov ebx, var . mov ecx, dword [var] . sub ebx, ecx . mov ecx, dword [var]
push ebp . push ebx . xor edx, edx . add edx, var . lea ecx, [var] . mov dword [edx + ecx + 1], esi . mov ecx, var . lea edx, [var] . mov dword [edx + ecx], ebp . mov eax, esp . mov ecx, 4 . add eax, ecx . lea edx, [var] . add eax, ecx . xor ecx, ecx . add ecx, var . mov dword [edx + ecx], eax . lea edx, [var] . mov dword [edx], edi . lea edx, [var] . inc edx . pop ecx . inc edx . add esp, 4 . mov dword [edx], ecx . call var . cmp eax, var . jne var . mov eax, ecx . lea ecx, [var] . xchg eax, ecx . xor eax, var . mov ecx, edx . xor eax, var . and ecx, var . inc ecx . xor eax, var . jmp eax . mov edx, 3 . xor eax, eax . ret . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [ebp + 8] . mov dword [ebp - 4], var . cmp dword [ebp - 4], var . mov dword [ebp - var], eax . ja var . xor eax, eax . mov dword [ebp - 8], var . mov dword [esp], 0 . mov dword [esp + 4], 0 . mov dword [ebp - var], eax . call var . add esp, var . pop ebp . ret . call var . mov ecx, esp . mov edx, dword [ebp - var] . mov dword [ecx + 4], edx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . jg var . dec esp . sbb byte [edi - var], al . and dword [esi - var], eax . sbb al, var . sub al, var . cmp byte [esi], dl . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax + var], dh . jae var . dec esp . jae var . jb var . outsd dx, dword [esi] . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . clc . dec eax . out dx, al . mov esp, var . push cs . jae var . xor cl, dl . cld . jno var . xor al, var . out dx, al . 36f6024a test byte ss:[edx], var . test byte [edx], var . movsd dword es:[edi], dword ptr [esi] . mov ebx, dword [esi - var] . sar byte [edx], 1 . xchg eax, ebp . call var . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . xor ecx, ecx . cmp eax, dword [ecx*8 + var] . je var . inc ecx . cmp ecx, var . jb var . lea ecx, [eax - var] . cmp ecx, var . ja var . push var . pop eax . pop ebp . ret . mov eax, dword [ecx*8 + var] . pop ebp . ret . add eax, var . push var . pop ecx . cmp ecx, eax . sbb eax, eax . and eax, ecx . add eax, 8 . pop ebp . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, 8 . ret . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . xor eax, ebp . mov dword [ebp - 4], eax . push ebx . xor ebx, ebx . push esi . mov esi, dword [ebp + 8] . push edi . mov dword [ebp - var], ebx . mov dword [ebp - var], ebx . mov dword [ebp - var], ebx . mov dword [ebp - var], ebx . mov dword [ebp - var], ebx . mov dword [ebp - var], esi . mov dword [ebp - var], ebx . cmp dword [esi + var], ebx . je var . lea eax, [esi + 4] . cmp dword [eax], ebx . jne var . push eax . movzx eax, word [esi + var]
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl . lea ecx, [eax + var]
call var . mov dword [var], eax . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov esi, dword [esp + var] . xor esi, var . cmp eax, esi . mov dword [esp + var], eax . mov dword [esp + var], ecx . mov dword [esp + var], edx . je var . jmp var . mov eax, dword [esp + var] . mov dword [esp + var], eax . jmp var . mov dword [esp + var], 0 . jmp var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . mov dl, byte [ecx] . mov ecx, dword [esp + var] . mov byte [ecx + eax], dl . mov eax, dword [esp + var] . add eax, 1 . mov dword [esp + var], eax . mov esi, dword [esp + var] . cmp eax, esi . je var . jmp var . mov eax, dword [esp + var] . and eax, var . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], 0 . cmp eax, 0 . je var . jmp var . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . mov esi, dword [esp + var] . add esi, eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, var . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . add byte [eax], al . mov al, 4 . add al, byte [eax] . invalid . invalid . invalid . call dword [ecx] . add byte [eax], al . add byte [ebx], dl . outsd dx, dword [esi] . add byte [esi], ah . je var . xor eax, dword [eax] . xor al, byte [eax] . and byte [eax], al . inc esp . add byte [edi], ch . ja var . outsb dx, byte [esi] . add byte [eax + eax + var], ch . add byte [ecx], ah . add byte fs:[ebp], ah . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . mov ecx, var . push 0 . push 0 . dec ecx . jne var . push ebx . push esi . push edi . mov eax, var . call var . mov edi, var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . mov eax, var . call var . mov eax, dword [var] . mov byte [eax], 1 . push var . call sub.KERNEL32.DLL_SetErrorMode . lea edx, [var] . mov eax, 1 . call var . mov eax, dword [var] . mov edx, var . call var . jne var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 0 . push 0 . push 0 . mov eax, dword [var] . call var . push eax . push var . push 0 . call sub.shell32.dll_ShellExecuteW . push 0 . call sub.KERNEL32.DLL_ExitProcess . lea edx, [var] . mov eax, 1 . call var . mov eax, dword [var] . mov edx, var . call var . jne var . push var . call sub.KERNEL32.DLL_Sleep . mov eax, edi . mov edx, var . call var . lea edx, [var] . xor eax, eax . call var . push edi
mov dword [var], esi . mov dword [var], edi . mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . push ebx . mov dword [var], ebx . push ebp . mov dword [var], ebp . push esp . mov eax, esp . mov ecx, 4 . add eax, ecx . mov dword [var], esp . add dword [var], var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov edi, dword [esp + var] . mov ebx, dword [esp + var] . mov ah, byte [edx + ecx] . xor edi, var . or edi, ebx . mov byte [esp + var], al . mov dword [esp + var], ecx . mov dword [esp + var], edi . mov dword [esp + 8], esi . mov byte [esp + 7], ah . jne var . jmp var . mov al, byte [esp + 7] . mov cl, byte [esp + var] . sub al, cl . mov edx, dword [esp + 8] . mov esi, dword [esp + var] . mov byte [edx + esi], al . lea esp, [ebp - var] . pop ebx . pop edi . pop esi . pop ebp . ret . push ebp
imul ebx . mov edx, esp . mov ecx, ebp . mov eax, ebx . cmp edx, var . mov dword [var], edx . mov dword [var], ebp . mov dword [var], eax . jg var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push esi . push edi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, var . mov dword [esp + var], var . mov ebx, var . mov byte [esp + var], al . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . add eax, eax . mov dword [esp + 8], eax . mov eax, dword [esp + var] . adc eax, eax . mov dl, byte [edx + ecx] . mov dh, byte [esp + var] . sub dl, dh . add esi, ecx . mov ecx, dword [esp + 8] . mov dword [esp + var], ecx . mov dword [esp + var], eax . cmp edi, ebx . mov byte [esp + 7], dl . mov dword [esp], esi . je var . mov eax, dword [esp] . mov cl, byte [esp + 7] . mov byte [eax], cl . lea esp, [ebp - var] . pop edi . pop esi . pop ebx . pop ebp . ret . push ebp . mov ebp, esp . push esi . push ebx . push edi
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . or ebp, var . jmp var . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], var . mov eax, esi . pop esi . pop ebp . ret 4 . mov ah, var . test eax, var . sub ecx, ecx . sbb byte fs:[esi - var], ah . and al, var . xor byte [edi + var], cl . or byte [var], cl . push ebp . mov ebp, esp . push esi . push dword [var] . mov esi, ecx . call var . mov dword [esi], var . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], str.bad_array_new_length . mov dword [ecx], var . ret . cld . push edx . salc . xor bh, byte [edi - var] . outsd dx, dword [esi] . mov byte [edi + var], bl . std . sbb ebx, dword [ecx] . sub byte [edi + var], dh . lea edx, [var] . jno var . xlatb . jne var . and ecx, dword [edx - var] . popal . test eax, var . mov byte [var], al . xchg dword [edi - var], edi . loop var . movsd dword es:[edi], dword ptr [esi] . push edi . push esp . aas . mov dword [var], eax . imul ecx, dword [ebx + eax + var], var . mov dword [esi + var], var . mov eax, dword [ecx + 4]
pushal . call var . jmp var . push ebp . ret . call var . jmp var . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[ebx + var], cl . add byte [ebx], cl . invalid . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4] . add eax, var . push 4 . push var . push eax . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . push esi
push ebp . push ebx . xor eax, eax . lea edx, [var] . add edx, var . mov dword [edx + var], ebp . lea edx, [var] . mov dword [edx], esi . mov esi, ecx . mov ecx, esp . add ecx, 8 . lea edx, [var] . mov dword [edx], ecx . lea edx, [var] . mov dword [edx], edi . lea edx, [var] . pop ecx . add edx, var . mov dword [edx], ecx . pop ecx . lea eax, [var] . add eax, var . jmp eax . xor eax, eax . ret . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . push edi . push ebx . push esi . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . mov dword [var], var . mov dword [var], var . cmp ecx, 0 . sete bl . cmp edx, 0 . sete bh . or bh, bl . mov esi, dword [var] . mov edi, esi . add edi, var . mov dword [var], edi . test bh, 1 . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], esi . jne var . jmp var . mov eax, dword [var] . add eax, 1 . mov dword [var], eax . cmp eax, var . je var . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov eax, dword [eax*4 + var] . mov dword [var], eax
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00413c62 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov eax, esi . push eax . add eax, 5 . call var . mov edx, edi . mov eax, 8 . push edx . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], bh . add byte [eax], al . add byte [var], al . invalid . cmp eax, dword [ebx - var] . into . and dword [eax], edi . add dword [ecx + var], var . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebp + var], dh . add byte gs:[eax], al . add byte [eax], al . je var . add byte gs:[eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . xchg eax, ebp . sbb dword [ebx], eax . and al, var . shr dword [edi + var], cl . xchg eax, edi . ror esp, var . mov dl, byte [edx + ecx*2 + var] . or dl, ah . dec edi . add eax, var . mov ebp, var . scasb al, byte es:[edi] . adc edi, dword es:[edx] . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push ebp . mov ebp, esp . push dword [var] . call var . pop ecx . pop ebp . ret . push var . push var . call var . mov byte [var], 0 . mov ebx, dword [var] . mov eax, ebx . mov edi, dword [var] . imul eax, edi . mov esi, dword [var] . add esi, eax . mov dword [var], esi . and dword [var], 0 . mov eax, edi . dec edi . mov dword [var], edi . test eax, eax . je var . sub esi, ebx . mov dword [var], esi . mov ecx, dword [var] . call dword [var] . mov ecx, esi . call dword [var] . jmp var . mov al, 1 . mov byte [var], al . mov dword [var], var . call var . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop esi . pop ebx . leave . ret var . mov edi, dword [ebp + var] . mov ebx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov al, byte [ebp - var] . test al, al . jne var . push dword [var] . push edi . push ebx . push esi . call var . ret . push var . push var . call var . xor esi, esi . mov dword [var], esi . mov edi, dword [var] . mov dword [var], esi
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . call var . jmp var . push ebp . ret . call var . jmp var . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[ebx + var], cl . add byte [ebx], cl . invalid . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4] . add eax, var . push 4 . push var . push eax . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . push esi
push ebp . mov ebp, esp . sub esp, var . push edi . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . jmp var . mov eax, dword [var] . add eax, 1 . mov dword [var], eax . cmp dword [var], var . jae var . push var . call dword [sym.imp.USER32.dll_CharLowerW] . jmp var . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_GetAsyncKeyState] . call dword [sym.imp.GDI32.dll_GdiFlush] . mov edx, dword [var] . push edx . call dword [sym.imp.GDI32.dll_WidenPath] . call dword [sym.imp.USER32.dll_GetForegroundWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.GDI32.dll_GetTextCharset] . push str.loJCgnmKgZ . call dword [sym.imp.GDI32.dll_GetEnhMetaFileW] . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_GetThreadDesktop] . mov edx, dword [var] . push edx . call dword [sym.imp.USER32.dll_GetTopWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.GDI32.dll_GetStockObject] . mov ecx, dword [var] . push ecx . call dword [sym.imp.GDI32.dll_CreateCompatibleDC] . push str.LTBnjwOIbU . call dword [sym.imp.GDI32.dll_AddFontResourceW] . mov edx, dword [var] . push edx . call dword [sym.imp.GDI32.dll_GetTextAlign] . call dword [sym.imp.USER32.dll_GetKBCodePage] . mov eax, dword [var] . push eax . call dword [sym.imp.USER32.dll_GetKeyState] . call dword [sym.imp.USER32.dll_GetDesktopWindow] . call dword [sym.imp.USER32.dll_GetMessagePos] . movzx ecx, word [var] . push ecx . call dword [sym.imp.USER32.dll_IsCharUpperW] . mov edx, dword [var] . push edx . call dword [sym.imp.USER32.dll_GetTopWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.USER32.dll_GetSystemMetrics] . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_CloseDesktop]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx - var], al . mov dword [var], eax . mov eax, var . xchg eax, esi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . arpl word [edi + var], bp . je var . arpl word [edi + ebp*2 + var], si . imul esp, dword [ebp + var], 0 . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . mov cs, word [esi + var] . inc eax . mov dl, byte [eax - var] . pop es . int var . nop . and edi, dword [ebp - var] . pop eax . dec esi . mov dh, byte [ebp - var] . mov edi, var . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov dword [var], esi . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . add edx, edx . jmp section..text . jmp section..text . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . xor edx, edx . mov dword [esp + var], edx . mov dword [esp + var], var . mov esi, var . mov dword [esp + var], esi . mov edi, dword [esp + var] . mov dword [esp + var], var . mov word [esp + var], var . mov dword [esp + var], edx . mov dword [esp + var], var . mov dword [esp + var], edx . mov dword [esp + var], var . movzx edx, word [esp + var] . mov bx, dx . mov dword [esp + var], eax . lea eax, [esp + var] . and edx, var . mov word [esp + var], dx . mov edx, dword [sym.imp.USER32.dll_FindWindowW] . call edx . xchg eax, ebx . add al, var . xchg eax, ebx . loope var . push ecx . mov ebx, var . aad var . xchg dword [edi], esi . push varffffffe3 . pop eax . mov byte fs:[var], al . inc ebx . bnd call var . push esp . and dword [edx], esi . out dx, eax . pop ecx . das . fdivr qword [ecx - var] . or byte [ecx - var], var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . call var . pop ebp . mov eax, ebp . sub ebp, var . sub eax, dword [ebp + var] . mov dword [ebp + var], eax . mov al, 0 . xchg byte [ebp + var], al . cmp al, 1 . jne var . mov eax, dword [ebp + var] . sub eax, dword [ebp + var] . mov eax, dword [eax] . mov dword [ebp + var], eax . mov eax, dword [ebp + var] . sub eax, dword [ebp + var] . mov eax, dword [eax] . mov dword [ebp + var], eax . cmp dword [ebp + var], 0 . je var . cmp dword [ebp + var], 0 . je var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dl, ch . mov dl, var . jle var . xor esp, dword [edi + var] . mov ebp, var . xchg ax, bp . xchg dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx + var], dl . outsd dx, dword [esi] . jne var . imul ebp, dword [esi + var], 0 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [esi], al . add byte [ebx + var], dh . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax - var], ch . pushal . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax + var], ah . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], dl . adc al, var . add byte [ecx], al . add byte [edx], al . add byte [ebx + var], dh . add byte [eax], al . invalid . invalid
push ebp . mov ebp, esp . mov ecx, var . push 0 . push 0 . dec ecx . jne var . push ecx . push ebx . push esi . push edi . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . push 0 . call sub.ole32.dll_CoInitialize . mov eax, dword [var] . mov byte [eax], 1 . call var . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . lea ecx, [var] . mov edx, var . mov eax, dword [var] . call var . mov edx, dword [var] . mov eax, dword [var] . call var . lea edx, [var] . xor eax, eax . call var . mov eax, dword [var] . lea edx, [var] . call var . push dword [var] . lea edx, [var] . mov eax, var . call var . push dword [var] . push var . lea eax, [var] . mov edx, 3 . call var . mov eax, dword [var] . call var . test al, al . je var . mov eax, var . mov edx, dword [var] . mov edx, dword [edx] . call var . lea edx, [var] . xor eax, eax
push ebp . mov ebp, esp . push varffffffff . push 0 . push 0 . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . push ebx . call var . push var . push 0 . push var . call var . push eax . push edx . push ebx . push esi . call var . push esi . push var . push 0 . call var . push var . push edi . call var . push var . push var . push ecx . call var . push ecx . push 0 . call var . push 2 . call var . push ebx . call var . pop edi . push dword [ecx] . xchg dword [esp], edi . push var . push var . call var . push ebx . push ecx . call var . push ecx . call var . push ecx . push edi . push ebx . call var . push ebx . call var . push var . cmp ecx, ebx . jae var . ret . pop ebp . call var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . je var . inc ecx . test eax, var . cdq . sbb al, var . xlatb . aam var . adc eax, var . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], cl . outsb dx, byte [esi] . popal . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [edx], al . add byte [esi + ebx + var], dh . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + var], ch . inc eax . add byte [eax], cl . dec ecx . add byte [eax], al . add byte [eax], al . add byte [eax], ch . dec esp . outsb dx, byte [esi] . add al, byte [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + edx], ch . inc eax . add byte [esi], al . add byte [eax], al . add byte [var], cl . add byte [eax], al
push ebp . push esp . mov ecx, esi . push ecx . mov ecx, 2 . add ecx, 2 . sub esp, ecx . mov dword [esp], edi . sub esp, ecx . mov dword [esp], ebx . sub esp, ecx . jmp var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp . ret var
call var . mov dword [var], eax . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov esi, dword [esp + var] . mov dword [esp + var], var . mov dword [esp + var], esi . mov edi, dword [esp + var] . mov ebx, dword [esp + var] . mov dword [esp + var], eax . mov eax, edi . add eax, var . mov dword [esp + var], eax . mov eax, ebx . adc eax, 0 . mov dword [esp + var], eax . xor eax, eax . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . cmp eax, ecx . mov dword [esp + var], ebx . mov dword [esp + var], edx . mov dword [esp + var], esi . mov dword [esp + var], edi . je var . jmp var . mov eax, dword [esp + var] . mov dword [esp + var], eax . jmp var . xor eax, eax . mov ecx, dword [esp + var] . mov edx, var . sub edx, ecx . mov ecx, dword [esp + var] . imul ecx, ecx . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . add ecx, edx . mov dword [esp + var], var . mov edx, dword [esp + var] . add edx, ecx . mov esi, dword [esp + var]
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
push ebp . mov ebp, esp . sub esp, var . mov dword [esp], 2 . call dword [sym.imp.msvcrt.dll___set_app_type] . call var . nop . lea esi, [esi] . push ebp . mov ebp, esp . sub esp, var . mov dword [esp], 1 . call dword [sym.imp.msvcrt.dll___set_app_type] . call var . nop . lea esi, [esi] . push ebp . mov ebp, esp . push ebx . sub esp, var . mov eax, dword [var] . mov eax, dword [eax] . mov eax, dword [eax] . cmp eax, var . ja var . cmp eax, var . jb var . mov ebx, 1 . mov dword [func], 0 . mov dword [esp], 8 . call sub.msvcrt.dll_signal . cmp eax, 1 . je var . test eax, eax . jne var . xor eax, eax . add esp, var . pop ebx . pop ebp . ret 4 . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . jmp var . cmp eax, var . je var . cmp eax, var . jne var . mov dword [func], 0 . mov dword [esp], 4 . call sub.msvcrt.dll_signal . cmp eax, 1 . je var . test eax, eax . je var . mov dword [esp], 4 . call eax . mov eax, var . jmp var . xor ebx, ebx . jmp var
call var . cmp eax, 4 . je var . or eax, esp . or eax, 5 . cmp eax, 0 . mov dword [var], eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push ebx . and esp, var . sub esp, var . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . lea eax, [esp + var] . mov ecx, dword [sym.imp.KERNEL32.dll_RtlCaptureStackBackTrace] . call ecx . mov edi, var . sbb eax, var . cmp byte [eax + var], bl . and al, 8 . jmp var . retf . arpl cx, bp . jg var . retf . sbb al, var . shl dword [ecx - var], cl . add dword [ebp - var], var . mov byte [ecx + var], dh . enter varffffcb8a, var . mov cl, var . inc esp . and al, var . mov ecx, dword [esp + var] . xor edx, edx . mov bl, dl . test bl, bl . mov dword [esp + 8], eax . mov dword [esp + 4], ecx . jne var
pushal . call var . jmp var . xchg ebx, ebx . nop . add byte [eax + var], al . add byte [eax + eax*2], cl . inc edx . add ah, dl . and al, var . add byte [eax], dl . push eax . inc edx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . rol byte [edx], 1 . add byte [eax], al . add byte [eax], al . add byte [eax], dh . add al, byte [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + 2], ah . add byte [ebx + var], bh . add ebx, ebp . sub ebx, dword [ebp + var] . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx + var], dh . lcall var . ret var . retf . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push edx . inc ecx . dec ebp . push eax . dec ecx . dec esi . inc edi . dec esp . pop ecx . add byte [eax], ah . inc esi . imul ebp, dword [ebp + var], 0 . add dword [eax], eax . add al, byte [eax] . mov eax, var . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [edi + ebx + var], ch . add byte [eax - var], dh . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax + var], al . das . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], cl . inc eax . add byte [esi], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . sub esp, var . lea eax, [lpWSAData] . push eax . push var . call dword [sym.imp.WS2_32.dll_WSAStartup] . call var . push var . lea eax, [s] . push 0 . push eax . call sub.MSVCRT.dll_memset . lea eax, [s] . push eax . call var . add esp, var . push 0 . call dword [sym.imp.KERNEL32.DLL_ExitProcess] . int . push ebp . lea ebp, [esp - var] . sub esp, var . cmp dword [ebp + var], 0 . jne var . lea eax, [ebp + var] . push eax . call dword [sym.imp.KERNEL32.DLL_GetLocalTime] . jmp var . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [sym.imp.KERNEL32.DLL_FileTimeToLocalFileTime] . lea eax, [ebp + var] . push eax . lea eax, [ebp + var] . push eax . call dword [sym.imp.KERNEL32.DLL_FileTimeToSystemTime] . and dword [ebp - var], 0 . lea eax, [ebp - var] . push eax . call dword [sym.imp.KERNEL32.DLL_GetTimeZoneInformation] . mov ecx, dword [ebp - var] . cmp eax, 2 . jne var . mov eax, dword [ebp + var] . add ecx, eax . neg ecx . mov eax, ecx . jns var . neg eax . cmp word [ebp + var], 6 . jbe var . mov word [ebp + var], 6 . cmp word [ebp + var], 0 . jne var . mov word [ebp + var], 1 . cmp word [ebp + var], var . jbe var . mov word [ebp + var], var . push edi . push var . cdq . pop edi
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov ecx, 4 . mov dword [var], ebx . cmp ecx, 3 . je var . pop eax . add eax, ecx . pop dword [var] . mov dword [var], eax . cmp eax, esp . je var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], var . call var . mov ecx, 1 . mov edx, dword [var] . xor edx, var . cmp eax, edx . mov dword [var], ecx . jne var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . add esp, 8 . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi
call var . jmp var . mov eax, dword [var] . mov dx, word [var] . jmp var . cmp cx, dx . je var . inc eax . inc eax . movzx ecx, word [eax] . test cx, cx . jne var . cmp word [eax], dx . je var . xor eax, eax . ret . push ebp . mov ebp, esp . mov eax, var . sub esp, var . cmp word [var], ax . je var . push ebx . push dword [var] . lea ecx, [var] . call var . mov eax, dword [var] . mov ecx, dword [eax + var] . xor ebx, ebx . cmp ecx, ebx . jne var . mov eax, dword [var] . lea ecx, [eax - var] . cmp cx, var . ja var . add eax, var . movzx eax, ax . jmp var . cmp word [var], var . jae var . lea eax, [var] . push eax . push 2 . push dword [var] . call var . add esp, var . test eax, eax . movzx eax, word [var] . je var . mov ecx, dword [var] . mov ecx, dword [ecx + var] . movzx ax, byte [ecx + eax] . jmp var . push dword [eax + 4] . lea eax, [var] . push 1 . push eax . push 1 . lea eax, [var] . push eax . push var . push ecx . lea eax, [var] . push eax
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . xor esi, esi . push esi . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi . push esi . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . push eax . call main . mov dword [var], eax . push eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . push var . call sub.KERNEL32.DLL_SetThreadLocale . mov eax, dword [var] . mov eax, dword [eax] . mov eax, dword [eax + var] . mov dl, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041dba8 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . push esi . mov esi, ecx . lea eax, [esi + 4] . mov dword [esi], vtable.std::exception.0 . push eax . call var . test byte [ebp + 8], 1 . pop ecx . je var . push var . push esi . call var . pop ecx . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + var], ch . jns var . dec ebx . mov dword [esi], ebp . pop ds . pop ss . xor eax, var . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx + var], ch . outsb dx, byte [esi] . and byte [var], bh . jae var . jae var . xor byte [eax], al . and cl, byte [var] . add byte gs:[eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or byte [eax - var], bh . and al, var . dec edx . wait . push varffffffcd . ljmp var . loopne var . popal . fimul dword [edi + var] . mov al, var . invalid . out var, al . adc dword [eax - var], esp . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . mov eax, 5 . dec eax . mov ecx, eax . mov edx, ebx . sub esp, ecx . mov dword [esp], edi . sub esp, ecx . mov dword [esp], edx . sub esp, ecx . jmp var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp . ret var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var]
xor ecx, ecx . add ecx, var . mov eax, var . or eax, ecx . sub eax, var . and eax, ecx . lea edx, [var] . mov dword [edx], ebx . lea ecx, [var] . mov edx, edi . mov dword [ecx - var], edx . add esi, var . lea edx, [var] . mov eax, esp . add edx, var . lea ecx, section..qdata . mov dword [edx], eax . mov eax, esi . lea edx, [var] . sub eax, var . sub edx, var . mov dword [var], eax . mov esi, eax . mov dword [edx], ebp . jmp ecx . mov dword [ebp - 4], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . leave . push cs . sbb eax, var . inc eax . sahf . fdiv qword [esi + var] . salc . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec ebp . outsd dx, dword [esi] . je var . outsd dx, dword [esi] . jae var . add byte [eax], al . add byte [eax], al . add byte [esi], al . add byte [eax], al . add byte [eax + var], al . add byte [eax], al . add byte [ebx + var], cl . add byte [edi], al . add byte [eax], al . add al, dh . and al, byte [eax] . pop es . add byte [eax], al . add byte [eax + var], ah . add byte [eax], al . add byte [edx + var], al . add byte [edi], al . add byte [eax], al . add al, bl . and dword [eax], eax . pop es . add byte [eax], al . add byte [eax + var], dl . add byte [eax], al . add byte [ecx + var], al . add byte [edi], al . add byte [eax], al . add byte [ecx], al . inc eax . add byte [ecx], al . add byte [edx], al . add byte [eax + var], ah . inc eax
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . test eax, eax . je var . cmp eax, var . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor eax, esi . and eax, var . pop esi . jne var . mov eax, var . mov dword [var], eax . not eax . mov dword [var], eax . leave . ret . int . int . int . int . int . cmp ecx, dword [var] . jne var . test ecx, var . jne var . ret . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push edi
mov eax, dword [var] . sub eax, 0 . je var . add eax, 4 . sub eax, 4 . call var . jmp var . mov dword [ebp - 4], eax . int . int . int . int . push ebp . mov ebp, esp . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov dword [var], var . mov dword [var], var . mov eax, var . mov dword [var], eax . call var . add eax, var . mov ecx, dword [var] . xor ecx, var . mov edx, dword [var] . mov esi, dword [var] . mov bl, dl . mov edx, var . xor edi, edi . mov dword [var], ecx . mov cl, bl . mov dword [var], eax . mov eax, edi . shld eax, edx, cl . mov cl, bl . shl edx, cl . test bl, var . cmovne eax, edx . cmovne edx, edi . mov dword [var], eax . mov dword [var], edx . mov eax, dword [var]
push var . call var . ret . ret . stosd dword es:[edi], eax . adc al, var . iretd . push ecx . mov al, byte [var] . and eax, var . dec ebp . or eax, dword [edi] . rcl eax, cl . pop ds . in al, dx . push varffffffc8 . xor esp, edi . xor bl, ch . pop esp . sti . outsb dx, byte [esi] . in al, var . sub al, var . mov eax, var . jns var . mov cl, var . push es . pop edi . mov ebp, var . out var, eax . push esi . dec edx . in eax, var . into . test eax, var . jb var . adc dword [ecx - var], var . or byte [eax - var], bh . and dword [esp + edi], esi . aad var . sub byte [eax], bh . jmp var . aas . mov bh, var . adc esp, dword [esi + var] . adc dword [esi + ebp], ecx . pop es . add ecx, esi . jmp var . jne var . mov esi, var . invalid . invalid . push ebx . inc eax . lahf . adc esi, esp . sahf . mov byte [var], al . invalid . outsd dx, dword [esi] . dec edx . loope var . adc dword [eax + var], ebp
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var] . movdqa xmm3, xmmword [esi + var]
call var . mov dword [var], eax . push ebp . mov dword [ebp - 4], eax . je var . push ebp . xor ecx, var . cmp ecx, 2 . push ebp . mov dword [var], edi . xor ebp, eax . call var . sub dword [var], 6 . call var . add eax, var . ret . mov dword [ebp - 8], eax . sbb eax, var . xor al, byte [edx] . or dl, byte [ecx + var] . mov ebx, var . int . aas . or byte [ebp - var], al . invalid . inc eax . pushal . lea esi, [eax] . cld . ret var . movsb byte es:[edi], byte ptr [esi] . std . or ah, byte [ecx] . sti . test eax, var . jmp var . sti . sbb byte [esp + ebx*2 - var], ah . sub byte [edx + var], cl . movsb byte es:[edi], byte ptr [esi] . adc eax, var . push esi . jl var . lcall var:var . mov al, var . into . aas . adc ch, byte [esi] . dec eax . pop ds . mov dword [edi], ebx . adc dword [edx - var], var . xor eax, var . into . mov esi, var . and ah, byte [edi + var] . sar byte [edi - var], cl . sbb eax, var . xor al, byte [edx] . or dl, byte [ecx + var] . mov ebx, var . int . aas . or byte [ebp - var], al
call var . jmp var . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var] . movdqa xmm3, xmmword [esi + var] . sub ecx, var . movdqa xmm0, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . lea esi, [esi + var] . cmp ecx, var . movdqa xmm2, xmm3 . palignr xmm3, xmm1, var . movdqa xmmword [edi], xmm3 . movdqa xmm4, xmm0
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.DLL_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . push 1 . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . xor esi, esi . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.DLL_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.DLL_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], bh . add byte [eax], al . add bl, ch . or bh, byte [ecx - 1] . imul esi, ecx, var . dec ebp . scasb al, byte es:[edi] . and al, var . test byte [esi], al . adc ebp, esi . xor dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], ah . and byte [edi + var], dl . je var . ja var . add byte [eax], ah . and byte [edi + var], dl . ja var . add byte [eax], ah . and byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . adc al, var . pushal . fidiv dword [edx + var] . stosb byte es:[edi], al . stosb byte es:[edi], al . movsb byte es:[edi], byte ptr [esi] . xchg eax, ebp . push ss . ror byte cs:[eax + var], 1 . push edi . iretd . stosb byte es:[edi], al . dec ebp . inc edi . sahf . ret var . add dword [ebx], ecx . mov bl, var . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ecx, 4 . sub esp, ecx . mov dword [esp], edi . mov eax, ebx . mov edx, esp . add edx, ecx . dec edx . add edx, ecx . inc edx . push edx . push ebx . xchg esi, ecx . sub esp, 4 . mov dword [esp], ecx . mov esi, ecx . call var . cmp ecx, var . xor ecx, eax . call var . cmp eax, var . jne entry0 . push eax . push var . mov dword [var], eax . int . push ebp . mov ebp, esp . push ebx . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . mov edi, var . mov dword [ebp - var], var . mov ebx, dword [ebp - var] . mov dword [ebp - var], ecx . mov ecx, edi . mov edi, eax . shl edi, cl . add ebx, var . mov dword [ebp - var], edi . cmp eax, ebx . mov dword [ebp - var], eax . mov dword [ebp - var], edx . mov dword [ebp - var], esi . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebx . pop ebp . ret var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . xor ecx, var . mov edx, dword [ebp - var] . mov bl, byte [edx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], bl
push ebp . push esp . mov dword [var], ebx . pop dword [var] . add dword [var], 4 . pop dword [var] . push ebp . xor ecx, var . cmp ecx, 2 . je var . pop eax . call var . mov dword [var], eax . xor eax, eax . add eax, var . ret . mov dword [ebp - 4], eax . sbb eax, var . push ds . pop ecx . push var . cmpsd dword [esi], dword ptr es:[edi] . lodsb al, byte [esi] . cwde . nop . movsd dword es:[edi], dword ptr [esi] . xlatb . out var, al . mul byte [ecx] . invalid . in eax, dx . push cs . aaa . adc byte [ebx - var], var . push esp . add dl, byte gs:[var] . int . cmpsb byte [esi], byte ptr es:[edi] . or eax, var . nop . or al, var . cmp ah, byte [eax] . stosd dword es:[edi], eax . sub byte [edx + var], ah . or dword [ecx + var], edx . outsd dx, dword [esi] . pushal . sbb eax, var . sbb eax, var . jb var . jae var . cwde . adc dword [ebp + var], eax . in eax, dx . fucomi st(5) . push cs . aaa . invalid . push var . xor al, var . and ecx, esp . pop ebp . ret var . retf
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.0040329e (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . push esp . mov eax, ebp . add eax, var . xor ecx, ecx . mov edx, ebx . mov dword [var], edx . or eax, edx . add ecx, 4 . cmp eax, 0 . je var . pop edx . add edx, ecx . pop dword [var] . mov dword [var], edx . cmp ecx, 0 . jne var . test eax, eax . je var . mov eax, var . add esp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . mov eax, dword [var] . mov ecx, dword [var] . xor eax, var . mov edx, var . mov dword [var], eax . mul edx . mov esi, dword [var] . imul edi, esi, var . add edx, edi . imul ecx, ecx, var . add edx, ecx . add eax, var . adc edx, var . sub eax, var . seta bl . sub edx, var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . 0000 add byte [eax], al . add byte [eax], al . sbb dword [var], edi . jnp var . mov esi, var . sal dword [ecx], 1 . das . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . inc edi . dec esi . dec edi . push ebx . push esp . dec ecx . inc ebx . dec ecx . pop edx . inc ebp . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . fisttp word [ebx - var] . inc edi . invalid . test byte [esi + edi*4 - var], var . xor ah, ah . fcmove st(0), st(3) . mov ch, var . lodsb al, byte [esi] . inc ebx . lea eax, [esi - var] . xchg eax, esp . jge var . shr byte [ebx + var], var . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . test eax, var . and byte [edi], dl . dec ebx . add dword [edx + var], var . xchg eax, ebp . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . pop eax . les esp, [eax + eax + var] . dec edi . dec esi . inc ebp . dec esp . inc ebp . push esp . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . or ebx, dword [eax - var] . out dx, al . wait . arpl dx, di . inc esp . mov dl, var . test al, var . push edi . arpl word [ecx - 3], ax . cdq . aas . aad var . jne var . inc esp . stosb byte es:[edi], al . test eax, var . inc ebx . out var, al . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jl var . push var . call var . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . push eax . add byte [eax], al . add byte [eax], bh . add byte [eax], al . add byte [eax + var], dl . lea ebp, [edx - var] . test byte [edi], dl . rcr byte [ebx + 9], 1 . xchg byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc eax . add byte [ecx + var], dl . inc ecx . dec ecx . outsb dx, byte [esi] . add byte [ebx + var], dl . insd dword es:[edi], dx . jo var . and byte gs:[ecx + var], al . dec ecx . outsb dx, byte [esi] . and byte [eax + var], dl . outsd dx, dword [esi] . push var . arpl word [eax + eax - var], si . inc eax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [esi], al . add byte [eax + var], ah . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [edx], dl . inc eax . add byte [eax - var], dl . inc eax . add byte [ecx], al . add byte [eax], al . add byte [eax + var], dh . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], dh
push ebp . mov ebp, esp . sub esp, var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax . cmp dword [var], 1 . jmp var . jmp var . jmp var . push 0 . push 0 . push 0 . push var . push 0 . push 0 . call dword [sym.imp.KERNEL32.dll_CreateThread] . mov dword [hObject], eax . cmp dword [hObject], 0 . je var . mov ecx, dword [hObject] . push ecx . call dword [sym.imp.KERNEL32.dll_CloseHandle] . mov eax, dword [var] . mov esp, ebp . pop ebp . ret var . int . int . push ebp . mov ebp, esp . sub esp, var . push esi . push var . lea eax, [lpStartupInfo] . xorps xmm0, xmm0 . push 0 . push eax . mov esi, ecx . movdqu xmmword [lpProcessInformation], xmm0 . call var . mov eax, dword [var] . add esp, var . mov dword [var], eax . mov dword [var], eax . mov eax, dword [var] . or dword [var], var . mov dword [var], eax . xor eax, eax . mov word [var], ax . lea eax, [lpProcessInformation] . push eax . lea eax, [lpStartupInfo] . mov dword [lpStartupInfo], var . push eax . push 0 . push 0 . push 0 . push 1 . push 0 . push 0 . push esi . push 0 . call dword [sym.imp.KERNEL32.dll_CreateProcessW]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add ch, al . ljmp var . xchg eax, ecx . ljmp var:var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push ebx . push esp . push edx . inc ecx . dec esi . inc esp . inc ebp . push ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add edi, dword [ebx - var] . and esi, ecx . dec ebp . sahf . add byte [ebx - var], var . out var, eax . mov ah, var . cmp al, var . in eax, var . test al, var . dec esi . mov al, byte [ebx - var] . invalid . popfd . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . add esi, 2 . cmp word [esi], bx . je var . cmp word [esi], var . jne var . push var . add esi, 2 . pop ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edi], al . adc ebp, dword [edx + edi + var] . mov dh, byte [ebx] . cmp ebx, ebp . invalid . fbstp tbyte [esi - var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push ebx . push ebp . inc edi . inc ecx . push edx . dec ebp . dec edi . push ebp . push esp . dec eax . inc ebp . inc esp . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push es . add byte [eax], al . add byte [eax], ah . xor eax, var . add byte [eax], al . sub al, var . inc eax . add byte [edi], al . add byte [eax], al . add al, ch . and dword [eax], eax . pop es . add byte [eax], al . add byte [eax + var], ch . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax], dl . and dword [eax], eax . add dword [eax], eax . add al, byte [eax] . sbb byte [var], 0 . add bh, bh
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . aaa . adc al, var . pushal . adc byte [ecx - 3], var . mov dl, byte [esi] . ret var . xor ah, byte [ecx] . xchg eax, edi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . js var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add cl, cl . jb var . adc ch, byte [esi + var] . dec eax . mov byte [var], al . lds ebx, [edi + edx*2 - var] . xchg eax, edi . aaa . dec edi . test bh, dl . bound edx, qword [eax + esi*4 - var] . mov esp, var . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], ch . 193dad12fffd sbb dword [var], edi . cmp eax, var . inc edi . lodsb al, byte [esi] . popal . mov ebx, var . mov eax, dword [0] . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . inc edx . inc ebp . push edx . inc ebp . inc ecx . push esi . inc ebp . dec esi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add eax, var . add eax, var . or edx, var . and al, var . adc al, byte [eax + var] . push edx . pop ebp . int1 . neg edi . adc eax, dword [ebp - var] . jge var . cmp dh, byte [ecx + ebp*8 - var] . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
mov eax, ebp . shl eax, 1 . xor eax, ebx . and eax, var . add eax, 3 . mov dword [var], esp . cmp eax, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add esp, var . cmp eax, 2 . jb var . push ebx . push ecx . call var . mov dword [var], eax . add ebp, var . test eax, eax . cmp eax, var . jne var . mov ebx, ebp . xor eax, eax . nop . nop . nop . nop . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . and esp, var . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], eax . call var . mov ecx, var . sub ecx, dword [var] . cmp eax, ecx . je var . mov eax, dword [var] . xor eax, var . mov dword [var], eax . jmp var . mov eax, var . sub eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov esp, ebp
mov eax, dword [esp] . xor eax, 7 . sub eax, ecx . or eax, var . inc eax . mov dword [var], esp . test eax, eax . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add esp, var . cmp eax, 2 . jb var . push ebx . push ecx . call var . mov dword [var], eax . add ebp, var . test eax, eax . cmp eax, var . jne var . mov ebx, ebp . xor eax, eax . nop . nop . nop . nop . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], eax . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . jne var . jmp var . mov eax, dword [var] . xor eax, var . mov dword [var], eax . jmp var . mov eax, dword [var] . add eax, var . mov dword [var], eax . call var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . nop . jne var . pushal . cmp al, var . dec esi . cmpsb byte [esi], byte ptr es:[edi] . cmp esp, ecx . push 4 . ja var . push ss . 0000 add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx], al . push es . push eax . add dword [ecx], var . jbe var . outsb dx, byte [esi] . jae var . add byte fs:[eax], al . add byte [eax], al . add byte [ecx], al . add byte [var], dl . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + ebp + var], dl . inc edi . add byte [eax], al . add byte [eax], al . add byte [eax + var], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + ebx + var], ah . add byte [ecx], al . add byte [edi], dl . add byte [eax + var], dl . inc eax . add byte [eax], al
call var . jmp var . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push ebx . mov ebx, dword [ebp + var] . push esi . mov esi, dword [ebx + 8] . xor esi, dword [var] . push edi . mov eax, dword [esi] . mov byte [ebp - 1], 0 . mov dword [ebp - var], 1 . lea edi, [ebx + var] . cmp eax, var
jmp var . invalid . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . sub esp, var . push ebx . push esi . push edi . push var . xor ebx, ebx . pop ecx . xor eax, eax . lea edi, [var] . mov byte [var], bl . mov esi, dword [sym.imp.MSVCRT.dll_sprintf] . rep stosd dword es:[edi], eax . stosw word es:[edi], ax . stosb byte es:[edi], al . push var . lea eax, [var] . push var . push eax . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], bl . call esi . push var . xor eax, eax . pop ecx . lea edi, [var] . mov byte [var], bl . push var . rep stosd dword es:[edi], eax . stosw word es:[edi], ax . stosb byte es:[edi], al . lea eax, [var] . push var . push eax . call esi . add esp, var . xor eax, eax . lea edi, [var] . mov byte [var], var . push var . mov byte [var], var . pop ecx . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], bl . rep stosd dword es:[edi], eax . stosw word es:[edi], ax . stosb byte es:[edi], al . call var . call var . lea eax, [lpFilename] . push var . push eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . mov edi, str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . pop ecx . mov dword [var], ebp . mov ebx, ebp . mov esi, ecx . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . push var . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . push var . pop ecx . mov dword [var], eax . mov eax, var . cmp word [var], cx . jne var . mov esi, ecx . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ecx . cmp ax, cx . jne var . add esi, 2 . cmp word [esi], cx . je var . push var . pop eax . mov ebp, ecx . cmp word [esi], ax
call var . jmp var . push var . push var . call var . call var . movzx esi, ax . push 2 . call var . pop ecx . mov eax, var . cmp word [var], ax . je var . xor ebx, ebx . jmp var . mov eax, dword [var] . cmp dword [eax + var], var . jne var . mov ecx, var . cmp word [eax + var], cx . jne var . xor ebx, ebx . cmp dword [eax + var], var . jbe var . cmp dword [eax + var], ebx . setne bl . mov dword [var], ebx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . and dword [var], 0 . call var . test eax, eax . jns var . push var . call var . pop ecx . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . test eax, eax . jns var . push 8 . call var . pop ecx . call var . test eax, eax . jns var . push 9 . call var . pop ecx . push 1
call var . cmp eax, 4 . je var . or eax, 1 . or eax, edx . cmp eax, 0 . mov dword [var], eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . pop esi . pop ebp . ret . push ebp . mov ebp, esp . and esp, var . sub esp, var . mov dword [esp + var], var . mov dword [esp + var], var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . lea edx, [esp + var] . mov dword [esp + 8], eax . mov dword [esp + 4], ecx . mov dword [esp], edx . jmp var . mov eax, dword [sym.imp.RPCRT4.dll_RpcServerUnregisterIfEx] . call eax . movsb byte es:[edi], byte ptr [esi] . mov edx, var . mov byte [var], al . adc bh, byte [edi - var] . aaa . invalid . sti . dec eax . jecxz var . pop eax . mov esp, edx . test eax, var . jae var . xchg bh, bl . outsb dx, byte [esi] . arpl word [esi], bp . das . pop edx . in al, var . fmul qword [ecx - var]
sub esp, var . push ebx . push esi . push edi . xor ebx, ebx . push var . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.UXTHEME . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], bl . jne var . push ebp . push 9 . call var . push 7 . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . mov dword [esp], 1 . call dword [sym.imp.msvcrt.dll___set_app_type] . call var . lea esi, [esi] . lea edi, [edi] . sub esp, var . mov dword [esp], 2 . call dword [sym.imp.msvcrt.dll___set_app_type] . call var . lea esi, [esi] . lea edi, [edi] . jmp dword [sym.imp.msvcrt.dll_atexit] . lea esi, [esi] . lea edi, [edi] . jmp dword [sym.imp.msvcrt.dll__onexit] . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . push ebp . mov ebp, esp . push esi . push ebx . sub esp, var . mov dword [esp], str.libgcc_s_dw2_1.dll . call var . sub esp, 4 . test eax, eax . je var . mov dword [esp], str.libgcc_s_dw2_1.dll . mov ebx, eax . call sub.KERNEL32.dll_LoadLibraryA . sub esp, 4 . mov dword [var], eax . mov dword [esp + 4], str.register_frame_info . mov dword [esp], ebx . call sub.KERNEL32.dll_GetProcAddress . sub esp, 8 . mov esi, eax . mov dword [esp + 4], str.deregister_frame_info . mov dword [esp], ebx . call sub.KERNEL32.dll_GetProcAddress . sub esp, 8 . mov dword [section..data], eax . test esi, esi . je var . mov dword [esp + 4], var . mov dword [esp], var . call esi . mov eax, dword [var] . test eax, eax . je var . mov dword [esp], str.libgcj_16.dll . call var . sub esp, 4 . test eax, eax . mov edx, 0
push ebp . mov ebp, esp . sub esp, var . push edi . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . jmp var . mov eax, dword [var] . add eax, 1 . mov dword [var], eax . cmp dword [var], var . jae var . jmp var . mov dword [var], 0 . jmp var . mov ecx, dword [var] . add ecx, 1 . mov dword [var], ecx . cmp dword [var], var . jae var . jmp var . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . sub edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . mov ecx, var . push 0 . push 0 . dec ecx . jne var . push ecx . push ebx . push esi . push edi . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . lea edx, [var] . mov eax, var . call var . mov eax, dword [var] . call var . mov edi, eax . test edi, edi . jle var . mov ebx, 1 . lea edx, [ebp - var] . mov eax, ebx . call var . mov ecx, dword [ebp - var] . lea eax, [ebp - var] . mov edx, var . call var . mov eax, dword [ebp - var] . lea edx, [ebp - var] . call var . mov edx, dword [ebp - var] . mov eax, var . call var . lea edx, [ebp - var] . mov eax, ebx . call var . mov ecx, dword [ebp - var] . lea eax, [ebp - var] . mov edx, var . call var . mov eax, dword [ebp - var] . lea edx, [ebp - var] . call var . mov edx, dword [ebp - var] . mov eax, var . call var . lea edx, [ebp - var] . mov eax, ebx . call var . mov ecx, dword [ebp - var] . lea eax, [ebp - var] . mov edx, var . call var . mov eax, dword [ebp - var] . lea edx, [ebp - var] . call var . mov eax, dword [ebp - var]
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, var . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . add byte [eax], al . mov al, 4 . add al, byte [eax] . invalid . invalid . invalid . call dword [ecx] . add byte [eax], al . add byte [ebx], dl . outsd dx, dword [esi] . add byte [esi], ah . je var . xor eax, dword [eax] . xor al, byte [eax] . and byte [eax], al . inc esp . add byte [edi], ch . ja var . outsb dx, byte [esi] . add byte [eax + eax + var], ch . add byte [ecx], ah . add byte fs:[ebp], ah . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, dword [var] . sub eax, 0 . je var . add eax, 7 . sub eax, 6 . sub eax, 1 . call var . jmp var . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . lea eax, section..data . mov esp, ebp . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov eax, dword [var] . mov dword [var], 0 . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . mov ecx, dword [var] . mov edx, dword [var] . mov esi, var . mov dword [var], eax . mov eax, ecx . mov dword [var], edx . mul esi . mov ecx, dword [var] . imul esi, ecx, var . add edx, esi . mov esi, dword [var] . mov edi, dword [esi + var] . mov dword [var], eax . mov dword [var], edx . add esi, edi . mov eax, edi . shl eax, var . mov edx, dword [var] . mov ebx, dword [var] . mov dword [var], eax . mov eax, dword [var]
mov eax, var . push eax . push dword fs:[0] . 648925000000. mov dword fs:[0], esp . add byte [ebx], dh . ror byte [ecx + var], var . insd dword es:[edi], dx . jo var . arpl word [edx + esi], si . mov ebp, var . imul edx, ecx, var . enter varffff8181, var . mov al, var . mov byte [var], al . mov dh, var . and al, var . dec ebp . xchg dword [edx + edi - var], eax . enter varffff94d1, var . out dx, eax . int1 . inc ecx . jecxz var . leave . fstp qword [var] . rcl cl, var . je var . pop ss . mov al, byte [var] . jnp var . de2cac fisubr word [esp + ebp*4] . lodsb al, byte [esi] . fld qword [edi - var] . test dword [ecx], esi . adc byte [esi + var], dl . loop var . in al, dx . and eax, var . adc byte [ecx - var], ch . jle var . aad var . jno var . add eax, ebx . a39151935f mov dword [var], eax . push ecx . xchg eax, ebx . pop edi . bound edi, qword [var] . invalid . jne var . push edi . xor esi, esp . inc ebp . ja var . push ds . pushfd . dec ecx . mov word [ebx - var], gs . inc ebx . fmul qword [edi - var] . dec edx . mov dl, var . invalid . stosd dword es:[edi], eax
call var . jmp var . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, var . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var] . cmp eax, dword [edx + var] . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx - var], ah . popal . jge var . fisubr dword [ebx] . inc ebx . mov eax, dword [var] . xchg dword [eax - 3], ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . add byte [edx], al . push eax . add dword [ecx], var . bound esi, qword [eax + esi*2] . jb var . push var . arpl word [esi + edx*2 + var], si . add byte [ebx], ch . push ss . add eax, dword [eax] . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . or ebp, dword [ecx - var] . std . fadd qword [ebp + var] . movsd dword es:[edi], dword ptr [esi] . inc edi . cmpsd dword [esi], dword ptr es:[edi] . out dx, eax . lock and dh, byte [var] . mov edx, var . cdq . inc eax . mov dword [var], eax . xor edx, esp . invalid . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . push ebp . mov ebp, esp . sub esp, var . mov esi, 2 . mov ebx, var . mov dword [ebp - 8], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov eax, var . mul dword [ebp - var] . mov dword [ebp - var], eax . mov dword [ebp - var], eax . add dword [ebp - var], var . dec dword [ebp - var] . mov eax, ebx . add eax, dword [ebp - 8] . sub eax, var . mov dword [ebp - var], eax . mov dword [ebp - var], var . add dword [ebp - var], var . add dword [ebp - var], var . mov eax, dword [ebp - var] . sub dword [ebp - var], eax . mov eax, dword [ebp - var] . mov ecx, ebx . sub ecx, 7 . xor edx, edx . div ecx . mov dword [ebp - var], eax . mov edi, eax . mov dword [ebp - var], edi . mov eax, dword [ebp - var] . add eax, dword [ebp - var] . mov edx, dword [ebp - 8] . sub edx, var . sub eax, edx . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . mov edx, dword [ebp - var] . mov al, byte [edx + eax] . mov byte [ebp - 9], al . movzx eax, byte [ebp - 9] . mov edx, dword [ebp - var] . add edx, dword [ebp - var] . and edx, var . xor eax, edx . mov byte [ebp - 9], al . mov eax, dword [ebp - var] . mov edx, dword [ebp - var] . mov cl, byte [ebp - 9] . mov byte [edx + eax], cl . dec dword [ebp - var] . mov eax, var . cdq . idiv ebx . mov edi, eax . add edi, dword [ebp - var] . cmp dword [ebp - var], edi . ja var . c745b0cca84d. mov dword [ebp - var], var . inc ebp . mov al, var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, var . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . add byte [eax], al . mov al, 4 . add al, byte [eax] . invalid . invalid . invalid . call dword [ecx] . add byte [eax], al . add byte [ebx], dl . outsd dx, dword [esi] . add byte [esi], ah . je var . xor eax, dword [eax] . xor al, byte [eax] . and byte [eax], al . inc esp . add byte [edi], ch . ja var . outsb dx, byte [esi] . add byte [eax + eax + var], ch . add byte [ecx], ah . add byte fs:[ebp], ah . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], bh . and al, var . inc edx . 1d23cd4bb1 sbb eax, var . dec ebx . mov cl, 7 . jne var . leave . dec edi . loop var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . sub byte [edx + var], al . push esi . popal . insb byte es:[edi], dx . push eax . inc ebp . push edx . inc ecx . dec ebp . inc ebp . dec esp . inc ebp . push ebx . cmp byte [eax], al . and byte [ecx + var], al . and byte [eax + eax], cl . add byte [eax], al . dec esp . xor dword [eax], eax . add bl, byte [esp + edx*8] . pop eax . bound ebx, qword [ebx - var] . push ebp . je var . sub byte [esi + var], 7 . push esp . xor esi, dword [eax] . dec esi . daa . in eax, dx . aas . inc eax . movsd dword es:[edi], dword ptr [esi] . hlt . ret . sahf . mov bl, var . jae var
jmp loc.00402064 . add byte [eax], al . add byte [eax], al . nop . nop . nop . push 0 . push var . push 0 . push str.STARTDLG . push dword [var] . call sub.USER32.DLL_DialogBoxParamA . cmp dword [var], 0 . jne var . cmp dword [var], 0 . jne var . mov ecx, 3 . mov edx, dword [var] . xor eax, eax . call var . cmp byte [var], 0 . je var . call var . ret . push ebp . mov ebp, esp . push eax . mov eax, 2 . add esp, var . push eax . dec eax . jne var . add esp, var . mov eax, dword [ebp - 4] . push ebx . push esi . push edi . mov edi, dword [ebp + var] . mov ebx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edx, ebx . push dword [ebp + var] . push str.STARTDLG . push 0 . push 0 . mov eax, esi . mov ecx, edi . call var . sub ebx, var . je var . dec ebx . je var . jmp var . xor ecx, ecx . xor edx, edx . xor eax, eax . call var . mov dword [var], esi . cmp dword [var], 0 . je var . push dword [var] . push 1 . push var . push esi
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 3] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 4] . mov ecx, dword [var] . sub eax, ecx . ret . mov edi, edi . push ebp
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . push ecx . push ecx . mov eax, dword [var] . push edi . mov edi, dword [var] . test eax, eax . je var . mov dword [eax], edi . test edi, edi . jne var . call var . mov dword [eax], var . call var . xor eax, eax . jmp var . cmp dword [var], 0 . je var . cmp dword [var], 2 . jl var . cmp dword [var], var . jg var . and dword [var], 0 . push ebx . push esi . push 8 . pop ebx . movzx esi, word [edi] . push ebx . push esi . add edi, 2 . call var . pop ecx . pop ecx . test eax, eax . jne var . cmp si, var . jne var . or dword [var], 2 . jmp var . cmp si, var . jne var . movzx esi, word [edi] . add edi, 2 . cmp dword [var], 0 . jne var . push esi . call var . pop ecx . test eax, eax . je var . mov dword [var], var . jmp var . movzx eax, word [edi] . cmp eax, var . je var . cmp eax, var . je var . mov dword [var], ebx . jmp var
mov eax, var . mov ecx, var . xor byte [eax], var . inc eax . loop var . jmp var . stosb byte es:[edi], al . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx . push eax . adc ch, byte [ebx + var] . xchg eax, edx . and al, byte [eax] . push edx . invalid . call var . push edx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . mov edx, var . mov eax, var . call var . call var . call var . push var . call sub.kernel32.dll_Sleep . mov edx, var . mov eax, var . call var . mov eax, var . call var . mov eax, var . call var . push var . push 0 . push 0 . push var . push 0 . push 0 . call sub.kernel32.dll_CreateThread . call var . xor eax, eax . pop edx . pop ecx . pop ecx . mov dword fs:[eax], edx . push var . ret . jmp var . jmp var . call var . add byte [eax], al . invalid . invalid . invalid . call dword [edx] . add byte [eax], al . add byte [ebx + var], al . pop esp . push edi . dec ecx . dec esi . inc esp . dec edi . push edi . push ebx . pop esp . bound ebp, qword [edi + var] . imul ebp, dword cs:[esi + var], var . invalid . jmp dword [ebx] . add byte [eax], al . add byte [eax + var], ch
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov dword [var], eax . mov dword [var], eax . call var . cmp ecx, 2 . mov dword [var], eax . je var . call var . call var . cmp esp, var . xor eax, eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - var], var . mov dword [ebp - var], 0 . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp . ret . xor eax, eax . mov ecx, dword [sym.imp.SHLWAPI.dll_StrCatW] . push 0 . push 0 . mov dword [ebp - var], eax . call ecx . add esp, 8 . xor ecx, ecx . mov dword [ebp - var], eax . mov eax, ecx . add esp, var . pop esi . pop edi . pop ebp . ret . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dword [ebp - var], ecx . mov ecx, dword [ebp - var] . cmp eax, ecx . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . add esi, var . mov edi, dword [ebp - var] . mov byte [edi + eax], dl . add eax, 1
sub esp, var . push ebx . push esi . push edi . push var . pop edi . xor ebx, ebx . push var . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.UXTHEME . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], 0 . jne var . push ebp . push 9 . call var . push 7 . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, ebp . jne var . push var . mov eax, var . pop edi . push edi
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], cl . mov al, byte [var] . dec edi . mov esi, var . lahf . daa . dec edi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . jo var . sbb dword [ebx], eax . inc edx . imul ebp, dword [ecx + ebp*2 + var], var . jae var . add byte [eax], ah . or byte [ecx], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . push es . lodsb al, byte [esi] . xchg eax, esp . fcomp qword [eax + var] . lcall var . out var, eax . aad var . cmp eax, var . invalid . jge var . dec ebx . invalid . dec ebx . test dword [ecx + var], ebp . dec edi . lodsd eax, dword [esi] . 339966cf11b7 xor ebx, dword [ecx - var] . iretd . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, dl . std . push cs . cmpsd dword [esi], dword ptr es:[edi] . mov ecx, var . test byte [eax], dh . std . out dx, eax . cmp eax, dword [ecx + var] . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx], al . push es . push eax . add dword [ecx], var . bound esp, qword gs:[ecx + var] . bound esp, qword [ecx + var] . imul edi, dword [edx + var], var . add eax, 0 . dec esp . xor dword [eax], eax . add al, var . lodsb al, byte [esi] . mov ah, var . lodsb al, byte [esi] . cmp dword ds:[ebx + ebp*4 + var], ecx . xchg eax, ebx . jo var . and eax, var . and dword [ebx], ebp . stc . fnstsw dword [edi - var] . aad var . adc cl, byte [edi] . fnstsw dword [edx] . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . 0000 add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], ch . je var . aam var . movsd dword es:[edi], dword ptr [esi] . mov dl, var . mov dh, var . orps xmm0, xmmword [ecx] . xchg byte [ebp + edx*4], bl . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . test al, var . adc eax, var . arpl word [eax + var], bp . jb var . add byte [eax], cl . inc ecx . add byte [eax], ah . or byte [ecx], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add bl, byte [esi + var] . 688143a69d push var . cmpsb byte [esi], byte ptr es:[edi] . popfd . into . leave . inc ebx . in eax, dx . pop es . stosd dword es:[edi], eax . pop es . add byte [edx], ah . fimul word [edx - var] . inc edx . mov dh, var . pop es . enter varffffa917, 6 . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . inc esi . inc esi . cmp word [esi], bx . je var . cmp word [esi], var . jne var . inc esi . push var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . mov cl, byte [eax] . cmp cl, bl . je var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax
mov eax, dword [var] . test edx, eax . mov eax, edx . lea edx, [var] . test eax, eax . test esp, eax . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push edi . push esi . sub esp, 8 . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [ebp - 9] . and ah, var . mov byte [ebp - 9], ah . mov edi, dword [ebp - var] . mov ah, byte [edx + ecx] . mov dword [ebp - var], edi . sub ah, al . mov byte [esi + ecx], ah . add esp, 8 . pop esi . pop edi . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . xor eax, eax . mov ecx, dword [var] . mov edx, dword [var] . xor esi, esi . mov dword [var], esi . mov dword [var], var . mov word [var], var . mov word [var], var . movzx edi, word [var] . mov bx, di . xor edi, var . mov word [var], di . mov dword [var], var . mov edi, dword [var] . mov dword [var], esi . mov dword [var], var . mov esi, ecx . or esi, var . mov dword [var], esi . mov esi, esp . mov dword [esi], 0 . mov esi, dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], edi . mov word [var], bx
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00411d2b (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . insd dword es:[edi], dx . mov dl, var . pop edi . or byte [ecx], var . dec edi . xchg eax, esp . insd dword es:[edi], dx . sar ebx, 1 . invalid . in eax, var . test al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx + var], al . jb var . jb var . inc ecx . push ebp . push ebx . dec ecx . dec esi . inc edi . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . or al, var . mov byte [var], al . mov ch, var . movsb byte es:[edi], byte ptr [esi] . movsb byte es:[edi], byte ptr [esi] . mov al, byte gs:[var] . xor al, byte [ecx + var] . ud2b . pop es . pop ebx . dec ebx . test eax, var . les ebx, [ecx + ebx*8 + var] . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . mov eax, ebp . mov dword [var], esp . cmp eax, 0 . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . jmp var . mov ebx, dword [var] . cmp ebx, ecx . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push esi . sub esp, 8 . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . add esp, 8 . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . xor ecx, ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . mov byte [esp + var], 3 . mov edx, dword [esp + var] . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . mov esi, dword [esp + var]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], bl . test byte [eax + esi], dl . jl var . test al, var . movsd dword es:[edi], dword ptr [esi] . jg var . jmp dword [ebx] . ljmp 0:var . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . 0000 add byte [eax], al . add byte [ebp + eax*2 + var], dl . inc ecx . dec ebx . push esp . inc ecx . dec ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or edx, ebp . sub dword [eax - var], var . dec ecx . sbb edx, dword [edx + var] . sbb dword [esi + var], ebx . mov byte [esi], ah . dec esi . movsb byte es:[edi], byte ptr [esi] . fistp qword [edx] . mov byte [var], al . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . push edi . push esi . mov ecx, 4 . sub esp, ecx . mov ecx, ebx . mov dword [esp], ecx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . sub esp, var . lea eax, [var] . mov ecx, var . lea edx, [ebp - var] . mov dword [esp], edx . mov dword [esp + 4], eax . mov dword [esp + 8], var . mov dword [ebp - var], edx . mov dword [ebp - var], ecx . call var . call var . mov dword [esp], eax . mov eax, dword [ebp - var] . mov dword [esp + 4], eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . sub esp, 8 . mov eax, var . mov dword [ebp - 4], var . sub eax, dword [ebp - 4] . mov dword [ebp - 8], eax . mov ecx, dword [ebp - 8] . mov edx, dword fs:[ecx] . mov eax, var . cmp edx, 0 . cmove edx, eax . mov eax, dword [edx + var] . add esp, 8 . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov eax, var . mov ecx, var . mov dword [ebp - 4], eax . mov edx, dword fs:[var] . mov eax, edx . test edx, edx . mov dword [ebp - 8], eax . mov dword [ebp - var], ecx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . xor edx, edx . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add cl, byte [var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor dl, byte [ebx] . mov eax, eax . add al, byte [eax] . mov eax, eax . add byte [varh], cl . inc eax
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . inc esi . inc esi . cmp word [esi], bx . je var . cmp word [esi], var . jne var . inc esi . push var
push ebp . push esp . xor ecx, ecx . mov dword [var], ebx . add ecx, 4 . cmp ecx, 1 . je var . pop eax . add eax, ecx . pop dword [var] . mov dword [var], eax . cmp ecx, 0 . jne var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . push ebp . mov ebp, esp . push eax . call var . mov ecx, 1 . cmp eax, 0 . mov dword [var], ecx . je var . mov eax, dword [var] . add esp, 4 . pop ebp . ret . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var
sub esp, 8 . lea edx, [var] . mov dword [var], var . mov dword [esp], edx . jmp var . int . jmp var . push esi . push edi . xor esi, esi . push dword [var] . call var . mov edi, eax . test edi, edi . pop ecx . jne var . cmp dword [var], eax . jbe var . push esi . call dword [sym.imp.KERNEL32.dll_Sleep] . lea eax, [esi + var] . cmp eax, dword [var] . jbe var . or eax, var . cmp eax, var . mov esi, eax . jne var . mov eax, edi . pop edi . pop esi . ret . int . int . int . int . int . int . cmp byte [eax], bh . insb byte es:[edi], dx . cmp byte [ebp + var], al . add esi, dword [var] . js var . push cs . jno var . insb byte es:[edi], dx . insd dword es:[edi], dx . invalid . lea ebx, [ebx + ebx*8] . fstpnce st(5), st(0) . jmp var . cmp byte [eax], bh . pop esp . cmp byte [eax + edi + var], ch . cmp byte [ebp + var], al . cmp byte [ecx], dh . xchg eax, ebx . clc . and ecx, dword [ecx - var] . aaa . dec ecx . mov ecx, var . mov esp, var . cmp byte [esi + var], ah . inc ebp
call var . jmp var . int . int . int . int . int . int . int . int . int . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . bt dword [var], 1 . jae var . rep movsb byte es:[edi], byte ptr [esi] . jmp case.var.0 . cmp ecx, var . jb var . mov eax, edi . xor eax, esi . test eax, var . jne var . bt dword [var], 1 . jb var . bt dword [var], 0 . jae var . test edi, 3 . jne var . test esi, 3 . jne var . bt edi, 2 . jae var . mov eax, dword [esi] . sub ecx, 4 . lea esi, [esi + 4] . mov dword [edi], eax . lea edi, [edi + 4] . bt edi, 3 . jae var . movq xmm1, qword [esi] . sub ecx, 8 . lea esi, [esi + 8] . movq qword [edi], xmm1 . lea edi, [edi + 8] . test esi, 7 . je var . bt esi, 3 . jae var . movdqa xmm1, xmmword [esi - var] . lea esi, [esi - var] . movdqa xmm3, xmmword [esi + var] . sub ecx, var . movdqa xmm0, xmmword [esi + var]
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . push 0 . push var . call sub.MSVCRT.dll_memset . add esp, var . push 0 . call sub.KERNEL32.dll_GetModuleHandleA . mov dword [var], eax . push 0 . push var . push 0 . call sub.KERNEL32.dll_HeapCreate . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . call var . call var . push 7 . push var . lea eax, [var] . push eax . push 8 . call var . mov dword [var], eax . push 7 . push var . push var . mov edx, dword [var] . call var . mov eax, var . push 8 . call var . mov edx, var . lea ecx, [var] . call var . mov edx, var . lea ecx, [var] . call var . mov edx, str.Can_not_create_some_of_your_include_files. . lea ecx, [var] . call var . mov edx, str.Can_not_allocate_the_memory. . lea ecx, [var] . call var . mov edx, str.Wrong_password. . lea ecx, [var] . call var . mov edx, var . lea ecx, [var] . call var . mov edx, var . lea ecx, [var] . call var . mov edx, str.already_exists_in_the_current_directory._Overwrite . lea ecx, [var] . call var . mov edx, str.An_unknown_error_occured._The_program_will_be_terminated. . lea ecx, [var] . call var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . dec eax . add byte [eax], al . add byte [eax], bh . add byte [eax], al . add byte [ecx + eax*2 - var], al . push ebx . dec edx . mov edx, var . test byte [eax - var], ch . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push esi . outsd dx, dword [esi] . insb byte es:[edi], dx . dec ecx . inc esp . add byte [eax], al . add byte [ecx + var], al . je var . inc esp . jb var . ja var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add dh, cl . sbb ah, bh . xchg edi, esp . pushfd . in al, dx . inc ebx . scasd eax, dword es:[edi] . out var, al . in al, var . mov eax, dword [var] . pushal . invalid . loope var . fiadd word [edx + esi*4 + var] . mov dword [var], eax . cmp cl, byte [bx - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call var . xor eax, eax . pop ebp . ret 4 . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . mov edi, edi . push ebp . mov ebp, esp . push edi . mov edi, var . push edi . call dword [sym.imp.KERNEL32.dll_Sleep] . push dword [lpModuleName] . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . add edi, var . cmp edi, var . ja var . test eax, eax . je var . pop edi . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . call var . push dword [var] . call var . push dword [var] . call var . push var . call eax . add esp, var . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . push str.mscoree.dll . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . test eax, eax
push ebp . push esp . mov eax, esi . push eax . add eax, 5 . call var . mov edx, edi . mov eax, 8 . push edx . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - 8], var . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . call esi . mov dword [ebp - var], eax . call var . call var . mov ecx, dword [sym.imp.KERNEL32.dll_CreateFileW] . sub esp, 4 . mov dword [esp], ecx . mov dword [ebp - var], eax . call var . add esp, 4 . mov ecx, dword [ebp - 8] . add ecx, var . cmp eax, ecx . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, dl . enter varffffb270, varfffffffa . lodsd eax, dword [esi] . mov edi, var . xor bl, byte [edi + var] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebp + var], dl . jb var . outsd dx, dword [esi] . jb var . jb var . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add ah, byte [edx] . push ds . adc dword [esi + var], var . clc . push ecx . push ebx . inc ecx . inc ebp . and byte [edx], var . cmp dword [ecx + 7], edi . jb var . inc edx . inc edi . popfd . aam var . test al, var . not dl . mov byte [edx], bh . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx + var], bh . cdq . mov byte [edx + edi*4 + var], cl . dec ebp . mov ch, var . mov ebp, var . pop ds . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . push var . inc ebp . push edx . push ebp . inc ecx . push edi . inc ecx . dec esi . add byte [eax], cl . inc ecx . add byte [eax], ah . or byte [ecx], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or ebx, ebx . pop ecx . pop ds . mov al, var . in al, var . inc edi . mov edx, var . dec esp . dec edx . iretd . rol ah, cl . inc eax . salc . add byte [ecx + ecx*2 - var], var . out dx, al . ror dword [ebx + var], 1 . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], dl . sbb byte [esi - var], al . dec ebp . xchg eax, ebp . iretd . cli . and ch, bl . jae var . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . outsd dx, dword [esi] . jb var . jb var . dec ecx . dec esi . inc esp . inc ebp . inc esi . dec esp . push ebp . inc ebp . dec esi . push esp . add byte [ecx + var], ah . je var . outsd dx, dword [esi] . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add ecx, dword [edi - var] . lcall var:var . mov edi, var . in eax, 5 . add eax, dword [ebp + ebx*4 + var] . stc . invalid . invalid . xchg eax, edx . hlt . das . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . or ebp, var . jmp var . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi]
mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . mov dword [var], ebx . push ebx . mov dword [var], ebx . push ebp . mov dword [var], ebp . push esp . mov eax, esp . mov ecx, 4 . add eax, ecx . inc edx . pop ecx . inc edx . inc eax . inc ecx . mov dword [var], esp . mov dword [var], eax . add eax, ecx . xor ecx, ecx . pop esp . inc edx . pop ecx . inc edx . add dword [var], 8 . jmp var . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, var . mov dword [esp + var], var . mov ebx, dword [esp + var] . add edx, ecx . cmp edi, ebx . mov byte [esp + var], al . mov dword [esp + 8], ecx . mov dword [esp + 4], edx . mov dword [esp], esi . ja var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . or eax, eax . or ecx, ecx . mov edx, dword [esp + 4] . mov bl, byte [edx] . mov bh, byte [esp + var] . sub bl, bh . mov dword [esp + var], ecx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx - var], bh . cmp al, var . jmp var . call var . jo var . sbb dword [eax], eax . 640000 add byte fs:[eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add al, bh . call var . outsb dx, byte [esi] . jb var . outsb dx, byte [esi] . arpl word [ebp + var], sp . add byte [eax], al . add al, var . lds eax, [edx] . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . push es . sbb al, bh . jecxz var . aad var . push esi . dec ebx . mov al, var . sub byte [edi - var], var . lodsd eax, dword [esi] . xchg eax, ecx . nop . adc byte [ebx], bh . jo var . add ch, bl . inc edi . lodsd eax, dword [esi] . test byte [esi - var], dh . dec ebp . stosd dword es:[edi], eax . inc esp . pushfd . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al
jmp var . jmp loc.00424e82 . jmp loc.00460447 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp loc.00419ecc . jmp var . jmp var . jmp var . jmp loc.00470724 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp loc.004577f3 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp loc.0044bb71 . jmp var . jmp loc.00419718 . jmp loc.00416c3a . jmp var . jmp loc.0040c907 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp loc.0045bd5c . jmp var . jmp var . jmp var . jmp loc.0040cb27 . jmp var . jmp loc.0040cdc7 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp loc.004579b4 . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . push ebx . mov eax, var . call var . mov ebx, dword [var] . nop . mov eax, dword [ebx] . call var . mov eax, dword [ebx] . mov edx, var . call var . mov ecx, dword [var] . mov eax, dword [ebx] . mov edx, dword [var] . call var . mov ecx, dword [var] . mov eax, dword [ebx] . mov edx, dword [var] . call var . mov eax, dword [ebx] . mov byte [eax + var], 0 . mov eax, dword [ebx] . call var . pop ebx . call var . invalid . invalid . invalid . inc dword [var] . popal . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . xor ecx, ecx . mov dword [var], ebx . add ecx, 4 . cmp ecx, 1 . je var . pop eax . add eax, ecx . pop dword [var] . mov dword [var], eax . cmp eax, esp . je var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . call var . mov ecx, dword [var] . mov edx, dword [var] . add ecx, var . xor edx, var . mov dword [var], edx . cmp eax, ecx . je var . jmp var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . lea esp, [var] . pop ebx . pop edi . pop esi . pop ebp . ret . mov eax, dword [var] . mov ecx, dword [var] . mov edx, eax . xor edx, var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx + ebp*4], cl . rol ah, 1 . or dl, var . dec esi . movsb byte es:[edi], byte ptr [esi] . mov edx, var . or dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx + var], ah . je var . outsd dx, dword [esi] . outsb dx, byte [esi] . push edx . insd dword es:[edi], dx . outsd dx, dword [esi] . outsb dx, byte [esi] . je var . jb var . outsb dx, byte [esi] . xor al, 0 . outsb dx, byte [esi] . add byte gs:[bx + si], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . sub eax, var . pop ds . dec edi . mov esp, var . cmp byte [edx + var], ch . xchg dword [eax - var], ecx . imul eax, dword [ebx - var], var . pop ds . push cs . invalid . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . call var . jae var . inc ebx . stosb byte es:[edi], al . mov esp, var . dec edx . bound eax, qword [eax] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx], al . push es . push eax . add dword [ecx], var . jne var . insd dword es:[edi], dx . jo var . add byte ss:[eax], al . add byte [eax], al . add byte [ecx], al . add byte [var], dl . add byte [eax], al . 0000 add byte [eax], al . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + ebp + var], ah . add al, bh . xchg eax, ecx . inc edi . add byte [eax], al . add byte [eax], al . add byte [eax + var], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], dh . sbb byte [eax], al . add dword [eax], eax . pop ss . add byte [eax], ah . and al, var . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add al, bl . push edi . push ebx . xchg eax, ebx . xchg dword [bx + si], edx . inc edx . xchg eax, ebp . out dx, al . or al, var . xor eax, var . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx + var], al . jb var . jb var . imul esi, dword [ecx + ebp*2 + var], var . add byte [edx], cl . inc ebx . popal . jo var . imul eax, dword [eax], var . int . xor dword [eax], eax . add ebx, esp . jno var . dec esi . or eax, var . sar ah, 1 . push esp . enter varffffbf50, varffffffd4 . add ch, byte [eax + edx*2] . dec ecx . call var . xor edx, dword [edi + var] . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov ecx, esi . push ecx . xchg esi, ecx . call var . xchg edx, edi . mov eax, 2 . push edx . shl eax, 1 . mov ecx, eax . mov eax, ebx . mov edi, edx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - 8], var . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . call esi . mov ecx, dword [sym.imp.USER32.dll_GetMenuCheckMarkDimensions] . mov dword [ebp - var], eax . call ecx . mov ecx, dword [sym.imp.USER32.dll_GetMenuDefaultItem] . push var . push var . push var . mov dword [ebp - var], eax . call ecx . mov dword [ebp - var], eax . call var . call var
push ebp . push esp . push edi . push esi . mov ecx, 4 . sub esp, ecx . mov ecx, ebx . mov dword [esp], ecx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . sub esp, var . lea eax, [var] . mov ecx, var . lea edx, [ebp - var] . mov dword [esp], edx . mov dword [esp + 4], eax . mov dword [esp + 8], var . mov dword [ebp - var], edx . mov dword [ebp - var], ecx . call var . call var . mov dword [esp], eax . mov eax, dword [ebp - var] . mov dword [esp + 4], eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . mov ecx, dword fs:[var] . mov eax, var . cmp ecx, 0 . cmove ecx, eax . mov eax, dword [ecx + var] . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov eax, var . mov ecx, var . mov dword [ebp - 4], eax . mov edx, dword fs:[var] . mov eax, edx . test edx, edx . mov dword [ebp - 8], eax . mov dword [ebp - var], ecx . je var . jmp var . mov eax, dword [ebp - 8] . sub eax, 1 . mov dword [ebp - var], eax . je var . jmp var
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], var . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var . mov cl, byte [eax + 1] . or cl, var . cmp cl, var . jne var . or esi, 2
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . call var . jmp var . xchg ebx, ebx . nop . add byte [eax - var], al . inc edi . add ah, dl . inc esp . inc edi . add byte [eax], dl . nop . inc edi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . pushal . or dword [eax], eax . add byte [eax], al . inc eax . add byte [eax], al . push eax . pop es . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . mov al, byte [var] . cmp dword [eax + eax + 3], eax . invalid . sub ebx, dword [ebp + var] . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . inc ecx . add ebx, ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec edx . dec eax . pop ecx . pop edi . inc edi . invalid . jnp var . mov eax, var . ja var . xchg eax, esi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . push ds . add edi, dword [ecx] . add byte [eax], al . add byte [eax + var], dh . outsb dx, byte [esi] . jns var . aaa . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add ebp, ebx . pushal . popfd . out var, eax . push var . inc eax . mov ebp, var . lahf . mov ebp, var . push ecx . pop esp . pushfd . pushfd . inc ecx . xchg dword [edx], eax . or eax, var . mov eax, dword [var] . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push ebp . mov ebp, esp . cmp dword [lpMem], 0 . jne var . push dword [var] . call var . pop ecx . pop ebp . ret . push esi . mov esi, dword [var] . test esi, esi . jne var . push dword [lpMem] . call var . pop ecx . xor eax, eax . jmp var . push ebx . jmp var . test esi, esi . jne var . inc esi . push esi . push dword [lpMem] . push 0 . push dword [var] . call dword [sym.imp.KERNEL32.dll_HeapReAlloc] . mov ebx, eax . test ebx, ebx . jne var . cmp dword [var], eax . je var . push esi . call var . pop ecx . test eax, eax . je var . cmp esi, var . jbe var . push esi . call var . pop ecx . call var . mov dword [eax], var . xor eax, eax . pop ebx . pop esi . pop ebp . ret . call var . mov esi, eax . call dword [sym.imp.KERNEL32.dll_GetLastError] . push eax . call var . pop ecx . mov dword [esi], eax . jmp var . call var . mov esi, eax . call dword [sym.imp.KERNEL32.dll_GetLastError] . push eax
call var . jmp var . push ebp . mov ebp, esp . pop ebp . jmp var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov byte [var], bl . mov dword [var], ebx . cmp ebx, dword [var] . je var . mov ecx, dword [var] . call var . mov ecx, dword [var] . call dword [var] . mov eax, dword [var] . add dword [var], eax . inc ebx . mov dword [var], ebx . jmp var . mov al, 1 . mov byte [var], al . mov dword [var], var . call var . call var . ret var . mov ebx, dword [ebp - var] . mov al, byte [ebp - var] . test al, al . jne var . push dword [var] . push ebx . push dword [var] . push dword [var] . call var . ret . push ebp . mov ebp, esp . push dword [var] . call var . pop ecx . pop ebp . ret . push ebp . mov ebp, esp . push varffffffff . push var . mov eax, dword fs:[0] . push eax . push ecx . push ebx . push esi . push edi . mov eax, dword [var] . xor eax, ebp . push eax . lea eax, [var] . mov dword fs:[0], eax . mov dword [var], esp . push dword [var]
jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
mov eax, dword [var] . sub eax, 0 . je var . add eax, 4 . sub eax, 4 . call var . jmp var . mov dword [ebp - 4], eax . int . int . int . int . push ebp . mov ebp, esp . push eax . mov dword [var], var . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . setne dl . and dl, 1 . movzx eax, dl . add esp, 4 . pop ebp . ret . int . int . int . int . int . int . int . push ebp . mov ebp, esp . and esp, var . sub esp, var . mov eax, 1 . mov ecx, var . mov dword [var], var . mov word [var], var . mov dword [var], eax . mov dword [var], ecx . call var . mov dword [var], var . mov dword [var], var . mov ecx, dword [var] . mov eax, dword [eax + var] . mov edx, dword [var] . sub edx, ecx . cmp eax, edx . mov eax, dword [var] . mov dword [var], eax . jb var . call var . mov cx, var . sub cx, word [var] . mov dword [esp], eax . mov word [var], cx . call var . mov cx, word [var] . cmp word [eax + var], cx . setb dl . and dl, 1
call var . jmp var . jmp var . push ebp . mov ebp, esp . mov eax, dword [var] . push esi . mov ecx, dword [eax + var] . add ecx, eax . movzx eax, word [ecx + var] . lea edx, [ecx + var] . add edx, eax . movzx eax, word [ecx + 6] . imul esi, eax, var . add esi, edx . cmp edx, esi . je var . mov ecx, dword [var] . cmp ecx, dword [edx + var] . jb var . mov eax, dword [edx + 8] . add eax, dword [edx + var] . cmp ecx, eax . jb var . add edx, var . cmp edx, esi . jne var . xor eax, eax . pop esi . pop ebp . ret . mov eax, edx . jmp var . push esi . call var . test eax, eax . je var . mov eax, dword fs:[var] . mov esi, var . mov edx, dword [eax + 4] . jmp var . cmp edx, eax . je var . xor eax, eax . mov ecx, edx . lock cmpxchg dword [esi], ecx . test eax, eax . jne var . xor al, al . pop esi . ret . mov al, 1 . pop esi . ret . push ebp . mov ebp, esp . cmp dword [var], 0 . jne var . mov byte [var], 1 . call var . call var . test al, al . jne var . xor al, al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bl, bl . mov dh, var . c13495f04f92. sal dword [edx*4 + var], var . xchg eax, ebp . invalid . dec edi . xchg eax, edx . jge var . jns var . int var . aam 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx + var], dl . bound esp, qword [edx + var] . je var . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [ebx], al . add ah, dl . and eax, dword [eax] . add byte [eax], al . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + var], bh . and byte [edx], cl . or al, 0 . add byte [eax], al . dec eax . sbb al, byte [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . add esi, 2 . cmp word [esi], bx . je var . cmp word [esi], var . jne var . push var . add esi, 2 . pop ebx
mov eax, dword [var] . xor eax, eax . call var . mov dword [var], eax . mov byte [esi - var], bh . pop ss . dec edx . and bh, dl . or bl, byte [esi - var] . pop ebx . xchg eax, ebx . out dx, al . lodsb al, byte [esi] . push es . inc edi . ret . rol dh, 1 . inc esi . mov byte [var], al . xchg bh, ch . mov ch, var . adc dword [ebx - var], esi . test byte [edx], ah . add eax, var . mov byte [var], al . in al, var . imul ebp, dword [ebx + var], var . fisub dword [esi - var] . cmp al, var . sahf . retf var . cmpsd dword [esi], dword ptr es:[edi] . clc . in al, var . loopne var . movsd dword es:[edi], dword ptr [esi] . iretd . dec ebp . adc edx, dword [eax - var] . mov dword [ebx + var], eax . popfd . fistp dword [ecx - var] . cmpsb byte [esi], byte ptr es:[edi] . dec esp . pushfd . or dword [ecx + var], ecx . push cs . out dx, al . or byte [ebx - var], dh . outsb dx, byte [esi] . inc ebx . jge var . mov esi, var . pop ss . dec edx . and bh, dl . or bl, byte [esi - var] . pop ebx . xchg eax, ebx . out dx, al . lodsb al, byte [esi] . push es . inc edi . ret
push ebp . push esp . or ecx, var . mov eax, ecx . and eax, var . cmp eax, 1 . je var . pop ecx . add ecx, 4 . pop dword [var] . mov dword [var], ecx . mov ecx, ebx . mov dword [var], ecx . call var . cmp ecx, ebp . je var . mov eax, ebx . sub eax, 6 . shl eax, 3 . push eax . xor eax, eax . mov ebp, ebx . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], var . call var . mov ecx, 1 . mov edx, dword [var] . add edx, var . cmp eax, edx . mov dword [var], ecx . jne var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . add esp, 8 . pop ebp . ret . int . int . int . int . int . int . int
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . push ebp . mov dword [var], eax . mov dword [ebp - 4], eax . mov dword [var], edi . xor ebp, eax . call var . call var . ret . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ah, byte [edx + ecx] . sub ah, al . xor edx, edx . mov edi, var . mov dword [esp + var], 0 . mov dword [esp + var], 0 . mov al, dl . test al, al . mov byte [esp + var], ah . mov dword [esp + 8], ecx . mov dword [esp + 4], esi . mov dword [esp], edi . jne var . jmp var . mov eax, dword [esp + 4] . mov ecx, dword [esp + 8] . mov dl, byte [esp + var] . mov byte [eax + ecx], dl . lea esp, [ebp - 8] . pop esi . pop edi . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [var] . mov dword [var], var . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov dword [var], var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . xor ecx, ecx . cmp eax, dword [ecx*8 + var] . je var . inc ecx . cmp ecx, var . jb var . lea ecx, [eax - var] . cmp ecx, var . ja var . push var . pop eax . pop ebp . ret . mov eax, dword [ecx*8 + var] . pop ebp . ret . add eax, var . push var . pop ecx . cmp ecx, eax . sbb eax, eax . and eax, ecx . add eax, 8 . pop ebp . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, 8 . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, var . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . call var . mov ecx, dword [var] . push ecx . mov dword [eax], ecx . call var . pop ecx . mov esi, eax . call var . mov dword [eax], esi . pop esi . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, var . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . mov eax, ebp . mov dword [var], esp . cmp eax, 0 . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . jmp var . mov ebx, dword [var] . cmp ebx, ecx . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov word [esp + var], var . mov byte [esp + var], var . mov dword [esp + var], var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . mov edx, eax . add edx, edx . mov esi, ecx . adc esi, esi . mov dword [esp + var], edx . mov dword [esp + var], esi . mov bl, byte [esp + var] . movzx edx, word [esp + var] . mov di, dx . mov esi, var . sub esi, edx . mov word [esp + var], si . mov bh, byte [esp + var] . xor bh, var . mov byte [esp + var], bh . lea edx, [esp + var] . mov esi, dword [sym.imp.USER32.dll_EnumWindows] . call esi . invalid . push edi . jge var . push ss
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dl, ch . insd dword es:[edi], dx . pop es . out dx, eax . push var . imul ecx, dword [varh], var . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + var], al . jo var . popal . jb var . xor byte fs:[eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [edx], al . add byte [edi + edx + var], ah . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax], bl . sbb byte [eax], al . cwde . and byte [ecx], cl . add byte [eax], al . add byte [eax], al . sub byte [esi], ch . xor eax, 0 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], ch . add byte [eax], al . add al, bl . and dword [eax], eax . pop es . add byte [eax], al
push ebp . mov ebp, esp . sub esp, var . push ebx . xor eax, eax . push esi . push edi . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor ebx, ebx . mov dword [var], eax . push var . push ebx . push var . mov dword [var], eax . mov dword [var], ebx . mov dword [var], ebx . call var . push var . lea eax, [var] . xorps xmm0, xmm0 . push ebx . push eax . movq qword [var], xmm0 . call var . add esp, var . lea esi, [var] . mov ecx, var . mov edi, var . rep movsd dword es:[edi], dword ptr [esi] . mov esi, dword [sym.imp.KERNEL32.dll_SetErrorMode] . push 2 . call esi . or eax, 2 . push eax . call esi . push str.4e064bee1f3860fd606a . push var . call var . add esp, 8 . push var . push ebx . push ebx . call dword [sym.imp.KERNEL32.dll_CreateMutexA] . test eax, eax . jne var . push var . call dword [sym.imp.KERNEL32.dll_ExitProcess] . mov edi, dword [sym.imp.KERNEL32.dll_GetLastError] . call edi . cmp eax, var . jne var . push var . call dword [sym.imp.KERNEL32.dll_ExitProcess] . call var . lea eax, [var] . push eax . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . call dword [sym.imp.SHELL32.dll_CommandLineToArgvW] . mov esi, eax . test esi, esi
push ebp . mov ebp, esp . cmp dword [var], 1 . jne var . call var . push dword [var] . push dword [var] . push dword [var] . call var . add esp, var . pop ebp . ret var . push var . push var . call var . xor eax, eax . inc eax . mov esi, dword [var] . test esi, esi . jne var . cmp dword [var], esi . je var . and dword [var], 0 . cmp esi, 1 . je var . cmp esi, 2 . jne var . mov ecx, dword [var] . test ecx, ecx . je var . push dword [var] . push esi . push dword [var] . call ecx . mov dword [var], eax . test eax, eax . je var . push dword [var] . push esi . push dword [var] . call var . mov dword [var], eax . test eax, eax . je var . mov ebx, dword [var] . push ebx . push esi . push dword [var] . call var . mov edi, eax . mov dword [var], edi . cmp esi, 1 . jne var . test edi, edi . jne var . push ebx . push eax . push dword [var] . call var . push ebx . push edi . push dword [var] . call var . mov eax, dword [var]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx - var], al . arpl word [ebx + ecx*2], dx . scasb al, byte es:[edi] . sbb al, var . xlatb . or dword [ecx + var], edi . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], dh . xor al, var . jb var . push var . arpl word [esi + edx*2 + var], si . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . adc byte [edi + var], cl . movsb byte es:[edi], byte ptr [esi] . invalid . imul edi . cmp eax, var . mov ecx, var . out var, eax . jle var . aaa . mov ecx, esp . inc eax . mov ah, var . int1 . inc esp . add bl, byte [ecx - 5] . and dword [edx], edi . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dl, dl . bound edx, qword [ebx + var] . dec ebx . test eax, var . xlatb . imul byte [eax + eax] . add byte [ecx], al . add byte [eax], al . add byte [edx], ah . je var . jbe var . popaw . je var . jb var . outsb dx, byte [esi] . je var . imul esp, dword gs:[edi], var . int . xor dword [eax], eax . add al, var . adc dl, byte [esi + edx - var] . cdq . invalid . dec edx . xchg eax, esi . stc . add ah, ch . or edi, esp . inc edx . xor eax, var . push ss . push var . cdq . shr byte [esi + var], cl . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . cmp ecx, dword [var] . jne var . ret . jmp loc.00441993 . mov eax, dword [var] . test eax, eax . je var . sub eax, 8 . cmp dword [eax], var . jne var . push eax . call var . pop ecx . ret . mov eax, dword [var] . test eax, eax . push esi . mov esi, ecx . mov byte [esi + var], 0 . jne var . call var . mov dword [esi + 8], eax . mov ecx, dword [eax + var] . mov dword [esi], ecx . mov ecx, dword [eax + var] . mov dword [esi + 4], ecx . mov ecx, dword [esi] . cmp ecx, dword [var] . je var . mov ecx, dword [var] . test dword [eax + var], ecx . jne var . call var . mov dword [esi], eax . mov eax, dword [esi + 4] . cmp eax, dword [var] . je var . mov eax, dword [esi + 8] . mov ecx, dword [var] . test dword [eax + var], ecx . jne var . call var . mov dword [esi + 4], eax . mov eax, dword [esi + 8] . test byte [eax + var], 2 . jne var . or dword [eax + var], 2 . mov byte [esi + var], 1 . jmp var . mov ecx, dword [eax] . mov dword [esi], ecx . mov eax, dword [eax + 4] . mov dword [esi + 4], eax . mov eax, esi . pop esi . ret 4 . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . xor eax, ebp . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . je var . or eax, edx . mov eax, ebp . mov ecx, dword [var] . jmp ecx . mov dword [var], eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push esi . push edi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . add edx, ecx . xor edi, edi . mov ebx, var . mov ah, 1 . test ah, ah . mov byte [esp + var], al . mov dword [esp + var], ecx . mov dword [esp + var], esi . mov dword [esp + var], edx . mov dword [esp + var], edi . mov dword [esp + 8], ebx . jne var . jmp var . call var . mov dword [esp + 4], eax . lea esp, [ebp - var] . pop edi . pop esi . pop ebx . pop ebp . ret . mov eax, dword [esp + var] . mov cl, byte [eax] . mov dl, byte [esp + var] . sub cl, dl . mov esi, dword [esp + var] . not esi . mov edi, dword [esp + 8] . not edi . mov dword [esp + var], edi . mov dword [esp + var], esi . mov dword [esp + var], var . mov dword [esp + var], var . mov esi, dword [esp + var] . mov edi, dword [esp + var]
push ebp . push esp . add ecx, var . add eax, ecx . and eax, var . cmp eax, 2 . je var . pop ecx . add ecx, 4 . pop dword [var] . mov dword [var], ecx . mov ecx, ebx . mov dword [var], ecx . call var . cmp ecx, ebp . je var . mov eax, ebx . sub eax, 6 . shl eax, 3 . push eax . xor eax, eax . mov ebp, ebx . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov dword [var], var . call var . mov ecx, 1 . mov edx, dword [var] . add edx, var . cmp eax, edx . mov dword [var], ecx . je var . mov eax, dword [var] . add esp, var . pop ebp . ret . mov eax, var . sub eax, dword [var] . mov dword [var], eax . call var . mov ecx, dword [var] . cmp eax, ecx . setne dl . and dl, 1 . movzx eax, dl . mov dword [var], eax . jmp var . int . int
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov dword [var], esi . mov dword [var], eax . call var . mov dword [var], eax . ret . pop edx . add edx, ecx . mov dword [var], edx . test eax, eax . mov eax, var . cmp ecx, 5 . jne var . pop dword [var] . add esp, var . mov dword [ebp - 8], eax . add dh, byte [var] . push ebp . xor dword [edx + var], var . jns var . invalid . jae var . mov ss, word [ebp + var] . invalid . cmpsd dword [esi], dword ptr es:[edi] . aad var . cmp al, var . clc . cmp al, var . dec ebp . pop edi . sub al, var . and eax, var . push esp . aaa . mov edi, var . cmpsb byte [esi], byte ptr es:[edi] . cmp dword [eax + var], ebx . pop ds . into . sar byte [ecx - 8], 1 . jp var . int var . mov dl, byte [ebx] . jo var . sbb al, var . iretd . test byte [eax + edi*4 - var], ah . insb byte es:[edi], dx . in eax, var . aas . xor eax, var . push varffffffb6 . or eax, var . jp var . push eax . cwde . les edi, [eax + var] . jmp var . add dh, byte [var] . push ebp . xor dword [edx + var], var . jns var . invalid . jae var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
add eax, ebp . xor edx, eax . and edx, var . inc edx . mov dword [var], esp . cmp edx, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . cmove esi, eax . mov eax, dword [esi + var] . mov eax, dword [eax + var] . mov esi, eax . add esi, var . mov eax, dword [eax + var] . cmp eax, esi . pop esi . pop edi . pop ebx . pop ebp . ret . nop . nop . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov ecx, dword [var] . mov edx, dword [var] . xor esi, esi . mov edi, var . sub edi, edx . sbb esi, ecx . mov dword [var], edi . mov dword [var], esi . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx
push ebp . xor ecx, ecx . add ecx, 5 . mov eax, edi . dec ecx . sub esp, ecx . mov dword [esp], eax . mov eax, ebx . mov edx, esp . push ebp . xor ecx, ecx . add ecx, var . mov eax, edi . dec ecx . dec edx . add edx, ecx . inc edx . push edx . push ebp . mov ebp, esp . mov ecx, dword [var] . je var . sub edx, 4 . pop ebp . add esp, var . call var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . mov eax, dword [sym.imp.KERNEL32.dll_lstrlenA] . mov dword [var], eax . mov esp, ebp . pop ebp . ret . std . sub eax, var . push edi . xor edi, esp . into . fcmovb st(0), st(4) . adc bl, ch . insd dword es:[edi], dx . mov bh, var . insd dword es:[edi], dx . out dx, al . test byte [edx + edi*2 + var], bl . push varffffff9a . mov ebp, var . outsd dx, dword [esi] . cmp byte [bx + di + var], var . bound eax, qword [edx + var] . pop edi . int1 . xor dword [ebx + var], esi . dec edx . test eax, var . hlt . mov dh, var . push edi . xchg eax, edi . add dword [edx], edi
pushal . call var . jmp var . push ebp . ret . call var . jmp var . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[ebx + var], cl . add byte [ebx], cl . invalid . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4] . add eax, var . push 4 . push var . push eax . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . push esi
push ebx . push esi . push edi . b9d2c30100 mov ecx, var . ret . add dword [eax], eax . call var . 81f958fffe01 cmp ecx, var . pop eax . invalid . inc byte [ecx] . js var . jns var . e983042412 jmp var . add dword [esp], var . loop var . call var . add eax, dword [eax] . add ah, cl . push ebp . mov ebp, esp . sub esp, var . push ebx . push esi . push edi . b9d2c30100 mov ecx, var . ret . add dword [eax], eax . call var . 81f958fffe01 cmp ecx, var . pop eax . invalid . inc byte [ecx] . js var . jns var . e983042412 jmp var . add dword [esp], var . loop var . call var . inc ebp . xchg eax, esp . mov cl, var . mov ah, var . xor ebx, ebx . mov dword [ebp - var], var . push eax . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . mov dword [ebp - var], var . call var . mov esi, eax . mov dword [ebp - var], var
push var . push 0 . push var . call sub.MSVCRT.dll_memset . add esp, var . push 0 . call sub.KERNEL32.dll_GetModuleHandleA . mov dword [var], eax . push 0 . push var . push 0 . call sub.KERNEL32.dll_HeapCreate . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . push dword [var] . call var . push 7 . push var . lea eax, [var] . push eax . push 8 . call var . push var . push var . push 7 . push var . push 8 . call var . mov edx, var . lea ecx, [var] . call var . mov edx, str.Error . lea ecx, [var] . call var . mov edx, str.Can_not_create_some_of_your_include_files. . lea ecx, [var] . call var . mov edx, str.Can_not_allocate_the_memory. . lea ecx, [var] . call var . mov edx, str.Wrong_password. . lea ecx, [var] . call var . mov edx, var . lea ecx, [var] . call var . mov edx, str.The_file . lea ecx, [var] . call var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . push ebp . mov dword [var], eax . mov dword [ebp - 4], eax . mov dword [var], edi . xor ebp, eax . call var . call var . ret . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push esi . push edi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, var . mov dword [esp + var], var . mov ebx, dword [esp + var] . xor ebx, var . mov dword [esp + var], ebx . mov dword [esp + var], var . mov ebx, dword [esp + var] . mov ah, byte [edx + ecx] . xor ebx, var . imul ebx, dword [esp + var] . mov edx, dword [esp + var] . sub ah, al . xor edx, var . cmp edi, edx . mov byte [esp + var], ah . mov dword [esp + var], ecx . mov dword [esp + 8], ebx . mov dword [esp + 4], esi . jae var . mov eax, dword [esp + var] . mov cl, byte [esp + var] . mov byte [eax], cl . lea esp, [ebp - var] . pop edi . pop esi . pop ebx . pop ebp . ret . mov eax, var . mov ecx, dword [esp + 4] . mov edx, dword [esp + var] . add ecx, edx . mov dword [esp + var], ecx . mov ecx, dword [esp + 8] . cmp eax, ecx . ja var . jmp var . push ebp
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax - var], ah . sub byte [edi], var . mov dword [edi + var], ebx . mov ebx, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . xor byte [esi + var], cl . jb var . insb byte es:[edi], dx . jae var . cmp byte [eax], al . and byte [eax], cl . inc ecx . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add dl, ch . mov eax, var . dec edx . mov bh, var . test eax, var . mov ah, var . mov dl, var . push ebx . adc al, var . pop ebp . dec esi . test al, var . or al, 0 . push eax . push es . clc . loope var . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . cmp eax, 4 . je var . or eax, esp . or eax, 5 . cmp eax, 0 . mov dword [var], eax . ret . pop edx . add edx, ecx . test eax, eax . mov dword [var], edx . jne var . pop dword [var] . mov eax, var . add esp, var . cmp ecx, 0 . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, sym.__Ordinal_92 . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [esp + var] . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . lea ecx, [esp + var] . mov edx, dword [sym.imp.USER32.dll_GetMenuDefaultItem] . call edx . and ebx, dword [ecx - var] . invalid . xchg eax, ecx . xor eax, var . bound esi, qword [ebx + var] . arpl bp, bx . cmpsb byte [esi], byte ptr es:[edi] . mov bh, var . cmp edi, edx . and ah, bh . jl var . insd dword es:[edi], dx
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
call var . cmp ecx, var . cmp edx, var . cmp edx, var . mov ecx, ebp . mov eax, ebx . mov dword [var], eax . jg var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . add edx, ecx . mov edi, ecx . imul edi, edi . mov ebx, ecx . imul ebx, ebx . mov byte [esp + var], al . mov eax, ecx . sub eax, eax . mov dword [esp + var], eax . mov eax, ecx . add eax, eax . mov dword [esp + var], eax . mov eax, dword [esp + var] . mov dword [esp + 8], ecx . mov ecx, dword [esp + var] . imul eax, ecx . sub ebx, edi . cmp ebx, eax . mov dword [esp + 4], esi . mov dword [esp], edx . jb var . mov eax, dword [esp + var] . mov ecx, dword [esp] . mov dl, byte [ecx] . and eax, var . mov dh, byte [esp + var] . sub dl, dh . mov dword [esp + var], eax . mov dword [esp + var], 0 . mov eax, dword [esp + 4] . mov esi, dword [esp + 8] . mov byte [eax + esi], dl . lea esp, [ebp - var] . pop esi . pop edi . pop ebx . pop ebp . ret . push ebp
call var . cmp eax, 4 . je var . mov dword [var], eax . ret . pop edx . add edx, ecx . test eax, eax . mov dword [var], edx . jne var . pop dword [var] . mov eax, var . add esp, var . cmp ecx, 0 . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . lea eax, section..data . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . push esi . push ebx . push edi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, dword [esp + 8] . mov ebx, dword [esp + var] . xor edi, var . mov ah, byte [edx + ecx] . sub ah, al . mov dword [esp + var], ebx . mov dword [esp + 8], edi . mov byte [esi + ecx], ah . mov ecx, dword [esp + 4] . add ecx, var . mov dword [esp + 4], ecx . lea esp, [ebp - var] . pop edi . pop ebx . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push esi . push ebx . push edi . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], var . mov ecx, dword [esp + var]
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041db88 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . lea eax, [ecx + 4] . mov dword [ecx], vtable.std::exception.0 . push eax . call var . pop ecx . ret . push ebp . mov ebp, esp . push esi . mov esi, ecx . lea eax, [esi + 4] . mov dword [esi], vtable.std::exception.0 . push eax . call var . test byte [ebp + 8], 1 . pop ecx . je var . push var . push esi . call var . pop ecx . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, dword [var] . test eax, eax . test edx, eax . mov eax, edx . lea edx, [var] . cmp ecx, 5 . jmp loc.00401fbc . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . movzx eax, word [var] . mov cx, ax . mov edx, eax . and edx, var . mov si, dx . mov word [var], si . xor edx, edx . mov dword [var], edx . mov dword [var], var . mov dword [var], var . mov edi, dword [var] . mov ebx, dword [var] . mov word [var], var . mov dword [var], eax . mov al, byte [var] . mov ah, al . not ah . mov byte [var], ah . mov dword [var], edx . mov dword [var], var . mov edx, dword [var] . add edx, var . mov si, dx . mov word [var], si . mov edx, edi . xor edx, var . mov esi, dword [var] . mov dword [var], edx . mov edx, dword [var] . mov dword [var], edx . mov edx, dword [var] . mov dword [var], edx . mov dx, word [var] . mov byte [var], al . xor dx, var . mov word [var], var . mov word [var], dx . mov dx, word [var] . mov word [var], 0 . mov dword [var], esi . mov esi, dword [var] . mov dword [var], esi . lea esi, [var] . mov dword [var], esi . lea esi, [var] . mov dword [var], esi . lea esi, [var] . mov dword [var], esi . mov esi, dword [var]
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . add esi, 2 . cmp word [esi], bx . je var . cmp word [esi], var . jne var . push var . add esi, 2 . pop ebx
push ebp . push esp . mov ecx, esi . push ecx . xchg esi, ecx . call var . xchg edx, edi . mov eax, 2 . push edx . shl eax, 1 . mov ecx, eax . mov eax, ebx . mov edi, edx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - 8], var . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . call esi . mov ecx, dword [sym.imp.USER32.dll_GetClipboardSequenceNumber] . mov dword [ebp - var], eax . call ecx . mov dword [ebp - var], eax . call var . call var . mov ecx, dword [sym.imp.KERNEL32.dll_OpenMutexA] . mov dword [esp], ecx . mov dword [ebp - var], eax . call var . cmp eax, 0 . je var
push ebp . push esp . xchg ecx, esi . push ecx . mov esi, ecx . call var . mov edx, edi . mov eax, 2 . push edx . shl eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . and ebx, var . add ebx, var . dec esi . and esi, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . mov dword [var], var . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . call esi . mov dword [var], eax . call var . mov ecx, dword [var] . mov dword [var], ecx . mov edx, dword [var] . mov dword [var], edx . mov esi, dword [var] . mov dword [var], esi . mov dword [var], eax . call var . call var . mov ecx, dword [sym.imp.KERNEL32.dll_AllocConsole] . sub esp, 4
push ebp . push esp . mov eax, ebp . add eax, var . xor ecx, ecx . mov edx, ebx . mov dword [var], edx . or eax, edx . add ecx, 4 . cmp eax, 0 . je var . pop edx . add edx, ecx . pop dword [var] . mov dword [var], edx . cmp ecx, 0 . jne var . test eax, eax . je var . mov eax, var . add esp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov eax, dword [var] . mov ecx, dword [var] . add eax, var . adc ecx, 0 . mov dword [var], eax . mov dword [var], ecx . call var . mov ecx, dword [var] . xor ecx, var . mov dword [var], 1 . cmp eax, ecx . je var . jmp var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push edx . mov dword [esp], esi . push eax . push eax . add esp, 4 . mov dword [esp], ebx . call var . push eax . ljmp var . or al, var . stosb byte es:[edi], al . sar dword [esi], 1 . pop esp . xchg eax, ebx . mov edi, var . mov bl, var . arpl word [eax], si . fcomp dword [edx - var] . sbb eax, var . dec ebp . outsb dx, byte [esi] . cmp ch, byte [ecx] . sub esi, esi . inc ebx . sub ch, byte [ebx] . mov esi, var . fdiv st(0), st(0) . sbb al, var . stosb byte es:[edi], al . lea esp, [eax] . enter var, varffffff97 . add dword [edx + ecx*8], var . push cs . pop ss . adc dword [ebx - var], var . inc esp . out dx, eax . inc di . jmp var . enter varffff8c29, var . jge var . jg var . mov dword [var], eax . fsub dword [ebx] . cmp al, var . jmp var . std . jl var . xor ebp, dword [ebx] . jo var . sub byte [esi], cl . push edi . jo var . outsd dx, dword [esi] . mov esi, var . retf var . add edx, dword [eax] . cmp byte [ebx - var], ch . aas . xor cl, cl . push edi . in eax, var . adc al, var . push ebp
mov eax, dword [var] . test eax, eax . test edx, eax . mov eax, edx . lea edx, [var] . cmp ecx, 5 . jmp loc.0040340a . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . movzx esi, word [var] . imul esi, esi . mov di, si . mov word [var], di . mov dword [var], edx . mov edx, dword [var] . mov esi, edx . add esi, esi . mov dword [var], esi . mov dword [var], eax . mov dword [var], ecx . mov bl, byte [var] . mov bh, bl . add bh, var . mov byte [var], bh . xor eax, eax . mov dword [var], eax . mov dword [var], var . mov ecx, dword [var] . mov esi, dword [var] . mov dword [var], edx . mov edx, var . sub edx, esi . sbb eax, ecx . mov byte [var], 0 . mov dword [var], edx . mov byte [var], bl . mov dword [var], eax . jb var . jmp var . call var . mov dword [var], eax . lea esp, [var] . pop esi . pop edi . pop ebx . pop ebp . ret var . xor eax, eax . mov dword [esp], 0 . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], eax . call var . mov cl, byte [var] . add cl, var
push ebp . push esp . mov eax, esi . push eax . add eax, 5 . call var . mov edx, edi . mov eax, 8 . push edx . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx
lea esi, [ebx] . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . sub esp, 8 . mov eax, section..jnbcf . xor ecx, ecx . mov edx, eax . sub edx, var . cmova ecx, eax . mov eax, ecx . mov dword [ebp - 8], edx . add esp, 8 . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [var] . lea ecx, [var] . lea edx, [var] . mov esi, dword [var] . mov dword [var], var . imul edi, esi, var . lea ebx, [var] . mov dword [var], edi . lea edi, [var] . mov dword [var], eax . mov al, byte [var] . mov byte [var], 0 . mov byte [var], al . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, esi . xor eax, var . mov dword [var], eax . mov dword [var], var . mov eax, dword [var] . add eax, var . mov dword [var], eax . mov eax, dword [var] . mov dword [var], esi . mov si, word [var] . mov word [var], si . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . mov al, byte [var] . sub al, var . mov byte [var], al . mov dword [var], edx . mov dword [var], ebx . mov dword [var], edi . mov word [var], si . mov dword [var], ecx
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . xor esi, esi . push esi . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi . push esi . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . push eax . call main . mov dword [var], eax . push eax
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . mov eax, 5 . push edi . dec eax . mov ecx, eax . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [var] . mov dword [var], eax . call var . mov ecx, dword [var] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp
call var . jmp var . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], edi . mov dword [var], esi . mov esi, dword [var] . mov edi, dword [var] . mov ecx, dword [var] . shr ecx, 7 . jmp var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmm1, xmmword [esi + var] . movdqa xmm2, xmmword [esi + var] . movdqa xmm3, xmmword [esi + var] . movdqa xmmword [edi], xmm0 . movdqa xmmword [edi + var], xmm1 . movdqa xmmword [edi + var], xmm2 . movdqa xmmword [edi + var], xmm3 . movdqa xmm4, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . movdqa xmm6, xmmword [esi + var] . movdqa xmm7, xmmword [esi + var] . movdqa xmmword [edi + var], xmm4 . movdqa xmmword [edi + var], xmm5 . movdqa xmmword [edi + var], xmm6 . movdqa xmmword [edi + var], xmm7 . lea esi, [esi + var] . lea edi, [edi + var] . dec ecx . jne var . mov esi, dword [var] . mov edi, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov dword [var], edi . mov dword [var], esi . mov dword [var], ebx . mov ebx, dword [var] . mov eax, ebx . cdq . mov ecx, eax . mov eax, dword [var] . xor ecx, edx . sub ecx, edx . and ecx, var . xor ecx, edx . sub ecx, edx . cdq . mov edi, eax . xor edi, edx . sub edi, edx . and edi, var . xor edi, edx . sub edi, edx . mov edx, ecx . or edx, edi . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push ebp . push esp . mov eax, ebp . add eax, var . xor ecx, ecx . xchg edx, ebx . mov dword [var], edx . or eax, edx . add ecx, 4 . mov ebx, edx . cmp eax, 0 . je var . pop edx . add edx, ecx . pop dword [var] . mov dword [var], edx . cmp ecx, 0 . jne var . test eax, eax . je var . mov eax, var . add esp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], var . call var . mov ecx, 1 . mov edx, var . sub edx, dword [var] . cmp eax, edx . mov dword [var], ecx . je var . mov eax, dword [var] . add esp, 8 . pop ebp . ret . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . jmp var . int . int . int . int . int . int . int
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push var . call var . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . wait . jle var . sbb al, var . dec edx . inc ecx . mov ecx, var . loope var . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . inc edx . jne var . insb byte es:[edi], dx . xor dword [eax], eax . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . adc al, var . jg var . cmp bh, byte [ebx - var] . stc . xor esi, dword [edi + ebp*2 + var] . cmpsd dword [esi], dword ptr es:[edi] . sti . enter varfffff4ff, var . dec edx . adc byte [ebp + var], var . stosb byte es:[edi], al . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], ah . invalid . adc edx, dword [eax - var] . pop ebp . mov ecx, var . pop edi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . jb var . push ebp . jo var . outsd dx, dword [esi] . dec ebx . dec edi . dec ebp . push eax . inc ecx . inc edi . dec esi . dec edi . dec esi . inc ebp . push edx . dec esi . inc ebp . push ebx . add byte [eax], dh . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . fsubr dword [edx] . xchg eax, ebx . sbb eax, var . invalid . ror byte [edi + var], cl . push var . mov eax, dword [var] . dec esp . or ecx, dword [esi] . inc byte [eax + var] . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . push 0 . push var . call sub.MSVCRT.dll_memset . add esp, var . push 0 . call sub.KERNEL32.dll_GetModuleHandleW . mov dword [var], eax . push 0 . push var . push 0 . call sub.KERNEL32.dll_HeapCreate . mov dword [var], eax . call var . call var . call var . mov eax, var . push eax . mov eax, str.c_net_stop_AdobeFlashPlayerHash . push eax . mov eax, var . push eax . call var . push var . call var . mov eax, var . push eax . mov eax, str.c_sc_delete__AdobeFlashPlayerHash . push eax . mov eax, var . push eax . call var . push var . call var . mov eax, str.C:__Windows__parameters1 . push eax . call var . mov eax, str.C:__Windows__parameters1__hostdll.exe . push eax . call sub.SHLWAPI.DLL_PathFileExistsW . and eax, eax . je var . xor eax, eax . jmp var . mov eax, 1 . and eax, eax . jne var . mov ebx, dword [var] . and ebx, ebx . je var . jmp var . mov eax, 1 . jmp var . xor eax, eax . and eax, eax . je var . mov eax, str.C:__Windows__parameters1__hostdll.exe . push eax . push var . call var . mov dword [var], eax . cmp dword [var], 0 . je var . mov ebp, str.hash_____value_17E5BDB98D1D154A219EBD989C8883C6_____commentary_____value_0000_____Description_____value_Microsoft_.NET_Framework_NGEN_____DisplayName_____value_Microsoft_.NET_Framework_NGEN_v1.0.13491_X64_____mincorecount_____value_2_____mainer_dir_____value_C:__Windows__Installer__PatchCach_____ssl_____activ_1_____MyMainerBlackList_____url_http:__mine.zarabotaibitok.ru_Downloads_blockproc.txt_____mainer_param_str_____value__o_test.zarabotaibitok.ru:11111__o_kasp.zarabotaibitok.ru:11111__u_21_05__p_x___donate_level_1___api_port_1010_____mainer_exe_____value_SystemNT.exe_____ServerHS_____0_62.76.75.170_____AutoCloseProcessTimer_____value_10000taskmgr.exe____ProcessHacker.exe____perfmon.exe____procexp.exe____procexp64.exe____procexp32.exe____PT.exe____resmon.exe____autoruns.exe____procmon.exeMZ
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], ah . inc ebx . out dx, al . dec ecx . mov cl, var . stc . out var, al . int . mov byte [0], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push esi . inc ecx . dec esp . dec ecx . inc esp . dec edi . push ebp . push ebx . xor dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . push ss . fcom dword [ecx] . mov esp, var . inc ebx . lodsb al, byte [esi] . mov dl, var . cmp byte [ebp + var], ch . lcall var:var . or al, var . mov bl, var . int . retf var . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], ch . add eax, var . invalid . dec esp . xchg eax, ebx . adc al, byte [eax + 4] . push edi . push edx . sub dword [ecx], edx . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax + var], al . add byte [ebp + var], al . insb byte es:[edi], dx . popal . push var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add byte [edx], al . popfd . adc ecx, dword [ebx] . xchg dword [esi + var], ecx . adc eax, var . scasb al, byte es:[edi] . push cs . out dx, al . int1 . mov dword [var], eax . test edx, eax . mov esi, var . jb var . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
add ecx, dword [ebp] . xor edx, ecx . and edx, var . inc edx . mov dword [var], esp . cmp edx, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . cmove esi, eax . mov eax, dword [esi + var] . mov eax, dword [eax + var] . mov esi, eax . add esi, var . mov eax, dword [eax + var] . cmp eax, esi . pop esi . pop edi . pop ebx . pop ebp . ret . nop . nop . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov cx, var . mov word [var], var . mov dword [var], var . sub cx, word [var] . mov word [var], cx . mov dword [var], eax . call var . mov edx, dword [var] . add edx, var . cmp eax, edx . jne var . jmp var . mov eax, var . sub eax, dword [var] . mov dword [var], eax . jmp var . mov ax, var . mov cx, word [var] . mov dx, word [var] . sub ax, cx . cmp dx, ax . jbe var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx - var], dl . jb var . inc edx . invalid . and eax, var . cmp al, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . cmp byte [ecx], var . add edx, dword [eax + var] . jae var . outsd dx, dword [esi] . insb byte es:[edi], dx . jo var . outsd dx, dword [esi] . outsd dx, dword [esi] . add byte [eax], ah . or byte [ecx], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add eax, var . dec ecx . inc ebp . and al, var . cmpsb byte [esi], byte ptr es:[edi] . xchg eax, ebx . pop edx . cmp bl, dl . loope var . adc ah, dl . add byte [eax + var], var . nop . fistp qword [edx] . loop var . pop edi . fcmovne st(0), st(5) . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, var . call var . call var . add bh, bh . invalid . invalid . inc dword [ecx] . add byte [eax], al . add byte [ebp], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push edi . mov eax, esi . and eax, var . test eax, eax . jne var . mov edx, ecx . and ecx, var . shr edx, 7 . je var . jmp var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmm1, xmmword [esi + var] . movdqa xmm2, xmmword [esi + var] . movdqa xmm3, xmmword [esi + var] . movdqa xmmword [edi], xmm0 . movdqa xmmword [edi + var], xmm1 . movdqa xmmword [edi + var], xmm2 . movdqa xmmword [edi + var], xmm3 . movdqa xmm4, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . movdqa xmm6, xmmword [esi + var] . movdqa xmm7, xmmword [esi + var] . movdqa xmmword [edi + var], xmm4 . movdqa xmmword [edi + var], xmm5 . movdqa xmmword [edi + var], xmm6 . movdqa xmmword [edi + var], xmm7 . lea esi, [esi + var] . lea edi, [edi + var] . dec edx . jne var . test ecx, ecx . je var . mov edx, ecx . shr edx, 4 . test edx, edx . je var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmmword [edi], xmm0 . lea esi, [esi + var] . lea edi, [edi + var] . dec edx . jne var . and ecx, var . je var . mov eax, ecx . shr ecx, 2 . je var . mov edx, dword [esi] . mov dword [edi], edx . lea esi, [esi + 4] . lea edi, [edi + 4] . dec ecx . jne var . mov ecx, eax . and ecx, 3 . je var . mov al, byte [esi] . mov byte [edi], al . inc esi . inc edi
push ebp . mov ecx, ebp . inc ecx . inc ecx . inc ecx . mov ebp, esp . push 4 . lea esp, [var] . cmp sp, var . jb var . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call dword [sym.imp.kernel32.dll_OpenJobObjectW] . cmp eax, 0 . jne var . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call dword [sym.imp.kernel32.dll_OpenJobObjectW] . cmp eax, 0 . jne var . push var . dec dword [esp] . push var . call dword [sym.imp.kernel32.dll_IsBadReadPtr] . cmp eax, 0 . jne var . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call dword [sym.imp.kernel32.dll_OpenJobObjectW] . test eax, eax . jne var . push var . dec dword [esp] . push var . call dword [sym.imp.kernel32.dll_IsBadReadPtr] . test eax, eax . jne var . push var . push 1 . dec dword [esp] . push var . dec dword [esp] . call dword [sym.imp.kernel32.dll_OpenJobObjectW] . cmp eax, 0 . jne var . push var . dec dword [esp] . push var . call dword [sym.imp.kernel32.dll_IsBadReadPtr] . test eax, eax . jne var . push var . dec dword [esp] . push var . call dword [sym.imp.kernel32.dll_IsBadReadPtr]
jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
call var . jmp var . push var . push var . call var . call var . movzx esi, ax . push 2 . call var . pop ecx . mov eax, var . cmp word [var], ax . je var . xor ebx, ebx . jmp var . mov eax, dword [var] . cmp dword [eax + var], var . jne var . mov ecx, var . cmp word [eax + var], cx . jne var . xor ebx, ebx . cmp dword [eax + var], var . jbe var . cmp dword [eax + var], ebx . setne bl . mov dword [var], ebx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . and dword [var], 0 . call var . test eax, eax . jns var . push var . call var . pop ecx . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . test eax, eax . jns var . push 8 . call var . pop ecx . call var . test eax, eax . jns var . push 9 . call var . pop ecx . push 1
mov eax, dword [var] . test eax, eax . test edx, eax . mov eax, edx . lea edx, [var] . cmp ecx, 5 . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . mov dword [var], 0 . mov dword [var], var . mov esi, dword [var] . and esi, var . mov dword [var], esi . mov esi, dword [var] . mov edi, dword [var] . mov ebx, edi . add ebx, var . mov dword [var], eax . mov eax, esi . adc eax, 0 . mov dword [var], eax . mov dword [var], ebx . mov dword [var], edx . mov eax, dword [var] . mov edx, dword [var] . mov ebx, dword [var] . mov dword [var], ebx . xor edx, var . or edx, eax . mov dword [var], edi . mov dword [var], ecx . mov dword [var], esi . mov dword [var], edx . jne var . jmp var . mov eax, dword [var] . mov dword [var], eax . mov ecx, dword [var] . mov edx, dword [var] . imul ecx, edx . mov eax, dword [var] . mov esi, dword [var] . mul esi . add edx, ecx . add edx, ecx . mov dword [var], eax . mov dword [var], edx . call var . mov dword [esp], eax . lea esp, [var] . pop esi . pop edi . pop ebx . pop ebp
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
mov eax, ebp . shl eax, 1 . xor eax, ebx . and eax, var . add eax, 3 . mov dword [var], esp . cmp eax, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add esp, var . cmp eax, 2 . jb var . push ebx . push ecx . call var . mov dword [var], eax . add ebp, var . test eax, eax . cmp eax, var . jne var . mov ebx, ebp . xor eax, eax . nop . nop . nop . nop . ret . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], eax . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . jne var . jmp var . mov eax, dword [var] . add eax, var . mov dword [var], eax . mov eax, dword [var] . add esp, var . pop ebp . ret . mov eax, dword [var] . xor eax, var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . jmp var . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . sub esp, 1 . lea eax, section.CODE . add esp, 1 . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov dword [esp + var], var . mov word [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . lea eax, [esp + var] . mov dword [esp + var], var . mov dword [esp + var], var . mov ecx, dword [sym.imp.SHLWAPI.dll_HashData] . call ecx . mov bh, var . test eax, var . jns var . stosb byte es:[edi], al . add ah, byte [var] . inc esp . test dword [edx + var], var . fidivr dword [esi + var] . jns var . push eax . dec esi . push esi . retf var . mov dword [ebp - var], var . mov dl, byte [esp + var] . mov ecx, dword [esp + var] . mov esi, ecx . and esi, 1 . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], 6 . mov di, word [esp + var] . mov bx, di . add bx, var
mov eax, ebp . shl eax, 1 . xor eax, ebx . and eax, var . add eax, 3 . mov dword [var], esp . cmp eax, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . mov ebx, dword [var] . cmp ebx, ecx . jne var . pushal . push ecx . call var . mov dword [var], eax . xor ebx, edx . popal . jne var . mov ebx, ebp . nop . nop . nop . nop . ret . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov cx, var . mov word [var], var . mov byte [var], var . mov dword [var], var . sub cx, word [var] . mov word [var], cx . mov dword [var], eax . call var . mov edx, dword [var] . add edx, var . cmp eax, edx . jne var . jmp var . mov ax, word [var]
mov dword [var], eax . mov dword [var], eax . call var . cmp ecx, 2 . mov dword [var], eax . je var . call var . call var . cmp esp, var . xor eax, eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . mov edi, var . mov dword [ebp - var], var . sub edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp . ret . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . je var . jmp var . push ebp . mov ebp, esp . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [ebp + 8] . xor ecx, ecx . mov byte [esp + var], 4 . cmp eax, 0 . mov dword [esp + var], eax . mov dword [esp + 8], ecx . je var . xor eax, eax . mov ecx, 1
push ebp . mov edx, edi . mov dword [var], edx . pop eax . lea edx, [var] . mov dword [edx + var], ebx . push esp . push eax . push esi . call var . mov dword [var], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . push edi . push esi . mov ecx, 4 . sub esp, ecx . mov ecx, ebx . mov dword [esp], ecx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . sub esp, var . mov eax, var . mov ecx, var . mov dword [ebp - 4], var . sub ecx, dword [ebp - 4] . mov dword [ebp - var], ecx . cmp eax, dword [ebp - var] . je var . lea eax, [var] . lea ecx, [ebp - var] . mov edx, dword [ebp - 4] . add edx, var . mov dword [esp], ecx . mov dword [esp + 4], eax . mov dword [esp + 8], edx . mov dword [ebp - var], ecx . call var . call var . mov dword [esp], eax . mov eax, dword [ebp - var] . mov dword [esp + 4], eax . call var . add esp, var . pop ebp . ret . xor eax, eax . mov ecx, var . mov dword [esp], 0 . mov dword [esp + 4], 0 . mov dword [esp + 8], var . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . call sub.ntdll.dll_memmove . xor ecx, ecx . mov dword [ebp - var], eax . mov eax, ecx . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . mov ecx, dword fs:[var] . mov eax, var . cmp ecx, 0 . cmove ecx, eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add al, 0 . add byte [eax], al . add byte [eax], al . add eax, dword [eax] . add eax, dword [eax]
call var . jmp var . mov eax, dword [var] . xor ecx, ecx . cmp eax, dword [ecx*8 + var] . je var . inc ecx . cmp ecx, var . jb var . lea ecx, [eax - var] . cmp ecx, var . ja var . push var . pop eax . ret . mov eax, dword [ecx*8 + var] . ret . add eax, var . push var . pop ecx . cmp ecx, eax . sbb eax, eax . and eax, ecx . add eax, 8 . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, 8 . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, var . ret . push esi . call var . mov ecx, dword [var] . push ecx . mov dword [eax], ecx . call var . pop ecx . mov esi, eax . call var . mov dword [eax], esi . pop esi . ret . push ebp . mov ebp, esp . mov eax, var . sub esp, var . cmp word [var], ax . je var . push ebx . push dword [var] . lea ecx, [var] . call var . mov eax, dword [var] . mov ecx, dword [eax + var] . xor ebx, ebx
call var . jmp var . push ebp . mov ebp, esp . sub esp, var . push ebx . push dword [var] . lea ecx, [var] . call var . xor ebx, ebx . cmp dword [var], ebx . jne var . call var . push ebx . push ebx . push ebx . push ebx . push ebx . mov dword [eax], var . call var . add esp, var . cmp byte [var], bl . je var . mov eax, dword [var] . and dword [eax + var], var . mov eax, var . jmp var . push esi . mov esi, dword [var] . cmp esi, ebx . jne var . call var . push ebx . push ebx . push ebx . push ebx . push ebx . mov dword [eax], var . call var . add esp, var . cmp byte [var], bl . je var . mov eax, dword [var] . and dword [eax + var], var . mov eax, var . jmp var . push edi . mov edi, dword [var] . cmp dword [edi + 8], ebx . jne var . push esi . push dword [var] . call var . pop ecx . pop ecx . jmp var . mov eax, dword [var] . movzx cx, byte [eax] . movzx ecx, cx . movzx edx, cl . inc eax . test byte [edx + edi + var], 4 . mov dword [var], eax . je var
mov edi, edi . push ebp . mov ebp, esp . cmp dword [var], 1 . jne var . call var . push dword [var] . mov ecx, dword [var] . mov edx, dword [var] . call var . pop ecx . pop ebp . ret var . ├ 262: loc.10016a6e (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_IsDebuggerPresent] . mov dword [var], eax . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . cmp dword [var], 0 . jne var . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . jmp dword [var] . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . bnd ret . mov ecx, dword [var] . xor ecx, ebp . bnd call var . bnd jmp var . mov ecx, dword [var] . xor ecx, ebp . bnd call var . bnd jmp var . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + eax*4 - var], ch . jl var . sub al, var . dec ecx . mov ch, var . invalid . sbb al, var . aas . ret . push esi . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . push ecx . pop esp . push eax . jb var . dec esi . imul esp, dword [ebx + var], var . add byte fs:[ebx + var], dh . outsb dx, byte [esi] . popal . aaa . add byte cs:[eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . adc ecx, eax . lodsb al, byte [esi] . sbb eax, var . inc eax . test dword [var], esi . in eax, var . pop ebp . dec esi . and byte [eax], var . jecxz var . dec edi . test eax, var . xchg eax, ecx . adc edi, dword [esi + var] . cdq . iret . adc dword [edi + var], esi . pushal . rcl dword [ebx], cl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov dword [var], ebx . pop dword [var] . add dword [var], 4 . pop dword [var] . push ebp . xor ecx, var . cmp ecx, 2 . je var . pop eax . call var . mov dword [var], eax . xor eax, eax . add eax, var . ret . mov dword [ebp - 4], eax . arpl word [ebx + var], dx . std . xchg dword [var], edi . sbb dword [esi - var], ebp . jg var . adc eax, var . jns var . add esp, eax . xchg eax, ebp . add dword [edx + var], eax . push esi . pushfd . cwde . popfd . hlt . inc byte [esi - var] . sbb al, var . mov esi, var . js var . int1 . in eax, var . xor esi, ebx . fucom st(4) . sub esi, esp . push ebp . xchg eax, ecx . wait . in al, var . pop es . add ebx, edi . pop esi . retf var . sub eax, dword [ebx] . leave . invalid . mov ecx, var . adc eax, var . cwde . clc . insb byte es:[edi], dx . add esp, eax . adc eax, var . jl var . mov cl, var . sbb eax, var . stosd dword es:[edi], eax . cli
mov eax, dword [esp] . xor eax, 7 . sub eax, ecx . or eax, var . inc eax . mov dword [var], esp . test eax, eax . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add ebp, 8 . cmp eax, var . jbe var . mov edx, ebx . sub edx, ecx . and eax, var . pop ecx . add esp, 8 . inc edx . cmp edx, var . jne var . pop ebx . mov eax, 1 . nop . nop . nop . nop . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], var . mov dword [var], eax . call var . mov ecx, dword [var] . add ecx, var . cmp eax, ecx . mov dword [var], eax . jne var . jmp var . mov dword [var], 1 . mov eax, var . sub eax, dword [var] . cmp dword [var], eax . jae var . mov eax, dword [var] . add esp, var
call var . jmp var . push ebp . mov ebp, esp . push var . push dword [var] . push dword [var] . call var . add esp, var . pop ebp . ret . push var . push var . call var . xor ecx, ecx . mov dword [var], ecx . xor eax, eax . mov edi, dword [var] . test edi, edi . setne al . test eax, eax . jne var . call var . mov dword [eax], var . call var . xor eax, eax . jmp var . xor eax, eax . mov ebx, dword [var] . test ebx, ebx . setne al . test eax, eax . je var . xor eax, eax . cmp word [ebx], cx . setne al . test eax, eax . je var . call var . mov esi, eax . mov dword [var], esi . test esi, esi . jne var . call var . mov dword [eax], var . jmp var . xor eax, eax . mov dword [var], eax . cmp word [edi], ax . jne var . call var . mov dword [eax], var . push varfffffffe . lea eax, [var] . push eax . push var . call var . add esp, var . jmp var . push esi . push dword [var] . push ebx . push edi . call var
push ebp . push ebx . xor eax, eax . mov ecx, esi . add eax, var . push ecx . mov esi, ecx . call var . xchg edx, edi . xor eax, eax . inc eax . push edx . shl eax, 2 . xchg eax, ecx . mov eax, ebx . mov edi, edx . mov edx, esp . add edx, ecx . dec edx . add edx, ecx . inc edx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . inc ecx . sub esp, 4 . shl ecx, 4 . dec ecx . cmp ecx, var . jl var . jne var . or ebx, var . cmp eax, ebx . je var . add esp, var . ret . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . push ebx . push edi . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . mov dword [var], var . mov dword [var], var . mov esi, dword [var] . mov edi, dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], esi . call edi . mov ecx, var . mov edx, dword [var] . cmp ecx, edx . mov dword [var], eax . jne var . jmp var . mov eax, dword [var] . xor eax, var . mov dword [var], eax
pushal . call var . pop ebx . add ebx, var . push ebx . cmp al, dl . ret . adc byte [eax], al . push 0 . call dword [sym.imp.KERNEL32.dll_ExitProcess] . ret . nop . nop . nop . pushfd . adc byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx + var], bh . adc byte [eax], al . add byte [eax + edx], ah . add byte [eax], al . add byte [eax], al . add byte [eax], al . salc . adc byte [eax], al . add byte [eax], cl . adc byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + edx], ch . add byte [eax], al . enter var, 0 . add byte [eax], al . add byte [eax], al . jge var . inc ebp . js var . je var . jb var . arpl word [ebp + var], sp . jae var . dec ebx . inc ebp . push edx . dec esi . inc ebp . dec esp . xor esi, dword [edx] . insb byte es:[edi], dx . insb byte es:[edi], dx . add byte [eax], al . ret . add dword [ebp + var], ecx
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041db27 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . jmp var . jmp dword [var] . int . int . int . int . int . int . int . int . int . int . int . int . push var
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . mov cl, byte [eax] . cmp cl, bl . je var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax
add edx, ecx . inc edx . push edx . push ebp . xor ecx, ecx . mov eax, edi . dec ecx . sub esp, ecx . mov dword [esp], eax . mov eax, ebx . mov edx, esp . add esp, 9 . xchg esi, ecx . mov dword [esp], ecx . mov esi, ecx . mov eax, edi . dec ecx . dec edx . add edx, ecx . inc edx . mov edx, 4 . xchg esi, ecx . add eax, ecx . xchg esi, ecx . mov dword [esp], ecx . mov esi, ecx . mov eax, edi . dec ecx . dec edx . sub esp, var . push ebp . mov ebp, esp . mov ecx, dword [var] . je var . sub edx, 8 . pop ebp . call var . ret . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push esi . push edi . and esp, var . sub esp, var . lea eax, section..data . mov ecx, dword [esp + 8] . mov edx, dword [esp + var] . mov ebx, ecx . mov dword [esp + 4], ecx . mov cl, bl . mov esi, dword [esp + 4] . shl esi, cl . mov cl, bl . mov edi, dword [esp + 4] . shld edx, edi, cl . xor ecx, ecx . test bl, var . cmovne edx, esi . cmovne esi, ecx . mov dword [esp + var], edx . mov dword [esp + 8], esi . lea esp, [ebp - var]
jl var . push var . call var . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . push eax . add byte [eax], al . add byte [eax], bh . add byte [eax], al . add byte [eax + var], dl . lea ebp, [edx - var] . test byte [edi], dl . rcr byte [ebx + 9], 1 . xchg byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc eax . add byte [ecx + var], dl . inc ecx . dec ecx . outsb dx, byte [esi] . add byte [ebx + var], dl . insd dword es:[edi], dx . jo var . and byte gs:[ecx + var], al . dec ecx . outsb dx, byte [esi] . and byte [eax + var], dl . outsd dx, dword [esi] . push var . arpl word [eax + eax - var], si . inc eax . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [esi], al . add byte [eax + var], ah . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [edx], dl . inc eax . add byte [eax - var], dl . inc eax . add byte [ecx], al . add byte [eax], al . add byte [eax + var], dh . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], dh
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . push 1 . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . xor esi, esi . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp var . ret var . call var . int . push ebp . mov ebp, esp . push ecx . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . add eax, dword [var] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . push ecx . push ecx . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 1 . mov eax, dword [var] . inc eax . mov dword [var], eax . cmp dword [var], var . jb var . mov eax, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [dwSize], var . push var . push var . push dword [dwSize] . push 0 . call dword [sym.imp.KERNEL32.dll_VirtualAlloc] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov eax, dword [dwSize] . mov dword [var], eax . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . lea eax, [var] . mov dword [var], eax . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
call var . jmp var . int . int . int . int . int . push ebp . mov ebp, esp . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . cmp ecx, var . jb var . cmp dword [var], 0 . je var . push edi . push esi . and edi, var . and esi, var . cmp edi, esi . pop esi . pop edi . jne var . jmp var . test edi, 3 . jne var . shr ecx, 2 . and edx, 3 . cmp ecx, 8 . jb switch.var . rep movsd dword es:[edi], dword ptr [esi] . jmp dword [edx*4 + var] . mov eax, edi . mov edx, 3 . sub ecx, 4 . jb var . and eax, 3 . add ecx, eax . jmp dword [eax*4 + var] . jmp dword [ecx*4 + case.switch.var] . nop . ││ . jmp dword [ecx*4 + var] . nop . inc cx . add byte [eax - var], dl . inc cx . add byte [ebx], ah . ror dword [edx - var], 1 . inc esi . add dword [eax + var], ecx . add al, cl . jmp var . add esi, 3 . add edi, 3
mov edi, edi . push ebp . mov ebp, esp . cmp dword [var], 1 . jne var . call var . push dword [var] . mov ecx, dword [var] . mov edx, dword [var] . call var . pop ecx . pop ebp . ret var . push dword [var] . call var . pop ecx . test eax, eax . je var . call eax . push var . call var . push 1 . push 0 . call var . add esp, var . jmp var . push var . push var . call var . mov esi, dword [ebp + 8] . test esi, esi . je var . cmp dword [var], 3 . jne var . push 4 . call var . pop ecx . and dword [ebp - 4], 0 . push esi . call var . pop ecx . mov dword [ebp - var], eax . test eax, eax . je var . push esi . push eax . call var . pop ecx . pop ecx . mov dword [ebp - 4], var . call var . cmp dword [ebp - var], 0 . jne var . push dword [ebp + 8] . jmp var . push 4 . call var . pop ecx . ret . push esi . push 0 . push dword [var] . call dword [sym.imp.KERNEL32.dll_HeapFree] . test eax, eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
nop . push var . pop eax . push var . pop edi . nop . nop . mov esi, var . nop . push dword [esi + edi] . xor dword [esp], eax . pop dword [esi + edi] . nop . nop . dec esi . sub esi, 3 . nop . nop . jne var . cld . jecxz var . das . adc al, var . jle var . adc al, var . das . sub byte [esi + edi*2 + var], ch . das . retf var . das . adc al, var . jl var . adc eax, var . out dx, al . das . nop . out var, al . das . and dh, var . das . lodsb al, byte [esi] . cli . jle var . xchg eax, esi . out var, al . das . and dh, var . das . je var . jle var . xchg eax, esi . out var, al . das . and dh, var . das . adc al, var . jle var . adc al, var . jle var . adc al, var . jle var . adc al, var . jle var . test dh, ch
mov dword [var], esi . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . lea esi, [esp] . push esp . add edx, edx . jmp var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov cx, word [esp + var] . mov word [esp + var], var . xor edx, edx . mov dword [esp + var], edx . mov dword [esp + var], var . mov esi, dword [esp + var] . mov dword [esp + var], var . mov di, word [esp + var] . add di, var . mov word [esp + var], di . mov word [esp + var], var . mov dword [esp + var], edx . mov dword [esp + var], var . mov dword [esp + var], edx . mov dword [esp + var], var . mov edx, dword [esp + var] . mov ebx, dword [esp + var] . mov word [esp + var], var . mov dword [esp + var], ebx . mov word [esp + var], cx . mov dword [esp + var], esi . mov dword [esp + var], edx . mov dword [esp + var], eax . jmp var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . or ecx, var . mov dword [esp + var], ecx . xor eax, var . mov ecx, dword [esp + var] . add ecx, var . mov dword [esp + var], ecx . mov ecx, dword [sym.imp.KERNEL32.dll_GetFileSizeEx] . call ecx . in al, dx . stosd dword es:[edi], eax . jge var . mov byte [ebx - 6], dl . jmp var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, var . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . mov edx, 1 . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . add byte [eax], al . mov al, 4 . add al, byte [eax] . invalid . invalid . invalid . call dword [ecx] . add byte [eax], al . add byte [ebx], dl . outsd dx, dword [esi] . add byte [esi], ah . je var . xor eax, dword [eax] . xor al, byte [eax] . and byte [eax], al . inc esp . add byte [edi], ch . ja var . outsb dx, byte [esi] . add byte [eax + eax + var], ch . add byte [ecx], ah . add byte fs:[ebp], ah . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, edi . dec ecx . dec edx . add edx, ecx . inc edx . push edx . push ebp . xor ecx, ecx . add ecx, 5 . mov eax, edi . dec ecx . sub esp, ecx . mov dword [esp], eax . mov eax, ebx . mov edx, esp . push ebp . xor ecx, ecx . add ecx, var . push ebp . mov ebp, esp . mov ecx, dword [var] . je var . sub edx, 4 . pop ebp . add esp, var . call var . jmp var . mov dword [ebp - 4], eax . invalid . cld . and dword [edi], ebx . xor bl, byte [var] . pop ebp . sbb al, var . lahf . add al, var . push var . mov ecx, var . push bp . add al, var . cmp ch, byte [edi - var] . mov dl, var . add dh, byte [edi + ecx*4] . fstp xword [esi - var] . xor dword [ecx], ebp . dec ebx . mov esi, var . fst dword ds:[esi + var] . push ebx . add byte [ebx + var], al . push var . sbb eax, dword [edx + ebx*8] . or eax, var . in al, dx . mov cl, var . pop esp . jmp var . bound edi, qword [eax - var] . mov cl, var . ret . sbb eax, var . xchg eax, ebp . sbb eax, var . loop var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
cmp dword [var], 1 . jne var . 8b0d47b04600 mov ecx, dword [var] . mov al, var . add byte [edx + var], bh . xchg dword [esp - var], esi . and dword [var], edx . jne var . mov dword [var], var . mov dword [var], eax . mov ecx, var . mov ebx, var . ret . nop . push var . mov dword [var], edx . mov dword [var], edi . xchg dword [var], eax . mov dword [var], var . mov al, 1 . ret . push ebp . mov ebp, esp . add esp, var . mov dword [var], eax . mov dword [var], var . test edi, edi . jne var . mov dword [var], eax . mov edx, dword [var] . mov ecx, dword [var] . mov ecx, ebx . mov edi, ebx . mov byte [var], 0 . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], edx . mov dword [var], edi . mov byte [var], var . mov dword [var], ecx . cmp dword [var], var . je var . mov dword [var], var . test edi, edi . jne var . mov dword [var], eax . mov edx, dword [var] . mov ecx, dword [var] . mov ecx, ebx . mov edi, ebx . mov eax, dword [var] . push eax . call var . test al, al . jne var . cmp byte [var], 0 . je var . mov byte [var], var . xchg dword [var], eax . mov dword [var], edi . mov esi, dword [var] . mov dword [var], edi . xchg dword [var], eax
call var . mov dword [var], ebx . push esp . sub dword [var], 8 . mov dword [var], edi . mov dword [var], esi . add dword [var], 8 . mov dword [var], eax . mov eax, dword [var] . add dword [var], 4 . jmp var . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [esp + var], eax . mov dword [esp + 8], ecx . mov dword [esp + 4], edx . mov dword [esp], esi . je var . mov eax, dword [esp] . mov ecx, dword [esp + var] . mov edx, dword [esp + var] . mov esi, dword [esp + 8] . mov bl, byte [esi + eax] . not ecx . not edx . mov dword [esp + var], edx . mov dword [esp + var], ecx . mov ecx, dword [esp + 4] . mov byte [ecx + eax], bl . mov dword [esp + var], var . add eax, 1 . mov edx, dword [esp + var] . cmp eax, edx . mov dword [esp], eax . jne var . mov eax, dword [esp + 4] . lea esp, [ebp - 8] . pop esi . pop ebx . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [ebp + 8] . xor ecx, ecx . mov edx, dword [esp + var] . mov esi, dword [esp + var] . cmp eax, 0 . mov dword [esp + var], eax . mov dword [esp + var], esi . mov dword [esp + 8], edx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, var . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var] . cmp eax, dword [edx + var] . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx - var], ah . xor bl, byte [edx + ebx*2 - var] . sub dword [eax - var], ecx . mov bl, var . dec edx . or eax, var . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx], al . xchg byte [eax - var], dl . add dword [esi + var], esp . outsd dx, dword [esi] . jb var . outsb dx, byte [esi] . je var . add byte [eax], al . add byte [eax], al . cmp al, var . dec ebx . add al, byte [eax] . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . or eax, var . imul esp, ecx, var . dec edi . scasd eax, dword es:[edi] . add esi, dword [ecx + edx*8] . add ah, byte [esi] . inc ebx . pop esp . scasd eax, dword es:[edi] . add edx, dword [edx + var] . inc ebp . test al, var . xor esp, esp . outsb dx, byte [esi] . mov ch, var . into . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
pushal . mov esi, var . lea edi, [esi - var] . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl
push ebp . mov ebp, esp . call var . add dword ds:[esp], var . jne var . je var . e9281458ff jmp var . pop eax . jmp eax . add cl, ch . call var . push 0 . call dword [sym.imp.KERNEL32.dll_ExitThread] . pop ebp . ret . push ebp . mov ebp, esp . mov eax, dword [dwSize] . push esi . push edi . push var . mov esi, ecx . xor edi, edi . push var . push eax . push edi . mov dword [esi + 8], edi . mov dword [esi + var], edi . mov dword [esi], eax . call dword [sym.imp.KERNEL32.dll_VirtualAlloc] . mov dword [esi + 4], edi . mov dword [esi + 8], eax . mov dword [esi + var], eax . mov eax, esi . pop edi . pop esi . pop ebp . ret 4 . push var . push 0 . push dword [ecx + 8] . call dword [sym.imp.KERNEL32.dll_VirtualFree] . ret . push ebp . mov ebp, esp . mov edx, ecx . push esi . cmp dword [edx + 8], 0 . je var . mov esi, dword [edx + 4] . mov ecx, dword [var] . add esi, ecx . cmp esi, dword [edx] . jae var . mov eax, dword [edx + var] . add ecx, eax . mov dword [edx + var], ecx . mov dword [edx + 4], esi . jmp var . xor eax, eax . pop esi . pop ebp . ret 4 . push ebp
push ebp . push esp . mov ecx, esi . push ecx . call var . test eax, eax . je var . mov edx, edi . mov eax, 8 . push edx . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . call esi . mov ecx, dword [sym.imp.USER32.dll_GetMenuCheckMarkDimensions] . mov dword [ebp - var], eax . call ecx . mov ecx, dword [sym.imp.USER32.dll_GetMenuDefaultItem] . push var . push var . push var . mov dword [ebp - var], eax . call ecx . mov dword [ebp - var], eax . call var . call var . mov ecx, dword [sym.imp.KERNEL32.dll_CreateMutexW]
sub esp, var . push ebx . push ebp . push esi . push edi . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor ebx, ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov esi, var . mov edi, var . push esi . push edi . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_GetTempPathA] . call var . mov ebp, dword [sym.imp.KERNEL32.dll_lstrcatA] . test eax, eax . jne var . push var . push esi . call dword [sym.imp.KERNEL32.dll_GetWindowsDirectoryA] . push str.Temp . push esi . call ebp . call var . test eax, eax . je var . mov esi, var . push esi . call dword [sym.imp.KERNEL32.dll_DeleteFileA] . push str.NSIS_Error . push esi . call sub.KERNEL32.dll_lstrcpyA . push edi . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov esi, var . push eax . push esi . call dword [sym.imp.KERNEL32.dll_lstrcpynA] . push 0 . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . jne var . mov byte [var], var . mov esi, var . push dword [var] . push esi . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov edi, eax . mov dword [var], edi . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
mov eax, dword [var] . call var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, section.p0rWRzt . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [esp + var] . mov ecx, eax . and ecx, var . mov dword [esp + var], ecx . mov ecx, eax . add ecx, var . mov dword [esp + var], ecx . mov dword [esp + var], var . mov dword [esp + var], var . mov ecx, var . mov edx, dword [esp + var] . mov esi, var . sub esi, edx . mov edx, dword [esp + var] . mov edi, dword [esp + var] . mov ebx, edi . shld ebx, edx, 1 . mov dword [esp + var], eax . mov eax, edi . shr eax, var . mov dword [esp + var], eax . mov dword [esp + var], ebx . mov dword [esp + var], esi . cmp ecx, var . mov dword [esp + var], edi . mov dword [esp + var], edx . jbe var . jmp var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . or ecx, ecx . mov dword [esp + var], ecx . cmp eax, var . jb var . jmp var . mov eax, dword [sym.imp.RPCRT4.dll_RpcServerUseProtseqW]
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . nop . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov byte [eax + var], 0 . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . xor ecx, ecx . cmp eax, dword [ecx*8 + var] . je var . inc ecx . cmp ecx, var . jb var . lea ecx, [eax - var] . cmp ecx, var . ja var . push var . pop eax . pop ebp . ret . mov eax, dword [ecx*8 + var] . pop ebp . ret . add eax, var . push var . pop ecx . cmp ecx, eax . sbb eax, eax . and eax, ecx . add eax, 8 . pop ebp . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, 8 . ret . call var . test eax, eax . jne var . mov eax, var . ret . add eax, var . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . call var . mov ecx, dword [var] . push ecx . mov dword [eax], ecx . call var . pop ecx . mov esi, eax . call var . mov dword [eax], esi . pop esi . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . mov ecx, var . push 0 . push 0 . dec ecx . jne var . push ecx . push ebx . push esi . push edi . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . call var . call var . mov eax, dword [var] . mov byte [eax], 0 . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . mov edx, 1 . mov eax, var . call var . call var . xor eax, eax . pop edx . pop ecx . pop ecx . mov dword fs:[eax], edx . jmp var . jmp var . lea edx, [ebp - var] . xor eax, eax . call var . mov eax, dword [ebp - var] . push eax . call sub.kernel32.dll_GetLastError_1 . mov edx, eax . pop eax . call var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax]
push ebp . push esp . mov eax, ebp . add eax, var . xor ecx, ecx . mov edx, ebx . mov dword [var], edx . or eax, edx . add ecx, 4 . cmp eax, 0 . je var . pop edx . add edx, ecx . pop dword [var] . mov dword [var], edx . cmp ecx, 0 . jne var . test eax, eax . je var . mov eax, var . add esp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov dword [var], var . mov eax, dword [var] . add eax, var . mov dword [var], eax . call var . mov ecx, dword [var] . xor ecx, var . mov dword [var], 1 . cmp eax, ecx . je var . jmp var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . add esp, var . pop ebp . ret . cmp dword [var], var . jae var . jmp var . int
mov eax, dword [var] . test eax, eax . test edx, eax . mov eax, edx . lea edx, [var] . cmp ecx, 5 . jmp loc.00401b2a . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov byte [var], var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, eax . and edx, var . xor esi, esi . mov dword [var], esi . mov dword [var], edx . mov word [var], var . mov bl, byte [var] . mov dword [var], var . mov bh, bl . xor bh, var . mov byte [var], bh . mov word [var], var . mov edx, dword [var] . mov edi, edx . add edi, var . mov dword [var], edi . mov dword [var], esi . mov dword [var], var . mov dword [var], var . mov edi, dword [var] . mov dword [var], eax . mov eax, dword [var] . sub eax, var . sbb edi, esi . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edi . mov byte [var], bl . mov dword [var], edx . jb var . jmp var . call var . mov ecx, dword [var] . and ecx, var . mov dword [var], ecx . mov dword [var], 0 . cmp eax, 0 . je var . jmp var . xor eax, eax . mov dword [var], eax . mov dword [var], var . mov dword [var], eax . call var . mov byte [var], var . movzx ecx, word [var]
push ebp . mov ebp, esp . add esp, var . push eax . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . mov eax, var . call var . mov eax, dword [var] . mov byte [eax], 1 . push var . call sub.KERNEL32.DLL_SetErrorMode . push var . call sub.KERNEL32.DLL_Sleep . mov eax, 1 . call var . mov edx, eax . lea eax, [var] . call var . mov eax, dword [var] . mov edx, dword [var] . call var . jne var . push 0 . push 0 . push 0 . xor eax, eax . call var . push eax . push var . push 0 . call sub.shell32.dll_ShellExecuteW_1 . push 0 . call sub.KERNEL32.DLL_ExitProcess . push var . push 0 . push 0 . call var . mov edi, eax . call sub.KERNEL32.DLL_GetLastError . cmp eax, var . jne var . push var . call sub.KERNEL32.DLL_Sleep . push edi . call sub.KERNEL32.DLL_CloseHandle . mov eax, var . mov edx, var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . push 0 . push dword [var] . push dword [var] . push dword [var] . push dword [var] . call var . add esp, var . ret . mov eax, dword [var] . mov cx, word [eax] . inc eax . inc eax . test cx, cx . jne var . sub eax, dword [var] . sar eax, 1 . dec eax . ret . int . int . int . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . add byte [eax], 0 . add byte [eax], al . add byte [eax], al . nop . shl dword [ebp - var], cl . dec ebp . mov ds, word [ebx - var] . cmp cl, dl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . add byte [esi], al . push eax . add dword [ecx], var . imul ebp, dword fs:[esi + var], var . push var . add dl, byte [eax + var] . outsd dx, dword [esi] . push var . 63742049 arpl word [eax + var], si . dec ecx . outsb dx, byte [esi] . and byte [ecx + var], cl . and byte [var], ch . and byte [edi + var], cl . push var . arpl word [eax + var], si . jb var . outsb dx, byte gs:[esi] . je var . and byte fs:[eax + var], dl . outsd dx, dword [esi] . jb var . insd dword es:[edi], dx . insd dword es:[edi], dx . imul ebp, dword [esi + var], var . inc esp . push esp . inc ebp . push edx . dec ebp . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . push ds . jo var . loope var . insd dword es:[edi], dx . jp var
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ecx . push ebx . xor eax, eax . lea edx, [var] . add edx, var . mov dword [edx], ebp . lea edx, [var] . mov dword [edx], esi . mov esi, ecx . mov ecx, esp . add ecx, 8 . lea edx, [var] . mov dword [edx], ecx . lea edx, [var] . mov dword [edx], edi . lea edx, [var] . pop ecx . add edx, var . mov dword [edx], ecx . pop ecx . lea eax, [var] . add eax, var . jmp eax . xor eax, eax . ret . mov dword [ebp - 4], eax . int . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . xor esi, esi . mov dword [var], var . cmp ecx, 0 . sete bl . cmp edx, 0 . sete bh . or bh, bl . test bh, 1 . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], esi . jne var . jmp var . mov eax, dword [var] . add eax, 1 . cmp eax, var . mov dword [var], eax . je var . jmp var . mov eax, dword [var] . mov ecx, var . mov dword [var], eax . mul ecx . shr edx, 4 . imul eax, edx, var . neg eax . mov ecx, dword [var]
call var . mov dword [var], ebx . push esp . sub dword [var], 8 . mov dword [var], edi . mov dword [var], esi . add dword [var], 8 . mov dword [var], eax . mov eax, dword [var] . add dword [var], 4 . mov dword [var], esi . mov dword [var], edi . mov dword [var], esi . mov dword [var], edi . mov dword [var], esi . mov dword [var], edi . mov eax, dword [var] . jmp var . jle var . dec edx . out var, al . dec esp . mov dword [var], eax . sbb bh, bl . mov al, byte [var] . push ebx . sbb eax, var . retf . push ebx . dec edx . push var . inc ebx . xchg eax, edx . cdq . out dx, al . cmc . mov edx, var . cmpsd dword [esi], dword ptr es:[edi] . outsd dx, dword [esi] . jno var . dec ebp . xchg eax, edi . xor al, var . jns var . shl dword [edx + var], cl . cmp byte [esi + var], var . sahf . jecxz var . aaa . jns var . xchg eax, edi . mov byte [var], al . dec ebp . aad var . sub ah, byte [edx] . push ss . and edi, esi . cmp byte [esi], var . sub ah, var . add dword [esi + var], ecx . sbb ah, byte [var] . lcall var:var . dec edx . out var, al
sub esp, var . push ebx . push ebp . push esi . push edi . xor ebx, ebx . push var . mov dword [psfi], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.uxtheme . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], bl . jne var . push var . call var . push var . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push ebx . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . push eax . mov ebp, var . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . aad var . inc ecx . daa . ret . cmp al, var . xor byte [ebp + edx*8 + var], var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push var . insb byte es:[edi], dx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add al, byte [eax] . aam var . inc eax . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + var], cl . ror byte [eax], 1 . add byte [eax], al . add byte [eax], al . test al, var . insb byte es:[edi], dx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], ah . inc eax . add byte [esi], al . add byte [eax], al . add byte [ebp + ebp + var], ah . add byte [eax], al . or byte [ecx], ah
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . dec eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], bl . sbb dword [eax], var . jbe var . push ebp . inc eax . mov dl, bh . rcl dword [edx + var], 1 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . jo var . xor dword [var], ecx . imul esp, dword [ebp + var], var . 696b6b657273. imul ebp, dword [ebx + var], var . add byte [edx], cl . push ebx . insb byte es:[edi], dx . jo var . add byte [eax], al . add byte [eax], al . ffcc dec esp . int . xor dword [eax], eax . push es . mov edx, ds . push ds . mov word [esi], cs . xchg eax, edx . add byte [ebx - var], var . or al, var . and edx, dword [edx - var] . lodsb al, byte fs:[esi] . into . ret . pop esp . dec eax . mov al, var . out dx, eax . sbb eax, var . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041daea . ret . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . push esi . mov esi, ecx . lea eax, [esi + 4] . mov dword [esi], vtable.std::exception.0 . push eax . call var . test byte [ebp + 8], 1 . pop ecx . je var . push var . push esi . call var . pop ecx . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var]
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
call var . jmp var . push ebp . mov ebp, esp . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push dword [ExceptionInfo] . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . pop ebp . ret . ├ 251: loc.0040ae98 (int2_t var, int2_t var) . push ebp . mov ebp, esp . sub esp, var . push var . call sub.KERNEL32.dll_IsProcessorFeaturePresent . test eax, eax . je var . push 2 . pop ecx . int var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov dword [var], 1 . push 4 . pop eax . imul eax, eax, 0 . mov dword [eax + var], 2 . push 4 . pop eax . imul eax, eax, 0 . mov ecx, dword [var] . mov dword [ebp + eax - 8], ecx . push 4 . pop eax . shl eax, 0 . mov ecx, dword [section..data]
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov eax, dword [var] . mov eax, dword [eax] . mov dl, 1 . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . sub esp, var . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . push var . push section..data . push var . push var . push var . call var . add esp, var . push var . push var . push var . push var . push var . call var . add esp, var . push var . call var . add esp, 4 . push var . push 0 . push var . call var . add esp, var . call var . call var . push eax . call var . add esp, 4 . call var . mov dword [var], eax . lea eax, [var] . push eax . lea ecx, [var] . push ecx . lea edx, [var] . push edx . call var . add esp, var . test eax, eax . je var . push var . call var . add esp, 4 . mov dword [var], eax . mov eax, dword [var] . push eax . push var . call var . add esp, 8 . push 2 . push var . push var . push var . call var . add esp, var . mov dword [var], eax . mov ecx, dword [var] . push ecx . call var
mov dword [var], eax . mov dword [var], eax . call var . cmp ecx, 2 . mov dword [var], eax . je var . call var . call var . cmp esp, var . xor eax, eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . push edi . push esi . push ebx . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov esi, var . mov dword [esp + var], var . mov dword [esp + var], var . mov edi, dword [esp + var] . movsd xmm0, qword [esp + var] . movsd qword [esp + var], xmm0 . sub esi, edi . mov dword [esp + var], 0 . cmp eax, esi . mov dword [esp + 8], eax . mov dword [esp + 4], ecx . mov dword [esp], edx . je var . mov eax, dword [esp + var] . mov dword [esp + var], eax . mov dword [esp + var], 0 . mov dword [esp + var], var . cmp dword [esp + var], var . jne var . mov eax, dword [esp] . lea esp, [ebp - var] . pop ebx . pop esi . pop edi . pop ebp . ret . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . mov edx, dword [esp + 4] . mov bl, byte [edx + eax] . mov eax, dword [esp] . mov byte [eax + ecx], bl . mov ecx, dword [esp + var] . add ecx, 1 . mov dword [esp + var], ecx . mov esi, dword [esp + 8] . cmp ecx, esi . je var . jmp var . push ebp
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
call var . jmp var . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], edi . mov dword [var], esi . mov esi, dword [var] . mov edi, dword [var] . mov ecx, dword [var] . shr ecx, 7 . jmp var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmm1, xmmword [esi + var] . movdqa xmm2, xmmword [esi + var] . movdqa xmm3, xmmword [esi + var] . movdqa xmmword [edi], xmm0 . movdqa xmmword [edi + var], xmm1 . movdqa xmmword [edi + var], xmm2 . movdqa xmmword [edi + var], xmm3 . movdqa xmm4, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . movdqa xmm6, xmmword [esi + var] . movdqa xmm7, xmmword [esi + var] . movdqa xmmword [edi + var], xmm4 . movdqa xmmword [edi + var], xmm5 . movdqa xmmword [edi + var], xmm6 . movdqa xmmword [edi + var], xmm7 . lea esi, [esi + var] . lea edi, [edi + var] . dec ecx . jne var . mov esi, dword [var] . mov edi, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov dword [var], edi . mov dword [var], esi . mov dword [var], ebx . mov ebx, dword [var] . mov eax, ebx . cdq . mov ecx, eax . mov eax, dword [var] . xor ecx, edx . sub ecx, edx . and ecx, var . xor ecx, edx . sub ecx, edx . cdq . mov edi, eax . xor edi, edx . sub edi, edx . and edi, var . xor edi, edx . sub edi, edx . mov edx, ecx . or edx, edi . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edi + var], bl . pop es . mov edi, var . xchg eax, ebx . sbb ah, byte [eax - var] . xor eax, dword [eax] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], cl . push eax . dec edi . push eax . dec eax . push edx . inc ebp . dec esi . dec edi . push ebx . dec ecx . push ebx . aaa . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add eax, dword [eax] . je var . inc eax . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax + var], bl . inc eax . add al, al . or byte [eax], 0 . 0000 add byte [eax], al . add byte [eax], al . mov cl, cl . xchg eax, edi . add byte [eax], al
pushal . call var . pop ebp . push eax . push ecx . jmp var . b9eb0fb8eb mov ecx, var . jmp var . b8eb07b9eb mov eax, var . jmp var . nop . jmp var . std . jmp var . bnd jmp var . jmp var . bnd jmp var . std . jmp var . jmp var . cld . e959585051 jmp var . pop ecx . pop eax . push eax . push ecx . jmp var . b9eb0fb8eb mov ecx, var . jmp var . b8eb07b9eb mov eax, var . jmp var . nop . jmp var . std . jmp var . bnd jmp var . jmp var . bnd jmp var . std . jmp var . jmp var . cld . e959585051 jmp var . pop ecx . pop eax . push eax . push ecx . jmp var . b9eb0fb8eb mov ecx, var . jmp var . b8eb07b9eb mov eax, var . jmp var . nop . jmp var . std . jmp var . bnd jmp var . jmp var . bnd jmp var . std . jmp var . jmp var . cld . e959586033 jmp var
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
push ebp . mov ebp, esp . call var . add dword ds:[esp], var . jne var . je var . e9281458ff jmp var . pop eax . jmp eax . add cl, ch . call var . push 0 . call dword [sym.imp.KERNEL32.dll_ExitThread] . pop ebp . ret . push ebp . mov ebp, esp . mov eax, dword [dwSize] . push esi . push edi . push var . mov esi, ecx . xor edi, edi . push var . push eax . push edi . mov dword [esi + 8], edi . mov dword [esi + var], edi . mov dword [esi], eax . call dword [sym.imp.KERNEL32.dll_VirtualAlloc] . mov dword [esi + 4], edi . mov dword [esi + 8], eax . mov dword [esi + var], eax . mov eax, esi . pop edi . pop esi . pop ebp . ret 4 . push var . push 0 . push dword [ecx + 8] . call dword [sym.imp.KERNEL32.dll_VirtualFree] . ret . push ebp . mov ebp, esp . mov edx, ecx . push esi . cmp dword [edx + 8], 0 . je var . mov esi, dword [edx + 4] . mov ecx, dword [var] . add esi, ecx . cmp esi, dword [edx] . jae var . mov eax, dword [edx + var] . add ecx, eax . mov dword [edx + var], ecx . mov dword [edx + 4], esi . jmp var . xor eax, eax . pop esi . pop ebp . ret 4 . ret
pushal . call var . jmp var . push ebp . ret . call var . jmp var . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [ebp + var], 0 . mov dword [ebp + var], ebx . jne var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . mov edi, eax . lea ebx, [ebp + var] . push ebx . push eax . call dword [ebp + var] . mov dword [ebp + var], eax . lea ebx, [ebp + var] . push ebx . push edi . call dword [ebp + var] . mov dword [ebp + var], eax . lea eax, [ebp + var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[ebx + var], cl . add byte [ebx], cl . invalid . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4] . add eax, var . push 4 . push var . push eax . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . push esi
pushal . call var . jae var . add dword [eax], eax . jmp var . xor ecx, ecx . pop esi . xchg dword [esi], ecx . jecxz var . sub esi, ecx . mov ebx, esi . lodsd eax, dword [esi] . sub ebx, eax . lodsd eax, dword [esi] . add eax, ebx . push eax . xchg eax, edi . lodsd eax, dword [esi] . xchg eax, ecx . rep movsd dword es:[edi], dword ptr [esi] . pop esi . lodsd eax, dword [esi] . push esi . xchg eax, ecx . add dword [esi], ebx . lodsd eax, dword [esi] . loop var . lodsd eax, dword [esi] . lea ebp, [esi + var] . add dword [ebp], ebx . lea edi, [ebp + var] . mov ch, var . rep stosd dword es:[edi], eax . pop esi . lodsd eax, dword [esi] . push ebx . push eax . push ecx . xchg eax, edi . pop eax . lea edx, [ebp + eax*4 + var] . call dword [esi] . jb var . sub al, 3 . jae var . mov al, 0 . cmp al, 7 . jb var . sub al, 3 . push eax . movzx ebx, byte [edi - 1] . shl ebx, 3 . mov bl, 0 . lea ebx, [ebx + ebx*2] . lea ebx, [ebp + ebx*4 + var] . mov al, 1 . jecxz var . mov edx, edi . sub edx, dword [ebp + var] . mov ch, byte [edx] . xor edx, edx . test cl, ch . setne dh . push edx
xor ecx, ecx . add ecx, var . mov eax, var . or eax, ecx . sub eax, var . and eax, ecx . lea edx, [var] . mov dword [edx], ebx . lea ecx, [var] . mov edx, edi . mov dword [ecx - var], edx . add esi, var . lea edx, [var] . mov eax, esp . add edx, var . lea ecx, [var] . mov dword [edx], eax . mov eax, esi . lea edx, [var] . sub eax, var . sub edx, var . mov dword [var], eax . mov esi, eax . mov dword [edx], ebp . jmp ecx . mov dword [ebp - 4], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . test byte [eax - var], ch . imul eax, dword [ecx - var], var . and cl, byte [ecx - var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . or eax, var . and byte [eax + var], dl . insb byte es:[edi], dx . popal . aaa . add byte [eax + var], ch . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . pop es . sahf . int var . jle var . pushal . dec esp . xor byte [edi + var], var . or dword [varh], ebp . add dl, al . inc edx . mov dl, var . cli . xor eax, var . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
xchg eax, ecx . inc edx . xchg eax, ecx . nop . cdq . dec edx . cmc . inc eax . cdq . xchg eax, ecx . aas . cwde . xchg eax, ecx . dec ecx . xchg eax, edx . dec ebx . dec ebx . inc ecx . aaa . lahf . aaa . xchg eax, ebx . aas . daa . nop . xchg eax, edx . dec ebx . cld . lahf . cdq . clc . cmc . daa . dec ebx . cmc . inc ecx . inc ebx . dec ecx . stc . aaa . inc ebx . salc . clc . cdq . cdq . cdq . inc eax . cdq . inc ebx . salc . das . nop . cld . inc eax . dec edx . dec eax . xchg eax, ebx . aaa . xchg eax, ebx . aas . nop . salc . cwde . lahf
call sub.kernel32.dll_GetCommandLineA . mov dword [var], eax . push 0 . call sub.kernel32.dll_GetModuleHandleA . mov dword [var], eax . call sub.kernel32.dll_GetProcessHeap . mov dword [var], eax . push var . push dword [var] . push 0 . push dword [var] . call var . push 0 . call sub.kernel32.dll_ExitProcess . int . jmp dword [sym.imp.shlwapi.dll_PathFindFileNameA] . jmp dword [sym.imp.kernel32.dll_CloseHandle] . jmp dword [sym.imp.kernel32.dll_CreateFileA] . jmp dword [sym.imp.kernel32.dll_ExitProcess] . jmp dword [sym.imp.kernel32.dll_FindResourceA] . jmp dword [sym.imp.kernel32.dll_FreeResource] . jmp dword [sym.imp.kernel32.dll_GetCommandLineA] . jmp dword [sym.imp.kernel32.dll_GetEnvironmentVariableA] . jmp dword [sym.imp.kernel32.dll_GetFileSize] . jmp dword [sym.imp.kernel32.dll_GetModuleFileNameA] . jmp dword [sym.imp.kernel32.dll_GetModuleHandleA] . jmp dword [sym.imp.kernel32.dll_GetProcAddress] . jmp dword [sym.imp.kernel32.dll_GetProcessHeap] . jmp dword [sym.imp.kernel32.dll_GetSystemDirectoryA] . jmp dword [sym.imp.kernel32.dll_GetTempPathA] . jmp dword [sym.imp.kernel32.dll_GetWindowsDirectoryA] . jmp dword [sym.imp.kernel32.dll_GlobalAlloc] . jmp dword [sym.imp.kernel32.dll_GlobalFree] . jmp dword [sym.imp.kernel32.dll_HeapAlloc] . jmp dword [sym.imp.kernel32.dll_HeapFree] . jmp dword [sym.imp.kernel32.dll_LoadLibraryA] . jmp dword [sym.imp.kernel32.dll_LoadResource] . jmp dword [sym.imp.kernel32.dll_LockResource] . jmp dword [sym.imp.kernel32.dll_RtlMoveMemory] . jmp dword [sym.imp.kernel32.dll_SetFileAttributesA] . jmp dword [sym.imp.kernel32.dll_SizeofResource] . jmp dword [sym.imp.kernel32.dll_WriteFile] . jmp dword [sym.imp.kernel32.dll_lstrcatA] . jmp dword [sym.imp.kernel32.dll_lstrcpyA] . jmp dword [sym.imp.kernel32.dll_lstrcpynA] . jmp dword [sym.imp.kernel32.dll_lstrlenA] . jmp dword [sym.imp.user32.dll_CreateWindowExA] . jmp dword [sym.imp.user32.dll_DefWindowProcA] . jmp dword [sym.imp.user32.dll_DispatchMessageA] . jmp dword [sym.imp.user32.dll_GetMessageA] . jmp dword [sym.imp.user32.dll_LoadCursorA] . jmp dword [sym.imp.user32.dll_LoadIconA] . jmp dword [sym.imp.user32.dll_MessageBoxA] . jmp dword [sym.imp.user32.dll_PostQuitMessage] . jmp dword [sym.imp.user32.dll_RegisterClassExA] . jmp dword [sym.imp.user32.dll_SendMessageA] . jmp dword [sym.imp.user32.dll_ShowWindow] . jmp dword [sym.imp.user32.dll_TranslateMessage] . jmp dword [sym.imp.user32.dll_UpdateWindow] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
push ebp . lea edx, [var] . mov dword [edx + var], ebx . pop eax . push esp . push eax . push esi . mov ecx, edi . lea edx, [var] . mov dword [edx - var], ecx . lea ecx, section..text2 . call ecx . mov dword [var], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . add esi, 2 . cmp word [esi], bx . je var . cmp word [esi], var . jne var . push var . add esi, 2 . pop ebx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push 0 . push 0 . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . push ecx . push var . push ecx . call var . push ebp . call var . push ebp . push edx . push edx . call var . push var . push var . push ebp . call var . push 2 . push var . push var . push var . call var . push 0 . push esi . call var . push var . push var . push 0 . call var . push ebp . push 2 . push ebp . call var . push var . call var . push dword [edx] . xchg dword [esp], ebp . add esp, 4 . push var . push edx . push edx . push 2 . call var . call var . push edi . call var . push edi . call var . push ebx . call var . push var . cmp edx, edi . jae var . ret . pop eax . call var . add byte [eax], al . add byte [eax], al . add byte [eax], al
xor ecx, ecx . sub ecx, var . or eax, ecx . sub eax, var . lea edx, [var] . mov dword [edx], ebx . lea ecx, [var] . mov edx, edi . mov dword [ecx - var], edx . add esi, var . lea edx, [var] . mov eax, esp . add edx, var . lea ecx, [var] . mov dword [edx], eax . mov eax, esi . lea edx, [var] . sub eax, var . sub edx, var . mov dword [var], eax . mov esi, eax . mov dword [edx], ebp . jmp ecx . mov dword [ebp - 4], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . add esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . call var . test eax, eax . jne var . push var . call var . add esp, 4 . mov dword [var], 0 . call var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . test eax, eax . je var . mov eax, dword [var] . test eax, eax . jne var . push varffffffff . call var . add esp, 4 . call var . call var . call var . mov esi, dword [var] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, var . je var . test al, al . je var . and eax, var . push eax . call var . add esp, 4
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . call var . jmp var . push ebp . ret . call var . eb5d jmp var . pop ebp . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [var], 0 . mov dword [var], ebx . jne var . lea eax, [var] . push eax . call dword [var] . mov dword [var], eax . mov esi, eax . lea edi, [var] . push edi . push esi . call dword [var] . stosd dword es:[edi], eax . mov al, 0 . scasb al, byte es:[edi] . jne var . cmp byte [edi], al . jne var . lea eax, [var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[esi + var], dl . jb var . jne var . insb byte es:[edi], dx . push eax . jb var . je var . arpl word [eax + eax], si . mov ebx, dword [ebp + var] . or ebx, ebx . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4]
jmp var . ret var . call var . int . push ebp . mov ebp, esp . push ecx . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . add eax, dword [var] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . push ecx . push ecx . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 1 . mov eax, dword [var] . inc eax . mov dword [var], eax . cmp dword [var], var . jb var . mov eax, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [dwSize], var . push var . push var . push dword [dwSize] . push 0 . call dword [sym.imp.KERNEL32.dll_VirtualAlloc] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov eax, dword [dwSize] . mov dword [var], eax . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var . lea eax, [var] . mov dword [var], eax . mov byte [var], var . mov byte [var], var . mov byte [var], var . mov byte [var], var
push ebp . mov ebp, esp . sub esp, var . push edi . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . jmp var . mov eax, dword [var] . add eax, 1 . mov dword [var], eax . cmp dword [var], var . jae var . push var . call dword [sym.imp.USER32.dll_CharLowerW] . jmp var . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_GetAsyncKeyState] . call dword [sym.imp.GDI32.dll_GdiFlush] . mov edx, dword [var] . push edx . call dword [sym.imp.GDI32.dll_WidenPath] . call dword [sym.imp.USER32.dll_GetForegroundWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.GDI32.dll_GetTextCharset] . push str.loJCgnmKgZ . call dword [sym.imp.GDI32.dll_GetEnhMetaFileW] . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_GetThreadDesktop] . mov edx, dword [var] . push edx . call dword [sym.imp.USER32.dll_GetTopWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.GDI32.dll_GetStockObject] . mov ecx, dword [var] . push ecx . call dword [sym.imp.GDI32.dll_CreateCompatibleDC] . push str.LTBnjwOIbU . call dword [sym.imp.GDI32.dll_AddFontResourceW] . mov edx, dword [var] . push edx . call dword [sym.imp.GDI32.dll_GetTextAlign] . call dword [sym.imp.USER32.dll_GetKBCodePage] . mov eax, dword [var] . push eax . call dword [sym.imp.USER32.dll_GetKeyState] . call dword [sym.imp.USER32.dll_GetDesktopWindow] . call dword [sym.imp.USER32.dll_GetMessagePos] . movzx ecx, word [var] . push ecx . call dword [sym.imp.USER32.dll_IsCharUpperW] . mov edx, dword [var] . push edx . call dword [sym.imp.USER32.dll_GetTopWindow] . mov eax, dword [var] . push eax . call dword [sym.imp.USER32.dll_GetSystemMetrics] . mov ecx, dword [var] . push ecx . call dword [sym.imp.USER32.dll_CloseDesktop]
mov dword [var], esi . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . lea esi, [esp] . push esp . add edx, edx . jmp var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov cl, byte [esp + var] . mov dl, cl . xor dl, var . mov byte [esp + var], dl . xor esi, esi . mov dword [esp + var], esi . mov dword [esp + var], var . mov word [esp + var], var . mov byte [esp + var], 6 . mov dl, cl . xor dl, var . mov byte [esp + var], dl . mov dword [esp + var], var . mov word [esp + var], var . mov edi, dword [esp + var] . mov ebx, edi . add ebx, var . mov byte [esp + var], var . mov dword [esp + var], ebx . mov ebx, dword [esp + var] . mov edx, dword [esp + var] . mov dword [esp + var], esi . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], var . mov word [esp + var], var . mov word [esp + var], var . mov byte [esp + var], cl . mov cx, word [esp + var] . mov dword [esp + var], esi . mov dword [esp + var], var . mov byte [esp + var], var . mov word [esp + var], var . mov word [esp + var], var . mov word [esp + var], var . mov byte [esp + var], var . mov dword [esp + var], eax . mov al, byte [esp + var] . mov ah, var
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
push ebp . lea edx, [var] . mov dword [edx + var], ebx . mov ecx, edi . lea edx, [var] . mov dword [edx], ecx . pop eax . push esp . push eax . push esi . call var . mov dword [var], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov dword [var], esi . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . add edx, edx . jmp var . jmp var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov byte [esp + var], var . mov dword [esp + var], var . mov al, byte [esp + var] . mov cl, al . and cl, 1 . mov edx, dword [esp + var] . mov si, word [esp + var] . mov edi, edx . xor edi, var . mov byte [esp + var], cl . mov dword [esp + var], edi . mov edi, edx . xor edi, var . mov dword [esp + var], edi . mov dword [esp + var], var . mov dword [esp + var], var . mov cl, byte [esp + var] . mov edi, dword [esp + var] . mov ebx, dword [esp + var] . mov ah, var . sub ah, cl . mov byte [esp + var], ah . mov dword [esp + var], var . xor ecx, ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . mov dword [esp + var], ecx . mov dword [esp + var], var . mov byte [esp + var], var . mov byte [esp + var], var . mov ecx, edx . add ecx, var . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . xor ecx, var . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . mov dword [esp + var], ecx . mov ecx, dword [esp + var] . mov dword [esp + var], ecx . mov dword [esp + var], var . mov dword [esp + var], var
call var . jmp var . push ebp . mov ebp, esp . mov eax, dword [var] . and eax, var . push var . pop ecx . sub ecx, eax . mov eax, dword [var] . ror eax, cl . xor eax, dword [var] . pop ebp . ret . push ebp . mov ebp, esp . mov eax, dword [var] . push esi . mov ecx, dword [eax + var] . add ecx, eax . movzx eax, word [ecx + var] . lea edx, [ecx + var] . add edx, eax . movzx eax, word [ecx + 6] . imul esi, eax, var . add esi, edx . cmp edx, esi . je var . mov ecx, dword [var] . cmp ecx, dword [edx + var] . jb var . mov eax, dword [edx + 8] . add eax, dword [edx + var] . cmp ecx, eax . jb var . add edx, var . cmp edx, esi . jne var . xor eax, eax . pop esi . pop ebp . ret . mov eax, edx . jmp var . call var . test eax, eax . jne var . xor al, al . ret . mov eax, dword fs:[var] . push esi . mov esi, var . mov edx, dword [eax + 4] . jmp var . cmp edx, eax . je var . xor eax, eax . mov ecx, edx . lock cmpxchg dword [esi], ecx . test eax, eax . jne var . xor al, al . pop esi . ret
push ebp . push esp . mov eax, esi . push eax . add eax, 5 . call var . mov edx, edi . mov eax, 8 . push edx . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov dword [ebp - 8], var . mov esi, dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . call esi . mov dword [ebp - var], eax . call var . call var . mov ecx, dword [sym.imp.KERNEL32.dll_CreateFileW] . sub esp, 4 . mov dword [esp], ecx . mov dword [ebp - var], eax . call var . add esp, 4 . cmp eax, 0 . je var . mov eax, dword [sym.imp.KERNEL32.dll_PulseEvent] . push var
call var . jmp var . jmp dword [var] . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . and ecx, var . add eax, ecx . sbb ecx, ecx . or eax, ecx . pop ecx . jmp var . push ecx . lea ecx, [esp + 8] . sub ecx, eax
call var . push ebp . mov dword [var], eax . mov dword [ebp - 4], eax . xor ebp, eax . call var . sub dword [var], var . call var . ret . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, var . mov dword [ebp - var], var . mov ah, byte [edx + ecx] . mov edx, dword [ebp - var] . sub ah, al . cmp edi, edx . mov byte [ebp - var], ah . mov dword [ebp - var], ecx . mov dword [ebp - var], esi . jb var . mov eax, dword [sym.imp.KERNEL32.dll_GetCommandLineA] . call eax . mov dword [ebp - var], eax . add esp, var . pop esi . pop edi . pop ebp . ret . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ebp - var] . mov byte [eax + ecx], dl . add esp, var . pop esi . pop edi . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . lea eax, [ebp - 4] . mov ecx, dword [sym.imp.KERNEL32.dll_GetCommandLineA] . call ecx . cld . aas . sbb al, var . push ss . and al, var . xor esp, ebx . rol dword [ebx - var], var
pushal . mov esi, var . lea edi, [esi - var] . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
push ebp . mov ebp, esp . push ecx . and dword [var], 0 . lea eax, [var] . push esi . push edi . push eax . call var . push eax . call var . xor esi, esi . mov edi, eax . pop ecx . pop ecx . cmp dword [var], esi . jle var . push var . push dword [edi + esi*4] . call var . pop ecx . pop ecx . test eax, eax . je var . push var . call var . pop ecx . inc esi . cmp esi, dword [var] . jl var . push 0 . call var . push 0 . call var . pop ecx . pop edi . xor eax, eax . pop esi . mov esp, ebp . pop ebp . ret var . push ebp . mov ebp, esp . xor eax, eax . push eax . push eax . push var . push eax . call var . push dword [var] . call eax . pop ebp . ret . push ebp . mov ebp, esp . push esi . mov esi, dword [var] . test esi, esi . je var . push esi . call var . pop ecx . test eax, eax . je var
call var . jmp var . push edi . mov eax, esi . and eax, var . test eax, eax . jne var . mov edx, ecx . and ecx, var . shr edx, 7 . je var . jmp var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmm1, xmmword [esi + var] . movdqa xmm2, xmmword [esi + var] . movdqa xmm3, xmmword [esi + var] . movdqa xmmword [edi], xmm0 . movdqa xmmword [edi + var], xmm1 . movdqa xmmword [edi + var], xmm2 . movdqa xmmword [edi + var], xmm3 . movdqa xmm4, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . movdqa xmm6, xmmword [esi + var] . movdqa xmm7, xmmword [esi + var] . movdqa xmmword [edi + var], xmm4 . movdqa xmmword [edi + var], xmm5 . movdqa xmmword [edi + var], xmm6 . movdqa xmmword [edi + var], xmm7 . lea esi, [esi + var] . lea edi, [edi + var] . dec edx . jne var . test ecx, ecx . je var . mov edx, ecx . shr edx, 4 . test edx, edx . je var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmmword [edi], xmm0 . lea esi, [esi + var] . lea edi, [edi + var] . dec edx . jne var . and ecx, var . je var . mov eax, ecx . shr ecx, 2 . je var . mov edx, dword [esi] . mov dword [edi], edx . lea esi, [esi + 4] . lea edi, [edi + 4] . dec ecx . jne var . mov ecx, eax . and ecx, 3 . je var . mov al, byte [esi] . mov byte [edi], al . inc esi . inc edi
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . xor eax, eax . push eax . push eax . push eax . push eax . call var . ret . push esi . push edi . mov edi, dword [var] . mov esi, ecx . mov ecx, edi . mov dword [esi], edi . call var . mov dword [esi + 8], eax . mov dword [esi + var], edx . mov eax, dword [edi + var] . mov dword [esi + var], eax . pop edi . mov eax, esi . pop esi . ret 4 . mov eax, ecx . mov ecx, dword [eax] . mov edx, dword [eax + var] . cmp edx, dword [ecx + var] . jne var . push 0 . push dword [eax + var] . push dword [eax + 8] . call var . ret . push esi . mov esi, ecx . mov eax, dword [esi] . test eax, eax . je var . push eax . call dword [sym.imp.KERNEL32.dll_FreeLibrary] . and dword [esi], 0 . and dword [esi + 8], 0 . and dword [esi + var], 0 . pop esi . ret . push esi . mov esi, ecx . cmp byte [esi + 4], 0 . jne var . push str.Crypt32.dll . call dword [sym.imp.KERNEL32.dll_LoadLibraryW] . mov dword [esi], eax . test eax, eax . je var . push edi . mov edi, dword [sym.imp.KERNEL32.dll_GetProcAddress] . push str.CryptProtectMemory . push eax . call edi . push str.CryptUnprotectMemory . push dword [esi] . mov dword [esi + 8], eax . call edi . mov dword [esi + var], eax
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
pushal . mov esi, var . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 9 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dh, bh . xchg byte [eax + var], cl . xchg eax, ebp . inc eax . adc dword [var], ecx . adc byte [ecx - 1], ah . aas . fadd st(1) . dec ecx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [edi], bh . add eax, dword [ebx] . popal . outsb dx, byte [esi] . je var . jo var . popal . insb byte es:[edi], dx . xor al, byte [eax] . add byte [eax], ah . or byte [ecx], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or al, var . ljmp var . xchg byte [ebp + esi - var], cl . lodsb al, byte [esi] . out dx, eax . leave . enter var, var . aaa . jg var . add eax, dword [eax - var] . dec edi . movsd dword es:[edi], dword ptr [esi] . loope var . inc eax . sbb dword [edx], edi . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . push esi . mov esi, ecx . mov byte [esi + var], 0 . test eax, eax . jne var . call var . mov dword [esi + 8], eax . mov ecx, dword [eax + var] . mov dword [esi], ecx . mov ecx, dword [eax + var] . mov dword [esi + 4], ecx . mov ecx, dword [esi] . cmp ecx, dword [var] . je var . mov ecx, dword [var] . test dword [eax + var], ecx . jne var . call var . mov dword [esi], eax . mov eax, dword [esi + 4] . cmp eax, dword [var] . je var . mov eax, dword [esi + 8] . mov ecx, dword [var] . test dword [eax + var], ecx . jne var . call var . mov dword [esi + 4], eax . mov eax, dword [esi + 8] . test byte [eax + var], 2 . jne var . or dword [eax + var], 2 . mov byte [esi + var], 1 . jmp var . mov ecx, dword [eax] . mov dword [esi], ecx . mov eax, dword [eax + 4] . mov dword [esi + 4], eax . mov eax, esi . pop esi . pop ebp . ret 4 . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push ebx . push dword [var] . lea ecx, [var] . call var . mov ebx, dword [var] . test ebx, ebx . jne var . call var . mov dword [eax], var . call var . cmp byte [var], bl . je var
call var . jmp var . push var . push var . call var . and dword [var], 0 . mov esi, dword [var] . cmp esi, dword [var] . ja var . push 4 . call var . pop ecx . and dword [var], 0 . push esi . call var . pop ecx . mov dword [var], eax . mov dword [var], var . call var . mov eax, dword [var] . call var . ret . push 4 . call var . pop ecx . ret . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, dword [var] . cmp esi, var . ja var . push ebx . push edi . mov edi, dword [sym.imp.KERNEL32.dll_HeapAlloc] . cmp dword [var], 0 . jne var . call var . push var . call var . push var . call var . pop ecx . pop ecx . mov eax, dword [var] . cmp eax, 1 . jne var . test esi, esi . je var . mov eax, esi . jmp var . xor eax, eax . inc eax . push eax . jmp var . cmp eax, 3 . jne var . push esi . call var . pop ecx . test eax, eax . jne var . test esi, esi
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add cl, byte [var] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor dl, byte [ebx] . mov eax, eax
sub esp, var . push ebx . push esi . push edi . xor ebx, ebx . push var . mov dword [psfi], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . and eax, var . cmp ax, 6 . mov dword [var], eax . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.UXTHEME . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], bl . jne var . push var . call var . push 8 . call var . push 6 . mov dword [var], eax . call var . cmp eax, ebx . je var . push var . call eax . test eax, eax . je var . or byte [var], var . push ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add al, dh . sbb dword [var], ebp . sub eax, dword [ebx] . mov bl, var . movsd dword es:[edi], dword ptr [esi] . mov dl, 7 . stosb byte es:[edi], al . ror byte [ebx - var], cl . or al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], dh . outsw dx, word gs:[esi] . je var . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add esi, esi . stc . fiadd dword [ebx] . sbb eax, var . sbb al, var . fist word [edi - 4] . add byte [ebx + var], dh . xor al, 3 . inc eax . ljmp var:var . invalid . arpl word [eax - var], bp . fidivr dword [edx] . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, var . push eax . ret . mov eax, var . adc eax, var . add al, var . imul eax, dword [eax + 1], var . add al, var . or al, var . inc byte [ecx + var] . imul eax, dword [eax - var], var . jae var . imul ecx, dword [ebp + var], var . dec ecx . int . jne var . dec esp . add al, byte [eax] . dec ecx . inc esp . call var . push var . and al, var . jb var . movq mm1, qword [edi] . push eax . jae var . outsb dx, byte [esi] . outsb dx, byte [esi] . jb var . popal . add edi, 4 . lea esp, [ecx + var] . nop . outsd dx, dword [esi] . insb byte es:[edi], dx . inc byte [ebx + var] . dec ebp . dec esp . insb byte es:[edi], dx . dec ebp . int . popal . popal . add dword [ebx], esi . xor eax, dword [eax + var] . mov eax, ebp . push es . nop . mov dword [ebp - var], ecx . call dword [eax] . int . adc eax, var . dec esp . insb byte es:[edi], dx . insb byte es:[edi], dx . invalid . int . mov esi, dword [ebp + var] . rol al, 1 . call var . dec ebp . dec ebp . inc ebp
sub esp, var . mov dword [var], 1 . call var . add esp, var . jmp var . lea esi, [esi] . sub esp, var . mov dword [var], 0 . call var . add esp, var . jmp var . nop . nop . nop . nop . nop . nop . push ebp . mov ebp, esp . sub esp, var . cmp dword [var], 0 . jle var . cmp dword [var], var . jle var . mov eax, 0 . jmp var . mov dword [var], 0 . mov dword [var], 0 . mov dword [var], 0 . mov dword [esp], str.Advapi32.dll . mov eax, dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . call eax . sub esp, 4 . mov dword [var], str.CryptAcquireContextA . mov dword [esp], eax . mov eax, dword [sym.imp.KERNEL32.dll_GetProcAddress] . call eax . sub esp, 8 . mov dword [var], eax . mov dword [var], 0 . mov dword [var], 1 . mov dword [var], 0 . mov dword [var], 0 . lea eax, [var] . mov dword [esp], eax . mov eax, dword [var] . call eax . sub esp, var . test eax, eax . sete al . test al, al . je var . mov dword [var], 8 . mov dword [var], 1 . mov dword [var], 0 . mov dword [var], 0 . lea eax, [var] . mov dword [esp], eax . mov eax, dword [var] . call eax . sub esp, var . test eax, eax . sete al . test al, al
push var . call var . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dh, bl . nop . or ebx, esi . xchg byte [ebx], bl . mov cs, word [ebp + ebp*4 + var] . jg var . adc byte [edi - var], bh . adc al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + var], cl . insd dword es:[edi], dx . jb var . imul esp, dword fs:[bx + di + var], 0 . add byte [eax], al . add byte [eax], al . add byte [esi], al . add byte [eax], al . add byte [edi + var], ah . add byte [edi], al . add byte [eax], al . add byte [var], dl . add byte [eax], al . dec eax . and eax, var . add byte [eax], al . add byte [var], ah . add byte [eax], al . mov esp, var . add byte [eax], al . add byte [eax + var], bh . inc eax . add byte [edi], al . add byte [eax], al . add byte [eax], bh . and al, var . add byte [edi], al . add byte [eax], al . add ah, dh . and eax, dword [eax] . pop es . add byte [eax], al . add byte [eax + var], dh . add byte [eax], al . add byte [eax + var], ch . inc eax . add byte [edi], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call var . xor eax, eax . pop ebp . ret 4 . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . mov edi, edi . push ebp . mov ebp, esp . push edi . mov edi, var . push edi . call dword [sym.imp.KERNEL32.dll_Sleep] . push dword [lpModuleName] . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . add edi, var . cmp edi, var . ja var . test eax, eax . je var . pop edi . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . call var . push dword [var] . call var . push dword [var] . call var . push var . call eax . add esp, var . pop ebp . ret . mov edi, edi . push ebp . mov ebp, esp . push str.mscoree.dll . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . test eax, eax
mov dword [var], esi . mov dword [var], eax . call var . mov dword [var], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov ecx, dword [var] . mov edx, dword [var] . xor esi, esi . mov dword [var], var . mov edi, dword [var] . mov ebx, edi . xor ebx, var . mov dword [var], edi . cmp eax, ebx . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], edi . mov dword [var], esi . je var . mov eax, dword [var] . mov ecx, dword [var] . add ecx, var . mov dword [var], ecx . mov dword [var], var . mov ecx, dword [var] . mov dl, byte [ecx + eax] . mov esi, dword [var] . mov edi, dword [var] . mov dword [var], edi . mov dword [var], esi . mov esi, dword [var] . mov byte [esi + eax], dl . inc eax . mov dword [var], 0 . mov dword [var], 0 . mov edi, dword [var] . cmp eax, edi . mov dword [var], eax . jne var . mov dword [var], var . mov ecx, dword [var] . mov eax, dword [var] . shr eax, cl . mov dword [var], eax . mov eax, dword [var] . lea esp, [var] . pop esi . pop edi . pop ebx . pop ebp . ret . push ebp . mov ebp, esp . push esi . push ebx . push edi
push ebp . mov ebp, esp . add esp, var . mov eax, section.sect_0 . call var . lcall var . jmp var . xchg eax, edx . cmp byte [edi], ch . cmpsb byte [esi], byte ptr es:[edi] . cmp eax, var . inc eax . or bl, byte [edx] . pop ss . dec ecx . cmp bh, dl . iretd . arpl word [eax + edi*2], bx . les eax, [ecx + esi*8 + var] . pop edi . jbe var . and ch, ah . int var . xlatb . lodsd eax, dword [esi] . aad var . mov esi, var . test eax, var . cmp eax, ecx . shl dword [ebx + var], 1 . sbb esp, dword [ebx] . jne var . mul cl . xlatb . cmp byte [esi + var], al . int . adc eax, var . loop var . fidiv dword [edx - var] . push ebp . mov ss, esi . dec ebx . xchg eax, edi . out var, al . inc esp . mov dl, var . jnp var . push ss . or dword [ecx + var], esp . jno var . fistp word [edi - var] . nop . sbb cl, ah . loop var . sub eax, var . add al, var . wait . insd dword es:[edi], dx . sub ah, dl . js var . xchg dword [edx], ebp . inc esp . sub eax, var . sal dword [ebx], var
nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . nop . push ebp . mov ebp, esp . inc ecx . push edx . nop . pop edx . dec ecx . pop ebp . inc ecx . mov eax, var . jmp eax . nop . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx], bl . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
pushfd . pushal . call var . pop ebp . sub ebp, 7 . lea ecx, [ebp - var] . cmp byte [ecx], 1 . je var . mov byte [ecx], 1 . mov eax, ebp . sub eax, dword [ebp - var] . mov dword [ebp - var], eax . add dword [ebp - var], eax . lea esi, [ebp - var] . add dword [esi], eax . push ebp . push esi . push var . push var . 6800100000 push var . adc byte [eax], al . add byte [edx], ch . call dword [ebp - var] . test eax, eax . je var . mov dword [ebp - var], eax . call var . pop ebx . mov ecx, var . add ebx, ecx . push eax . push ebx . call var . pop esi . pop ebp . mov esi, dword [esi] . mov edi, ebp . add edi, dword [ebp - var] . mov ebx, edi . cmp dword [edi], 0 . jne var . add edi, 4 . mov ecx, 0 . jmp var . mov ecx, 1 . add edi, dword [ebx] . add ebx, 4 . cmp dword [ebx], 0 . je var . add dword [ebx], edx . mov esi, dword [ebx] . add edi, dword [ebx + 4] . push edi . push ecx . push ebx . push dword [ebp - var] . push dword [ebp - var] . mov edx, esi . mov ecx, edi . mov eax, dword [ebp - var] . add eax, var . call eax . pop ebx . pop ecx
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . cmp eax, 4 . je var . or eax, esp . or eax, 5 . cmp eax, 0 . mov dword [var], eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, byte [edx + ecx] . sub ah, al . mov byte [esi + ecx], ah . mov dword [esp + 4], 0 . mov dword [esp], 0 . lea esp, [ebp - 4] . pop esi . pop ebp . ret . push ebp . mov ebp, esp . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ecx, dword [sym.imp.ntdll.dll_RtlCaptureStackBackTrace] . call ecx . sub byte [edx], dh . xchg eax, esi . sal ecx, 1 . push esp . sti . stc . leave . ljmp var:var . clc . lcall var:var . nop . outsb dx, byte [esi] . dec esi . sbb al, var . jmp var . sbb eax, var . dec ecx . bound ebp, qword [ebx + edi*8] . jmp var . mov ah, var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . mov cl, byte [eax] . cmp cl, bl . je var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax
mov eax, ebp . shl eax, 1 . xor eax, ebx . and eax, var . add eax, 3 . mov dword [var], esp . cmp eax, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add esp, var . cmp eax, 2 . jb var . push ebx . push ecx . call var . mov dword [var], eax . add ebp, var . test eax, eax . cmp eax, var . jne var . mov ebx, ebp . xor eax, eax . nop . nop . nop . nop . ret . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov eax, dword [var] . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov ecx, dword [var] . add ecx, var . mov dword [var], ecx . mov dword [var], eax . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . jne var . jmp var . mov eax, var . sub eax, dword [var]
pushal . call var . and ebp, dword [esi] . add al, byte [eax] . jmp var . xor ecx, ecx . pop esi . xchg dword [esi], ecx . jecxz var . sub esi, ecx . mov ebx, esi . lodsd eax, dword [esi] . sub ebx, eax . lodsd eax, dword [esi] . add eax, ebx . push eax . xchg eax, edi . lodsd eax, dword [esi] . xchg eax, ecx . rep movsd dword es:[edi], dword ptr [esi] . pop esi . lodsd eax, dword [esi] . push esi . xchg eax, ecx . add dword [esi], ebx . lodsd eax, dword [esi] . loop var . lodsd eax, dword [esi] . lea ebp, [esi + var] . add dword [ebp], ebx . lea edi, [ebp + var] . mov ch, var . rep stosd dword es:[edi], eax . pop esi . lodsd eax, dword [esi] . push ebx . push eax . push ecx . xchg eax, edi . pop eax . lea edx, [ebp + eax*4 + var] . call dword [esi] . jb var . sub al, 3 . jae var . mov al, 0 . cmp al, 7 . jb var . sub al, 3 . push eax . movzx ebx, byte [edi - 1] . shl ebx, 3 . mov bl, 0 . lea ebx, [ebx + ebx*2] . lea ebx, [ebp + ebx*4 + var] . mov al, 1 . jecxz var . mov edx, edi . sub edx, dword [ebp + var] . mov ch, byte [edx] . xor edx, edx . test cl, ch . setne dh . push edx
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
push ebp . push esp . add ecx, var . add eax, ecx . and eax, var . cmp eax, 2 . je var . pop ecx . add ecx, 4 . pop dword [var] . mov dword [var], ecx . mov ecx, ebx . mov dword [var], ecx . call var . cmp ecx, ebp . je var . mov eax, ebx . sub eax, 6 . shl eax, 3 . push eax . xor eax, eax . mov ebp, ebx . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push eax . call var . mov ecx, 1 . cmp eax, 0 . mov dword [var], ecx . je var . mov eax, dword [var] . add esp, 4 . pop ebp . ret . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . jmp var . int . int . int . int . int . int . int . int . int
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . xor edx, edx . mov dl, ah . mov dword [var], edx . mov ecx, eax . and ecx, var . mov dword [var], ecx . shl ecx, 8 . add ecx, edx . mov dword [var], ecx . shr eax, var . mov dword [var], eax . push 1 . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . xor esi, esi . mov dword [var], esi . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], esi . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . call var . mov dword [var], eax . test byte [var], 1 . je var . movzx eax, word [var] . jmp var . push var . pop eax . push eax . push dword [var] . push esi
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . inc ecx . add ebx, ebx
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . push edi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . mov eax, dword [var] . call var . call var . cmp byte [var], 0 . je var . call var . xor eax, eax . call var . lea edx, [var] . xor eax, eax . call var . mov edx, dword [var] . mov eax, var . call var . push 2 . push 0 . push 1 . mov ecx, dword [var] . mov dl, 1 . mov eax, dword [var] . call var . mov dword [var], eax . xor edx, edx . push ebp . push var . push dword fs:[edx] . mov dword fs:[edx], esp . call var . mov dword [var], eax . mov eax, dword [var] . cmp dword [eax + var], 1 . jne var . mov eax, dword [var] . mov edx, var . call var . mov edx, dword [var]
push ecx . mov eax, esi . mov dword [var], eax . mov dword [var], edi . push ebp . push esp . push ebx . call var . dec ecx . mov dword [var], ecx . mov dword [var], eax . push ebp . mov ebp, esp . push ebx . sub esp, var . lea eax, [var] . mov ecx, var . lea edx, [ebp - var] . mov byte [ebp - 5], var . mov dword [ebp - var], var . mov bl, byte [ebp - 5] . xor bl, var . mov byte [ebp - var], bl . sub ecx, dword [ebp - var] . mov dword [esp], edx . mov dword [esp + 4], eax . mov dword [esp + 8], ecx . mov dword [ebp - var], edx . call var . mov bl, byte [ebp - var] . mov bh, byte [ebp - 5] . xor bh, var . cmp bl, bh . jne var . add esp, var . pop ebx . pop ebp . ret . call var . mov dword [esp], eax . mov eax, dword [ebp - var] . mov dword [esp + 4], eax . call var . mov dword [var], eax . jmp var . push ebp . mov ebp, esp . sub esp, var . mov eax, var . mov dword [ebp - 4], var . sub eax, dword [ebp - 4] . mov dword [ebp - 8], eax . mov eax, dword [ebp - 4] . mov ecx, dword [ebp - 8] . xor eax, var . cmp ecx, eax . ja var . mov eax, dword [ebp - 4] . add eax, var . mov ecx, dword [ebp - 4] . xor ecx, var . mov dword [ebp - var], eax . mov ecx, dword fs:[ecx] . mov eax, var
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041db27 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . jmp var . jmp dword [var] . int . int . int . int . int . int . int . int . int . int . int . int . push var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . fild dword [var] . call var . mov dword [var], eax . mov eax, dword [var] . add eax, var . cmp eax, dword [var] . jge var . mov eax, dword [var] . push eax . mov eax, dword [var] . push eax . mov eax, dword [var] . push eax . mov eax, dword [var] . push eax . mov eax, dword [var] . push eax . call sub.user32.dll_IsRectEmpty . mov eax, dword [var] . add eax, dword [var] . mov dword [var], eax . call var . mov eax, dword [var] . sub dword [var], eax . xor eax, eax . mov dword [var], eax . mov eax, dword [var] . add eax, eax . lea eax, [eax + eax*8] . mov dword [var], eax . mov eax, dword [var] . sub eax, dword [var] . cmp eax, dword [var] . jge var . add dword [var], var . mov eax, dword [var] . add eax, dword [var] . cmp eax, dword [var] . jne var . mov eax, dword [var] . add eax, dword [var] . mov dword [var], eax . fild dword [var] . call var . mov dword [var], eax . mov eax, dword [var] . sub eax, dword [var] . mov dword [var], eax . inc dword [var] . cmp dword [var], 4 . jne var . mov eax, dword [var] . sub eax, var . mov dword [var], eax . mov eax, dword [var] . add eax, dword [var] . mov edx, dword [var] . add edx, dword [var] . cmp eax, edx
call var . jmp var . push dword [var] . call dword [sym.imp.KERNEL32.dll_DecodePointer] . test eax, eax . je var . call eax . push var . call var . push 1 . push 0 . call var . add esp, var . jmp var . int . int . int . mov ecx, dword [var] . test ecx, 3 . je var . mov al, byte [ecx] . add ecx, 1 . test al, al . je var . test ecx, 3 . jne var . add eax, 0 . lea esp, [esp] . lea esp, [esp] . mov eax, dword [ecx] . mov edx, var . add edx, eax . xor eax, var . xor eax, edx . add ecx, 4 . test eax, var . je var . mov eax, dword [ecx - 4] . test al, al . je var . test ah, ah . je var . test eax, var . je var . test eax, var . je var . jmp var . lea eax, [ecx - 1] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 2] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 3] . mov ecx, dword [var] . sub eax, ecx . ret . lea eax, [ecx - 4] . mov ecx, dword [var] . sub eax, ecx . ret . int
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push ebx . mov ebx, dword [var] . push esi . mov esi, dword [var] . push edi . mov edi, dword [var] . test esi, esi . jne var . cmp dword [var], 0 . jmp var . cmp esi, 1 . je var . cmp esi, 2 . jne var . mov eax, dword [var] . test eax, eax . je var . push edi . push esi . push ebx . call eax . test eax, eax . je var . push edi . push esi . push ebx . call var . test eax, eax . jne var . xor eax, eax . jmp var . push edi . push esi . push ebx . call var . cmp esi, 1 . mov dword [var], eax . jne var . test eax, eax . jne var . push edi . push eax . push ebx . call var . test esi, esi . je var . cmp esi, 3 . jne var . push edi . push esi . push ebx . call var . test eax, eax . jne var . and dword [var], eax . cmp dword [var], 0 . je var . mov eax, dword [var] . test eax, eax . je var . push edi . push esi
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . B' . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
sub esp, var . call dword [sym.imp.KERNEL32.dll_GetProcessHeap] . and dword [var], 0 . lea edx, [lpModuleName] . and dword [var], 0 . push var . pop ecx . mov dword [var], eax . call var . lea eax, [lpModuleName] . push eax . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . test eax, eax . jne var . call var . and dword [esp], 0 . push var . pop eax . dec eax . mov byte [esp + eax + 8], 0 . jne var . push var . lea eax, [lpFilename] . push eax . push 0 . call dword [sym.imp.KERNEL32.dll_GetModuleFileNameW] . push ecx . lea edx, [var] . lea ecx, [var] . call var . test eax, eax . je var . xor ecx, ecx . mov al, byte [ecx + var] . mov byte [esp + ecx + var], al . inc ecx . cmp ecx, var . jb var . and dword [var], 0 . lea eax, [var] . push ebx . push esi . mov esi, dword [var] . lea edx, [var] . push eax . push dword [var] . lea ecx, [var] . push esi . call var . test eax, eax . je var . mov ebx, dword [var] . jmp var . mov ecx, dword [var] . call var . xor ebx, ebx . mov dword [var], ebx . test esi, esi . je var . push var . push 0 . push esi . call dword [sym.imp.KERNEL32.dll_VirtualFree] . cmp dword [var], 0
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor eax, var . inc edi . mov word [esi + esi*4 + var], cs . sbb eax, var . test al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [ecx + var], bh . je var . cmp eax, var . jae var . outsd dx, dword [esi] . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add eax, var . les eax, [ecx - var] . or ebx, eax . outsd dx, dword [esi] . sbb al, var . mov esp, var . out dx, al . insb byte es:[edi], dx . inc eax . dec esi . sahf . xor dh, byte [ecx + ebp*4 - var] . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . add esp, var . push ebx . push esi . push edi . mov dword [var], esp . call dword [sym.imp.KERNEL32.dll_GetVersion] . mov dword [var], eax . mov eax, dword [var] . shr eax, 8 . and eax, var . mov dword [var], eax . mov ecx, dword [var] . and ecx, var . mov dword [var], ecx . mov edx, dword [var] . shl edx, 8 . add edx, dword [var] . mov dword [var], edx . mov eax, dword [var] . shr eax, var . and eax, var . mov dword [var], eax . push 1 . call var . add esp, 4 . test eax, eax . jne var . push var . call var . add esp, 4 . call var . test eax, eax . jne var . push var . call var . add esp, 4 . mov dword [var], 0 . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . call var . call var . mov dword [var], 0 . lea ecx, [lpStartupInfo] . push ecx . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . call var . mov dword [var], eax . mov edx, dword [var] . and edx, 1 . test edx, edx . je var . mov eax, dword [var]
call var . jmp var . test eax, eax . jne var . pxor xmm0, xmm0 . jmp var . movd xmm0, eax . punpcklbw xmm0, xmm0 . punpcklwd xmm0, xmm0 . pshufd xmm0, xmm0, 0 . push ebx . push ecx . mov ebx, ecx . and ebx, var . test ebx, ebx . jne var . mov ebx, edx . and edx, var . shr ebx, 7 . je var . movdqa xmmword [ecx], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . movdqa xmmword [ecx + var], xmm0 . lea ecx, [ecx + var] . dec ebx . jne var . test edx, edx . je var . mov ebx, edx . shr ebx, 4 . je var . jmp var . lea ecx, [ecx] . movdqa xmmword [ecx], xmm0 . lea ecx, [ecx + var] . dec ebx . jne var . and edx, var . je var . mov ebx, edx . shr edx, 2 . je var . movd dword [ecx], xmm0 . lea ecx, [ecx + 4] . dec edx . jne var . and ebx, 3 . je var . mov byte [ecx], al . inc ecx . dec ebx . jne var . pop eax . pop ebx . ret . neg ebx . add ebx, var . sub edx, ebx . push edx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + 8], ah . jnp var . sub byte [ecx], bh . fld dword [esi - var] . and eax, var . mov eax, dword [esi] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], cl . outsb dx, byte [esi] . jne var . insb byte es:[edi], dx . je var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add ch, byte [ebx + var] . xchg eax, ebx . rol byte [ebp - var], 1 . jb var . stosd dword es:[edi], eax . mov ch, var . push ecx . and dword [var], var . add byte [edx + var], var . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx + ecx*4 + var], al . inc ebx . dec edx . test dword [esi - var], edi . mov byte [var], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec edi . arpl word [ecx + var], si . jb var . outsd dx, dword [esi] . jne var . xor eax, 0 . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add eax, dword [ebx] . push ss . mov al, var . or bl, cl . cdq . inc edx . pushfd . scasb al, byte es:[edi] . jg var . retf var . cmpsb byte [esi], byte ptr es:[edi] . xor ch, byte [ecx + var] . or eax, var . cmpsb byte [esi], byte ptr es:[edi] . xor eax, var . mov edi, var . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebx . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . push eax . mov edi, var . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . call var . pop ebp . mov eax, ebp . sub ebp, var . sub eax, dword [ebp + var] . mov dword [ebp + var], eax . mov al, 0 . xchg byte [ebp + var], al . cmp al, 1 . jne var . mov eax, dword [ebp + var] . sub eax, dword [ebp + var] . mov eax, dword [eax] . mov dword [ebp + var], eax . mov eax, dword [ebp + var] . sub eax, dword [ebp + var] . mov eax, dword [eax] . mov dword [ebp + var], eax . cmp dword [ebp + var], 0 . je var . cmp dword [ebp + var], 0 . je var . lea eax, [ebp + var] . push eax . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax . lea eax, [ebp + var] . push eax . push dword [ebp + var] . call dword [ebp + var] . cmp eax, 0 . je var . mov dword [ebp + var], eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push esi . push edi . push var . pop edi . xor ebx, ebx . push var . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.UXTHEME . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], 0 . jne var . push ebp . push 9 . call var . push 7 . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, ebp . jne var . push var . mov eax, var . pop edi . push edi
sub esp, var . push ebx . push ebp . push esi . push edi . xor ebx, ebx . push var . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [psfi], var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . push str.UXTHEME . call var . push str.USERENV . call var . push str.SETUPAPI . call var . push var . call var . push var . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push ebx . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . push eax . mov ebp, var . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA]
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
push esi . mov dword [var], ebx . pop dword [var] . lea esi, [ebx] . test eax, eax . test esp, esp . test edx, edx . test ecx, ecx . mov eax, edx . lea edx, [var] . jmp loc.0040365b . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . cmp eax, 0 . mov ebx, dword [var] . cmp ebx, ecx . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + 8] . mov edx, var . mov dword [esp + var], var . mov word [esp + var], var . mov esi, dword [esp + var] . mov edi, esi . and edi, var . mov dword [esp + var], edi . mov bx, word [esp + var] . mov di, bx . sub di, var . mov word [esp + var], di . mov edi, dword [esp + var] . mov dword [esp + var], esi . mov si, bx . xor si, var . sub edx, edi . mov word [esp + var], si . mov dword [esp + var], edx . mov edx, dword [esp + var] . xor edx, var . mov dword [esp + var], edx . cmp eax, 0 . mov dword [esp + var], eax . mov dword [esp + 8], ecx . mov word [esp + 6], bx . jne var . mov eax, dword [esp + var] . mov dword [esp + var], 0 . mov dword [esp + var], var . lea esp, [ebp - var] . pop esi . pop edi . pop ebx . pop ebp . ret . mov ax, var . mov dx, word [esp + 6]
mov eax, dword fs:[0] . push ebp . mov ebp, esp . push varffffffff . push var . push var . push eax . mov eax, dword [var] . mov dword fs:[0], esp . mov ecx, dword [sym.imp.CRTDLL.dll__fmode_dll] . sub esp, var . mov dword [ecx], eax . mov edx, dword [var] . mov eax, dword [sym.imp.CRTDLL.dll__commode_dll] . push ebx . push esi . push edi . mov dword [var], esp . mov dword [eax], edx . call var . lea edx, [var] . lea eax, [var] . push dword [var] . push edx . push eax . lea ecx, [var] . push ecx . call sub.CRTDLL.dll___GetMainArgs . add esp, var . push var . push var . call sub.CRTDLL.dll__initterm . add esp, 8 . mov dword [var], 0 . mov eax, dword [sym.imp.CRTDLL.dll__acmdln_dll] . mov esi, dword [eax] . mov al, byte [esi] . cmp al, var . jne var . mov al, byte [var] . inc esi . mov al, byte [esi] . test al, al . je var . cmp al, var . jne var . cmp byte [esi], var . jne var . inc esi . jmp var . cmp al, var . jbe var . inc esi . cmp byte [esi], var . ja var . cmp byte [esi], 0 . je var . cmp byte [esi], var . ja var . inc esi . cmp byte [esi], 0 . jne var . mov dword [var], 0 . lea eax, [lpStartupInfo]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dl, bh . dec edi . int . xchg eax, ebx . jle var . inc ebx . sbb edi, var . mov ch, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . jbe var . xor al, var . jb var . push var . arpl word [esi + edx*2 + var], si . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . add al, var . jae var . push ebp . daa . into . cdq . dec ecx . mov ch, var . or edi, esi . mov dl, var . or ah, byte [eax] . les ebx, [eax + var] . arpl word [esi - var], sp . dec ebp . pop es . push ebx . push ecx . clc . push ebx . ret var . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . cmp byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . jg var . push var . dec esp . scasb al, byte es:[edi] . mov ah, var . pop esp . rol dword [edi + esi*2 + var], cl . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], cl . je var . jb var . add byte [eax], al . add byte [eax], al . add byte [eax], al . pop es . add byte [eax], al . add byte [eax + var], ah . inc eax . add byte [edi], al . add byte [eax], al . add byte [esi + ebx], al . inc eax . add byte [edi], al . add byte [eax], al . add al, al . sbb eax, var . add byte [eax], al . push esp . sbb eax, var . add byte [eax], al . adc byte [var], bl . add byte [eax], al . mov esp, var . add byte [ecx], al . add al, bh . sbb dword [eax], eax . add byte [eax], al . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [edx + ebx + var], bh
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edx], bl . jmp var . ret var . mov ah, var . sbb al, var . inc ebp . and al, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx + var], al . jb var . jb var . push edx . pop ecx . inc edi . dec eax . inc ebp . inc esp . push ebx . inc ecx . inc esi . push esp . inc ecx . dec esp . inc ebp . dec esi . add byte [eax], al . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . add al, var . not byte ss:[ecx] . cdq . dec ebp . adc al, var . cmpsb byte [esi], byte ptr es:[edi] . shr byte [esi + var], var . dec edx . jns var . std . push ebx . adc dword [ecx - var], ecx . pop es . int . xchg ah, bl . adc ch, byte [ebx] . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al
push ebp . mov ebp, esp . sub esp, var . xor eax, eax . push ebx . push esi . push edi . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], var . mov dword [var], var . mov dword [var], var . mov dword [var], 0 . call var . pop eax . add eax, var . mov dword [var], eax . mov eax, dword fs:[var] . mov dword [var], eax . mov eax, dword [var] . mov dword [eax], var . mov eax, dword [var] . mov dword [eax + 4], var . mov eax, dword [var] . mov eax, dword [eax + var] . mov eax, dword [eax + var] . mov eax, dword [eax] . mov eax, dword [eax + 8] . mov ecx, dword [eax + var] . mov ecx, dword [ecx + eax + var] . add ecx, eax . mov edi, dword [ecx + var] . mov ebx, dword [ecx + var] . mov esi, dword [ecx + var] . mov ecx, dword [ecx + var] . add esi, eax . add edi, eax . add ebx, eax . xor edx, edx . mov dword [var], esi . mov dword [var], edx . mov dword [var], ecx . cmp edx, dword [var] . jae var . movzx ecx, word [esi + edx*2] . mov edx, dword [ebx + edx*4] . mov esi, dword [edi + ecx*4] . add edx, eax . mov ecx, dword [edx] . add esi, eax . cmp ecx, var . jne var . cmp dword [edx + 4], var . jne var . cmp dword [edx + 8], var . jne var . cmp dword [edx + var], var . jne var . cmp byte [edx + var], 0
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00415462 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
mov eax, dword [var] . xor eax, eax . call var . jmp var . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov eax, dword [var] . mov ecx, dword [var] . mov dword [var], 0 . mov dword [var], var . mov dword [var], eax . mov dword [var], ecx . call var . mov eax, dword [eax + var] . mov ecx, dword [var] . add ecx, var . mov edx, dword [var] . adc edx, 0 . mov dword [var], edx . mov dword [var], ecx . mov dword [var], 1 . cmp eax, 6 . mov dword [var], eax . jb var . mov eax, dword [var] . mov ecx, dword [var]
push var . push var . call var . mov edi, var . mov eax, edi . call var . mov dword [var], esp . mov esi, esp . mov dword [esi], edi . push esi . call dword [sym.imp.KERNEL32.dll_GetVersionExA] . mov ecx, dword [esi + var] . mov dword [var], ecx . mov eax, dword [esi + 4] . mov dword [var], eax . mov edx, dword [esi + 8] . mov dword [var], edx . mov esi, dword [esi + var] . and esi, var . mov dword [var], esi . cmp ecx, 2 . je var . or esi, var . mov dword [var], esi . shl eax, 8 . add eax, edx . mov dword [var], eax . xor esi, esi . push esi . mov edi, dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . call edi . cmp word [eax], var . jne var . mov ecx, dword [eax + var] . add ecx, eax . cmp dword [ecx], var . jne var . movzx eax, word [ecx + var] . cmp eax, var . je var . cmp eax, var . je var . mov dword [var], esi . jmp var . cmp dword [ecx + var], var . jbe var . xor eax, eax . cmp dword [ecx + var], esi . jmp var . cmp dword [ecx + var], var . jbe var . xor eax, eax . cmp dword [ecx + var], esi . setne al . mov dword [var], eax . push 1 . call var . pop ecx . test eax, eax . jne var . push var . call var . pop ecx . call var
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . mov eax, ebp . mov dword [var], esp . cmp eax, 0 . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . jmp var . mov ebx, dword [var] . cmp ebx, ecx . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . and esp, var . sub esp, 8 . lea eax, section.CODE . xor ecx, ecx . mov dword [esp + 4], ecx . mov dword [esp], ecx . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov ah, var . mov byte [ebp - var], var . add edx, ecx . mov di, word [ebp - var] . mov bl, byte [ebp - var] . xor di, var . mov word [ebp - var], di . add bl, var . mov byte [ebp - var], bl . mov bl, byte [ebp - var] . mov edi, dword [ebp - var] . xor edi, var . mov dword [ebp - var], edi . cmp ah, bl . mov byte [ebp - var], al . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . mov eax, ebp . mov dword [var], esp . cmp eax, 0 . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . jmp var . mov ebx, dword [var] . cmp ebx, ecx . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, [var] . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . xor ecx, ecx . mov dword [esp + var], ecx . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], ecx . mov dword [esp + var], var . mov dx, word [esp + var] . mov si, dx . or si, var . mov word [esp + var], si . mov ecx, dword [sym.imp.USER32.dll_EnumWindows] . call ecx . pop edi . cmp eax, var . push ds . sub eax, var . dec ecx . jmp var . out var, al . enter var, varffffffa9 . and eax, var . sub al, var . cdq . hlt . pop es . dec eax
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
pushal . mov esi, var . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . mov cl, byte [eax] . cmp cl, bl . je var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add ch, ch . xor ecx, ebx . in al, var . enter varffff8c46, varffffffc2 . frstor dword [esi - var] . sub bh, byte [eax] . add byte es:[eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . inc edx . add byte [esi], al . push eax . add dword [ecx], var . push var . outsd dx, dword [esi] . outsd dx, dword [esi] . je var . add byte [eax], al . mov esp, var . add byte [eax], al . add bh, bh . int . xor dword [eax], eax . or ebp, dword [eax - var] . dec esi . wait . inc esi . test byte [edi + var], ch . sbb byte [esp], bl . mov byte [ebx], dh . mov ebx, var . invalid . out var, eax . cmpsd dword ss:[esi], dword ptr es:[edi] . adc ah, al . invalid . cmp cl, byte [edi - var] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
mov eax, ebp . shl eax, 1 . xor eax, ebx . and eax, var . add eax, 3 . mov dword [var], esp . cmp eax, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . add esp, var . cmp eax, 2 . jb var . push ebx . push ecx . call var . mov dword [var], eax . add ebp, var . test eax, eax . cmp eax, var . jne var . mov ebx, ebp . xor eax, eax . nop . nop . nop . nop . ret . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . mov dword [var], var . mov dword [var], eax . call var . mov ecx, dword [var] . xor ecx, var . cmp eax, ecx . jne var . mov eax, dword [var] . mov ecx, dword [var] . add ecx, var . cmp eax, ecx . jne var . jmp var . mov eax, dword [var] . xor eax, var . mov dword [var], eax . jmp var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var . mov cl, byte [eax + 1] . or cl, var . cmp cl, var . jne var . or esi, 2
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
call var . jmp var . push var . push var . call var . call var . movzx esi, ax . push 2 . call var . pop ecx . mov eax, var . cmp word [var], ax . je var . xor ebx, ebx . jmp var . mov eax, dword [var] . cmp dword [eax + var], var . jne var . mov ecx, var . cmp word [eax + var], cx . jne var . xor ebx, ebx . cmp dword [eax + var], var . jbe var . cmp dword [eax + var], ebx . setne bl . mov dword [var], ebx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . and dword [var], 0 . call var . test eax, eax . jns var . push var . call var . pop ecx . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . test eax, eax . jns var . push 8 . call var . pop ecx . call var . test eax, eax . jns var . push 9 . call var . pop ecx . push 1
push ebp . push esp . push edi . push esi . mov ecx, 4 . sub esp, ecx . mov ecx, ebx . mov dword [esp], ecx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . sub esp, var . lea eax, [var] . mov ecx, var . lea edx, [ebp - var] . mov dword [esp], edx . mov dword [esp + 4], eax . mov dword [esp + 8], var . mov dword [ebp - var], edx . mov dword [ebp - var], ecx . call var . call var . mov dword [esp], eax . mov eax, dword [ebp - var] . mov dword [esp + 4], eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push ebx . and esp, var . sub esp, var . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov eax, dword [esp + var] . add eax, var . mov dword [esp + var], eax . mov ecx, dword [esp + var] . mov edx, dword fs:[ecx] . cmp edx, 1 . sbb eax, eax . or eax, edx . mov bl, 1 . test bl, bl . mov dword [esp + 8], eax . jne var . jmp var . xor eax, eax . mov ecx, dword [sym.imp.KERNEL32.dll_GetProcessId] . push 0 . mov dword [esp + 8], eax . call ecx . add esp, 4
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . push var . pop ebx . mov dword [var], eax . mov eax, edi . cmp word [var], bx . jne var . mov esi, ebx . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ecx . cmp ax, cx . jne var . inc esi . inc esi . cmp word [esi], cx . je var . mov dword [var], ecx . cmp word [esi], bx . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + eax*4 + var], bl . adc al, var . xchg eax, esp . mov byte [edx - var], ch . mov dh, 0 . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], dl . push ebx . push esp . push ebp . dec esp . inc ecx . push esp . inc ebp . inc esp . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . or ebx, esp . sub byte [eax - var], bh . dec esi . mov edi, var . or dword [ebp + var], ecx . jb var . fsubr qword [edi + var] . scasd eax, dword es:[edi] . mov eax, var . or dh, byte [edi + var] . dec edi . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . xor eax, eax . push eax . push eax . push eax . push eax . call var . ret . push esi . push edi . mov edi, dword [var] . mov esi, ecx . mov ecx, edi . mov dword [esi], edi . call var . mov dword [esi + 8], eax . mov dword [esi + var], edx . mov eax, dword [edi + var] . mov dword [esi + var], eax . pop edi . mov eax, esi . pop esi . ret 4 . mov eax, ecx . mov ecx, dword [eax] . mov edx, dword [eax + var] . cmp edx, dword [ecx + var] . jne var . push 0 . push dword [eax + var] . push dword [eax + 8] . call var . ret . push ebp . mov ebp, esp . sub esp, var . push esi . xor esi, esi . push esi . push esi . push esi . push esi . lea eax, [ebp - var] . push eax . call dword [sym.imp.USER32.dll_PeekMessageA] . test eax, eax . je var . push esi . push esi . push esi . lea eax, [ebp - var] . push eax . call dword [sym.imp.USER32.dll_GetMessageA] . lea eax, [ebp - var] . push eax . call dword [sym.imp.USER32.dll_TranslateMessage] . lea eax, [ebp - var] . push eax . call dword [sym.imp.USER32.dll_DispatchMessageA] . pop esi . leave . ret . push ebp . mov ebp, esp
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . inc esi . inc esi . cmp word [esi], bx . je var . cmp word [esi], var . jne var . inc esi . push var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . or ebp, var . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
sub esp, var . push ebx . push ebp . push esi . push edi . push var . xor ebp, ebp . pop esi . mov dword [var], ebp . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebp . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebp . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . push ebp . push var . mov dword [var], eax . lea eax, [psfi] . push eax . push ebp . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoW] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineW] . push eax . mov edi, var . push edi . call var . push ebp . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . cmp word [var], var . mov dword [var], eax . mov eax, edi . jne var . push var . pop esi . mov eax, var . push esi . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextW] . mov esi, eax . mov dword [var], esi . jmp var . push var . pop ebx . cmp ax, bx . jne var . add esi, 2 . cmp word [esi], bx . je var . cmp word [esi], var . jne var . push var . add esi, 2 . pop ebx
cmp byte [var], 1 . jne var . pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . nop . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jae var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . mov ebp, eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jne var . inc ecx . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . mov eax, 5 . push edi . dec eax . mov ecx, eax . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . call var . nop . nop . nop . nop . nop . nop . nop . mov dword [var], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [var] . mov dword [var], eax . call var . mov ecx, dword [var] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi . pop edi . pop ebp
call var . inc edx . pop ecx . inc edx . mov dword [var], ebx . push esp . sub dword [var], 8 . mov dword [var], edi . mov dword [var], esi . add dword [var], 8 . add dword [var], 4 . mov dword [var], eax . mov eax, dword [var] . mov eax, dword [var] . jmp var . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . mov esi, var . mov dword [esp + var], var . mov dword [esp + var], var . mov edi, dword [esp + var] . mov ebx, dword [esp + var] . xor ebx, var . and edi, ebx . mov dword [esp + var], var . cmp esi, edi . mov dword [esp + var], eax . mov dword [esp + 8], ecx . mov dword [esp + 4], edx . ja var . jmp var . mov eax, dword [esp + 4] . lea esp, [ebp - var] . pop ebx . pop edi . pop esi . pop ebp . ret . mov eax, dword [esp + var] . mov ecx, dword [esp + 8] . mov dl, byte [ecx + eax] . mov esi, dword [esp + 4] . mov byte [esi + eax], dl . add eax, 1 . mov dword [esp + var], eax . mov edi, dword [esp + var] . cmp eax, edi . je var . jmp var . mov dword [esp + var], 0 . mov eax, dword [esp + var] . cmp eax, 0 . je var . jmp var . push ebp . mov ebp, esp
mov edx, ebp . shl edx, 1 . xor edx, ebx . and edx, var . add edx, 3 . mov dword [var], esp . cmp edx, 0 . je var . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . call var . cmove esi, eax . mov eax, dword [esi + var] . mov eax, dword [eax + var] . mov esi, eax . add esi, var . mov eax, dword [eax + var] . cmp eax, esi . pop esi . pop edi . pop ebx . pop ebp . ret . nop . nop . push ebp . push esp . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . push ebp . mov ebp, esp . and esp, var . sub esp, var . mov eax, dword [var] . mov byte [var], var . mov dword [var], var . mov cl, byte [var] . xor cl, var . mov byte [var], cl . mov dword [var], eax . call var . mov edx, dword [var] . add edx, var . cmp eax, edx . jne var . jmp var . mov eax, dword [var] . mov esp, ebp . pop ebp . ret . mov eax, var . sub eax, dword [var] . mov dword [var], eax . mov cx, word [var] . and cx, var . mov word [var], cx . jmp var
call var . cmp eax, 4 . je var . or eax, esp . or eax, 5 . cmp eax, 0 . mov dword [var], eax . ret . pop edx . add edx, ecx . test eax, eax . mov dword [var], edx . jne var . pop dword [var] . mov eax, var . add esp, var . cmp ecx, 0 . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . push eax . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov edi, ecx . xor edi, dword [ebp - var] . mov ah, byte [edx + ecx] . sub ah, al . mov dword [ebp - var], edi . mov byte [esi + ecx], ah . add esp, 4 . pop esi . pop edi . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], var . mov dword [esp + var], var . mov ecx, dword [sym.imp.RPCRT4.dll_I_RpcFreeBuffer] . call ecx . invalid . mov dword [ebx], ebx . sub al, var . pminub mm2, mm5 . mov byte [var], al . pop ecx . bound ecx, qword [edx + edi*4 + var] . pushfd
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . push esi . push edi . push 8 . pop ecx . mov esi, var . lea edi, [dwExceptionCode] . rep movsd dword es:[edi], dword ptr [esi] . mov dword [var], eax . mov eax, dword [var] . pop edi . mov dword [var], eax . pop esi . test eax, eax . je var . test byte [eax], 8 . je var . mov dword [lpArguments], var . lea eax, [lpArguments] . push eax . push dword [nNumberOfArguments] . push dword [dwExceptionFlags] . push dword [dwExceptionCode] . call dword [sym.imp.KERNEL32.dll_RaiseException] . leave . ret 8 . ├ 262: loc.00414c92 (int2_t var, int2_t var) . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [var], eax
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . mov ebp, esp . lea ebx, [esp - var] . xor eax, eax . push eax . cmp esp, ebx . jne var . inc esi . inc esi . push ebx . push var . push edi . add ebx, 4 . push ebx . push var . push esi . add ebx, 4 . push ebx . push eax . mov dword [ebx], var . nop . nop . nop . push ebp . push edi . push esi . push ebx . sub esp, var . mov edx, dword [var] . mov dword [var], 0 . mov byte [var], 0 . mov ebp, dword [var] . lea eax, [edx + 4] . mov dword [var], eax . mov eax, 1 . movzx ecx, byte [edx + 2] . mov ebx, eax . shl ebx, cl . mov ecx, ebx . dec ecx . mov dword [var], ecx . movzx ecx, byte [edx + 1] . shl eax, cl . dec eax . mov dword [var], eax . mov eax, dword [var] . movzx esi, byte [edx] . mov dword [ebp], 0 . mov dword [var], 0 . mov dword [eax], 0 . mov eax, var . mov dword [var], esi . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . mov dword [var], 1 . movzx ecx, byte [edx + 1] . add ecx, esi . shl eax, cl . lea ecx, [eax + var]
xor dword [var], eax . xor dword [var], edi . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov eax, dword [var] . mov eax, dword [var] . mov eax, dword [var] . add edx, edx . mov eax, ebp . mov dword [var], esp . cmp eax, 0 . mov ecx, ebx . mov dword [var], ecx . mov dword [var], ebp . jmp var . mov ebx, dword [var] . cmp ebx, ecx . jmp var . and dword [var], var . xor dword [var], var . xor dword [var], var . xor dword [var], var . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . lea eax, section.CODE . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push edi . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov ecx, dword [esp + var] . mov edx, ecx . and edx, var . mov dword [esp + var], edx . mov word [esp + var], var . mov byte [esp + var], var . mov dword [esp + var], var . mov bl, byte [esp + var] . xor edx, edx . mov dword [esp + var], edx . mov dword [esp + var], var . mov dword [esp + var], edx . mov dword [esp + var], var . mov bh, bl . xor bh, var . mov byte [esp + var], bh . mov byte [esp + var], var . mov byte [esp + var], var . mov word [esp + var], var . mov word [esp + var], var . mov byte [esp + var], bl . mov dword [esp + var], ecx . mov dword [esp + var], eax . jmp var . jmp var . mov al, byte [esp + var]
push ebp . mov ebp, esp . call var . push 0 . call dword [sym.imp.KERNEL32.dll_ExitProcess] . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, var . push esi . push var . lea eax, [lpStartupInfo] . xorps xmm0, xmm0 . push 0 . push eax . mov esi, ecx . movdqu xmmword [lpProcessInformation], xmm0 . call var . mov eax, dword [var] . add esp, var . mov dword [var], eax . mov dword [var], eax . mov eax, dword [var] . or dword [var], var . mov dword [var], eax . xor eax, eax . mov word [var], ax . lea eax, [lpProcessInformation] . push eax . lea eax, [lpStartupInfo] . mov dword [lpStartupInfo], var . push eax . push 0 . push 0 . push 0 . push 1 . push 0 . push 0 . push esi . push 0 . call dword [sym.imp.KERNEL32.dll_CreateProcessW] . test eax, eax . jne var . call dword [sym.imp.KERNEL32.dll_GetLastError] . pop esi . mov esp, ebp . pop ebp . ret . push dword [lpProcessInformation]
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . mov edx, esp . mov ecx, ebp . mov eax, ebx . cmp edx, var . mov dword [var], eax . jg var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, section..data . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ah, byte [edx + ecx] . sub ah, al . xor edx, edx . mov al, dl . test al, al . mov byte [esp + var], ah . mov dword [esp + var], ecx . mov dword [esp + var], esi . jne var . jmp var . mov eax, dword [esp + var] . mov ecx, dword [esp + var] . mov dl, byte [esp + var] . mov byte [eax + ecx], dl . lea esp, [ebp - 4] . pop esi . pop ebp . ret . xor eax, eax . mov dword [esp], 0 . mov dword [esp + 4], 0 . mov dword [esp + var], eax . call var . mov dword [esp + var], eax . lea esp, [ebp - 4] . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push ebx . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ecx, dword [esp + var] . mov edx, dword [sym.imp.KERNEL32.dll_SetThreadLocale]
push ebp . mov ebp, esp . add esp, var . push ebx . push esi . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov eax, var . call var . xor eax, eax . push ebp . push var . push dword fs:[eax] . mov dword fs:[eax], esp . call var . call var . push 1 . mov ecx, var . mov dl, 1 . mov eax, dword [var] . call var . mov edx, dword [var] . mov dword [edx], eax . mov eax, dword [var] . mov eax, dword [eax] . xor edx, edx . call var . test al, al . jne var . call var . test al, al . jne var . call var . mov ebx, eax . test ebx, ebx . jle var . mov esi, 1 . push dword [var] . push var . lea edx, [var] . mov eax, esi . call var . push dword [var] . push var . mov eax, var . mov edx, 4 . call var . inc esi . dec ebx . jne var . lea edx, [var] . xor eax, eax . call var . mov eax, dword [var] . push eax . call sub.user32.dll_GetForegroundWindow . mov ecx, dword [var] . pop edx . call var . jmp var . call var . mov eax, dword [var] . mov eax, dword [eax]
call var . jmp var . push var . push var . call var . call var . movzx esi, ax . push 2 . call var . pop ecx . mov eax, var . cmp word [var], ax . je var . xor ebx, ebx . jmp var . mov eax, dword [var] . cmp dword [eax + var], var . jne var . mov ecx, var . cmp word [eax + var], cx . jne var . xor ebx, ebx . cmp dword [eax + var], var . jbe var . cmp dword [eax + var], ebx . setne bl . mov dword [var], ebx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . test eax, eax . jne var . push var . call var . pop ecx . call var . and dword [var], 0 . call var . test eax, eax . jns var . push var . call var . pop ecx . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov dword [var], eax . call var . mov dword [var], eax . call var . test eax, eax . jns var . push 8 . call var . pop ecx . call var . test eax, eax . jns var . push 9 . call var . pop ecx . push 1
push ebp . mov ebp, esp . push varffffffff . push var . push var . mov eax, dword fs:[0] . push eax . mov dword fs:[0], esp . sub esp, var . push ebx . push esi . push edi . mov dword [var], esp . xor ebx, ebx . mov dword [var], ebx . push 2 . call dword [sym.imp.MSVCRT.dll___set_app_type] . pop ecx . or dword [var], var . or dword [var], var . call dword [sym.imp.MSVCRT.dll___p__fmode] . mov ecx, dword [var] . mov dword [eax], ecx . call dword [sym.imp.MSVCRT.dll___p__commode] . mov ecx, dword [var] . mov dword [eax], ecx . mov eax, dword [sym.imp.MSVCRT.dll__adjust_fdiv] . mov eax, dword [eax] . mov dword [var], eax . call var . cmp dword [var], ebx . jne var . push var . call dword [sym.imp.MSVCRT.dll___setusermatherr] . pop ecx . call var . push var . push var . call sub.MSVCRT.dll__initterm . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . push dword [var] . lea eax, [var] . push eax . lea eax, [var] . push eax . lea eax, [var] . push eax . call dword [sym.imp.MSVCRT.dll___getmainargs] . push var . push section..data . call sub.MSVCRT.dll__initterm . add esp, var . mov eax, dword [sym.imp.MSVCRT.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . cmp byte [esi], var . jne var . inc esi . mov dword [var], esi . mov al, byte [esi] . cmp al, bl
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [edi], al . adc eax, var . lea eax, [esi - var] . pop eax . xchg eax, ebp . ljmp 0 . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec eax . popal . outsb dx, byte [esi] . insb byte es:[edi], dx . imul esi, dword [ebx + var], var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add dword [eax], eax . add al, byte [eax] . jo var . inc eax . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [edi + ebx], ah . inc eax . add byte [eax - var], bl . dec ecx . add byte [eax], al . add byte [eax], al . add byte [eax], ah . push 0 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor al, var . inc eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov dword [var], ebx . pop dword [var] . add dword [var], 4 . pop dword [var] . xor ecx, var . cmp ecx, 2 . je var . call var . mov dword [var], eax . xor eax, eax . mov dword [var], eax . mov al, byte [var] . and byte [edi], dh . sti . int . add bh, byte [ecx - var] . test eax, var . pop edx . add eax, var . das . xchg eax, edx . int . adc dl, byte [edi + var] . sub al, cl . sar dword [esp + esi], var . and esi, esi . pop esp . rcl ch, cl . lea ebp, [ebx] . push esp . pop ss . cli . jne var . add ecx, dword [ebx - var] . fsubr dword [eax] . insb byte es:[edi], dx . mov eax, dword [var] . and byte [edi + var], dh . das . cwde . rcl dl, cl . ljmp var:var . and dword [ebx], edi . cmp cl, dh . arpl word [ebx - var], dx . sub eax, dword [ecx - var] . cmp al, var . sbb esp, dword [ecx] . idiv byte [edx + edx*2 - var] . or eax, var . aaa . jp var . mov eax, dword [var] . invalid . fcomp st(0) . fdiv qword [ecx + var] . sbb byte [ebp + edi*2 + var], bl . push esp . imul ebp, dword [edi + ecx*2 + var], var . les eax, [edx] . mov edx, var . cmpsd dword [esi], dword ptr es:[edi]
push ebp . push esp . mov eax, ebp . add eax, var . xor ecx, ecx . xchg edx, ebx . mov dword [var], edx . or eax, edx . add ecx, 4 . mov ebx, edx . cmp eax, 0 . je var . pop edx . add edx, ecx . pop dword [var] . mov dword [var], edx . cmp ecx, 0 . jne var . test eax, eax . je var . mov eax, var . add esp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov eax, dword [var] . mov ecx, dword [var] . xor eax, var . mov dword [var], ecx . mov dword [var], eax . call var . mov dword [var], 1 . cmp eax, 0 . je var . jmp var . cmp dword [var], 0 . setne al . and al, 1 . movzx ecx, al . mov dword [var], ecx . jmp var . mov eax, dword [var] . and eax, var . mov dword [var], eax . call var . mov dword [var], eax
adc edi, edi . mov ecx, ecx . imul ebx, eax . push var . push ebp . test ebp, var . test eax, ebp . jb var . movsx ecx, ax . test edi, ebx . test ah, dh . dec ecx . xchg ecx, ebp . sub al, var . mov dh, var . dec ecx . call var . mov dl, var . mov dh, var . imul ebx, ebp . sbb esi, var . inc dl . inc esi . cmp ecx, var . mov ch, var . imul esi, ebp . mov ah, var . mov cl, al . lea esi, [var] . add al, var . sbb eax, var . mov al, var . test eax, var . test ch, var . lea eax, [var] . xchg eax, eax . jmp var . mov eax, ebp . push var . lea eax, [var] . pop ebx . mov eax, var . mov ah, dl . xor ebx, var . adc ah, var . push ebx . mov ah, var . pop ebp . mov al, var . add ebp, var . cmp ebx, var . je var . inc eax . mov esi, ebp . mov ebx, edx . add esi, var . imul ebp, esi . xchg esi, edi . dec al . sub al, bh . test esi, var . sub edi, var . inc ebp . push edi
call var . push eax . call sub.KERNEL32.DLL_ExitProcess . add byte [eax], al . add byte [eax], al . nop . push ebp . mov ebp, esp . push ebx . push esi . push edi . mov edi, dword [var] . mov ebx, dword [var] . mov esi, dword [var] . mov edx, ebx . push dword [var] . push str.GETPASSWORD1 . push 0 . push 0 . mov eax, esi . mov ecx, edi . call var . sub ebx, var . je var . dec ebx . je var . jmp var . push dword [var] . push var . push esi . call sub.USER32.DLL_SetDlgItemTextA . mov eax, 1 . jmp var . and di, var . dec di . je var . dec di . je var . jmp var . push var . push var . push var . push esi . call sub.USER32.DLL_GetDlgItemTextA . push 1 . push esi . call sub.USER32.DLL_EndDialog . mov eax, 1 . jmp var . push 0 . push esi . call sub.USER32.DLL_EndDialog . mov eax, 1 . jmp var . xor eax, eax . jmp var . xor eax, eax . pop edi . pop esi . pop ebx . pop ebp . ret var . push ebp . mov ebp, esp
push ebp . mov ebp, esp . sub esp, var . push edi . mov dword [lpStartupInfo], var . mov ecx, var . xor eax, eax . lea edi, [var] . rep stosd dword es:[edi], eax . push var . push 0 . push var . call var . add esp, var . push section..bdata . call var . add esp, 4 . push eax . push var . push section..bdata . call var . add esp, var . push var . push var . call dword [sym.imp.KERNEL32.dll_GetSystemDirectoryA] . push var . push var . push 0 . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . push eax . call dword [sym.imp.KERNEL32.dll_GetModuleFileNameA] . push var . push var . call dword [sym.imp.KERNEL32.dll_lstrcpyA] . push var . push var . call dword [sym.imp.KERNEL32.dll_lstrcatA] . push var . push var . call dword [sym.imp.KERNEL32.dll_lstrcatA] . push var . push 0 . push 0 . call dword [sym.imp.KERNEL32.dll_CreateMutexA] . mov dword [hObject], eax . call dword [sym.imp.KERNEL32.dll_GetLastError] . cmp eax, var . jne var . push var . call var . add esp, 4 . test eax, eax . jne var . push 0 . call var . jmp var . call var . push var . call var . add esp, 4 . push eax . push var . call var . add esp, 4
pushal . call var . jmp var . push ebp . ret . call var . eb5d jmp var . pop ebp . mov ebx, var . add ebx, ebp . sub ebx, var . cmp dword [var], 0 . mov dword [var], ebx . jne var . lea eax, [var] . push eax . call dword [var] . mov dword [var], eax . mov edi, eax . lea ebx, [var] . push ebx . push eax . call dword [var] . mov dword [var], eax . lea ebx, [var] . push ebx . push edi . call dword [var] . mov dword [var], eax . lea eax, [var] . jmp eax . push esi . imul esi, dword [edx + var], var . insb byte es:[edi], dx . insb byte es:[edi], dx . outsd dx, dword [esi] . arpl word [eax], ax . push esi . imul esi, dword [edx + var], var . jb var . add byte gs:[ebx + var], cl . add byte [ebx], cl . invalid . je var . mov eax, dword [ebx] . xchg dword [ebp + var], eax . mov dword [ebx], eax . lea esi, [ebp + var] . cmp dword [esi], 0 . je var . push 4 . push var . push var . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax . mov eax, dword [esi + 4] . add eax, var . push 4 . push var . push eax . push 0 . call dword [ebp + var] . mov dword [ebp + var], eax
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add al, bh . xchg eax, ebx . loop var . daa . mov bl, var . dec ebx . mov bh, byte [ebx + esi] . and edx, esp . and al, var . je var . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [edx], al . push es . push eax . add dword [ecx], var . jne var . insb byte es:[edi], dx . imul esp, dword [ebx + var], var . add byte [esi + var], ah . add eax, dword [eax] . add byte [eax], al . add byte [ecx], al . add byte [edi], dl . add byte [esi + var], cl . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add byte [eax], dh . sub eax, dword [eax] . fdiv dword [ecx + var] . add byte [eax], al . push var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add ah, bl . sbb dword [eax], eax . add dword [eax], eax . sbb dword [eax], eax . mov word [esi], fs . inc eax
push ebp . push esp . xor ecx, ecx . mov dword [var], ebx . add ecx, 4 . cmp ecx, 1 . je var . pop eax . add eax, ecx . pop dword [var] . mov dword [var], eax . cmp ecx, 0 . jne var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . push ebp . mov ebp, esp . push esi . push edi . push ebx . and esp, var . sub esp, var . mov dword [var], 0 . mov dword [var], var . mov dword [var], var . mov dword [var], 0 . mov dword [var], var . call var . mov ecx, var . sub ecx, dword [var] . mov dword [var], ecx . cmp eax, 0 . je var . jmp var . mov al, byte [var] . and al, 1 . movzx ecx, al . mov dword [var], ecx . mov eax, dword [var] . lea esp, [var] . pop ebx . pop edi . pop esi . pop ebp . ret . call var . mov ecx, dword [var] . mov edx, dword [var] . mov esi, dword [var] . mov edi, dword [var] . xor ebx, ebx . mov dword [var], eax
push var . call var . ret . ret . mov edx, var . ljmp var:var . and al, 8 . dec edx . jecxz var . in al, var . add bl, ah . cmc . mov ch, dl . dec ebx . sub byte [edi - var], var . mov dl, var . cmp eax, var . jl var . pop eax . cwde . insd dword es:[edi], dx . xchg eax, esp . cmpsd dword [esi], dword ptr es:[edi] . std . xlatb . sbb ah, ah . iretd . jnp var . and al, var . pop edx . leave . add bl, byte [eax - var] . insb byte es:[edi], dx . push cs . mov bl, var . loope var . cwde . xor eax, var . sub eax, var . dec ecx . bound ebp, qword [ebp + esi*4 + var] . pushfd . rcl dword [edi - var], var . push eax . out var, eax . jge var . loop var . cmc . fmul dword [edi] . sbb al, var . sbb dword [esi], var . fsub dword [eax + var] . test byte [ebx + esi*2], var . ror dword [edi - var], var . inc ecx . mov ebx, var . adc eax, var . loopne var . cmp al, var . retf var . sub byte [ebp + ecx*2 - var], ch . xor esi, dword gs:[ebp - var] . out dx, eax . inc ecx
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . mov dword [edi + var], var . push edi . or ebp, var . jmp var . nop . nop . nop . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi]
sub esp, var . push ebx . push esi . push edi . xor ebx, ebx . push var . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . mov dword [var], ebx . mov byte [var], var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . call dword [sym.imp.KERNEL32.dll_GetVersion] . cmp ax, 6 . je var . push ebx . call var . cmp eax, ebx . je var . push var . call eax . mov esi, str.UXTHEME . push esi . call var . push esi . call dword [sym.imp.KERNEL32.dll_lstrlenA] . lea esi, [esi + eax + 1] . cmp byte [esi], bl . jne var . push ebp . push 9 . call var . push 7 . call var . mov dword [var], eax . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov ebp, var . push eax . push ebp . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, ebp . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [var], dh . jnp var . dec esp . scasd eax, dword es:[edi] . pop es . sbb cl, bl . and al, var . pop esp . sub byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], dh . xor al, var . jb var . push var . arpl word [esi + edx*2 + var], si . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . push es . add byte [eax], al . add byte [eax + var], bl . add byte [eax], al . add byte [eax + var], dl . add byte [eax], al . add byte [ebp + ebx + var], cl . add byte [edi], al . add byte [eax], al . add ah, bh . sbb al, var . add byte [edi], al . add byte [eax], al . add byte [eax + var], bl . add byte [eax], al . add byte [esp + ebx + var], cl . 0001 add byte [ecx], al . add dword [eax], eax . add al, byte [eax] . enter var, 0 . add byte [eax], al . add byte [eax], al . invalid . invalid . invalid . invalid . invalid . invalid
sub esp, var . push ebx . push ebp . push esi . xor ebx, ebx . push edi . mov dword [var], ebx . mov dword [var], str.Error_writing_temporary_file._Make_sure_your_temp_folder_is_valid. . xor esi, esi . mov byte [var], var . call dword [sym.imp.COMCTL32.dll_InitCommonControls] . push var . call dword [sym.imp.KERNEL32.dll_SetErrorMode] . push ebx . call dword [sym.imp.ole32.dll_OleInitialize] . push 8 . mov dword [var], eax . call var . mov dword [var], eax . push ebx . lea eax, [psfi] . push var . push eax . push ebx . push var . call dword [sym.imp.SHELL32.dll_SHGetFileInfoA] . push str.NSIS_Error . push var . call var . call dword [sym.imp.KERNEL32.dll_GetCommandLineA] . mov edi, var . push eax . push edi . call var . push ebx . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . cmp byte [var], var . mov dword [var], eax . mov eax, edi . jne var . mov byte [var], var . mov eax, var . push dword [var] . push eax . call var . push eax . call dword [sym.imp.USER32.dll_CharNextA] . mov dword [var], eax . jmp var . cmp cl, var . jne var . inc eax . cmp byte [eax], var . je var . cmp byte [eax], var . mov byte [var], var . jne var . inc eax . mov byte [var], var . cmp byte [eax], var . jne var . inc eax . cmp byte [eax], var . jne var
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . inc ecx . add ebx, ebx
pushal . mov esi, section.UPX1 . lea edi, [esi - var] . push edi . jmp var . nop . mov al, byte [esi] . inc esi . mov byte [edi], al . inc edi . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . mov eax, 1 . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . add ebx, ebx . jae var . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . dec eax . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc eax, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . adc ecx, ecx . jmp var . xor ecx, ecx . sub eax, 3 . jb var . shl eax, 8 . mov al, byte [esi] . inc esi . xor eax, var . je var . sar eax, 1 . mov ebp, eax . jmp var . add ebx, ebx . jne var . mov ebx, dword [esi] . sub esi, var . adc ebx, ebx . jb var . inc ecx . add ebx, ebx
call var . jmp var . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . bnd ret . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx
push ebp . mov ebp, esp . sub esp, var . xor eax, eax . push ebx . push esi . push edi . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], var . mov dword [var], var . mov dword [var], var . mov dword [var], 0 . call var . pop eax . add eax, var . mov dword [var], eax . mov eax, dword fs:[var] . mov dword [var], eax . mov eax, dword [var] . mov dword [eax], var . mov eax, dword [var] . mov dword [eax + 4], var . mov eax, dword [var] . mov eax, dword [eax + var] . mov eax, dword [eax + var] . mov eax, dword [eax] . mov eax, dword [eax + 8] . mov ecx, dword [eax + var] . mov ecx, dword [ecx + eax + var] . add ecx, eax . mov edi, dword [ecx + var] . mov ebx, dword [ecx + var] . mov esi, dword [ecx + var] . mov ecx, dword [ecx + var] . add esi, eax . add edi, eax . add ebx, eax . xor edx, edx . mov dword [var], esi . mov dword [var], edx . mov dword [var], ecx . cmp edx, dword [var] . jae var . movzx ecx, word [esi + edx*2] . mov edx, dword [ebx + edx*4] . mov esi, dword [edi + ecx*4] . add edx, eax . mov ecx, dword [edx] . add esi, eax . cmp ecx, var . jne var . cmp dword [edx + 4], var . jne var . cmp dword [edx + 8], var . jne var . cmp dword [edx + var], var . jne var . cmp byte [edx + var], 0
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov ecx, ebx . mov dword [var], ecx . add ecx, 7 . cmp ecx, 3 . je var . pop eax . add eax, 4 . pop dword [var] . mov dword [var], eax . cmp eax, esp . je var . test eax, eax . je var . mov edx, ebx . sub edx, ecx . add eax, edx . sub ebp, var . ret . mov dword [ebp - 4], eax . int . int . int . int . int . int . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], var . call var . mov ecx, 1 . mov edx, dword [var] . xor edx, var . cmp eax, edx . mov dword [var], ecx . jne var . call var . cmp eax, 0 . setne cl . and cl, 1 . movzx eax, cl . mov dword [var], eax . mov eax, dword [var] . add esp, 8 . pop ebp . ret . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push edi
call var . push eax . call sub.KERNEL32.DLL_ExitProcess . add byte [eax], al . add byte [eax], al . nop . push ebp . mov ebp, esp . push ebx . push esi . push edi . mov edi, dword [var] . mov ebx, dword [var] . mov esi, dword [var] . mov edx, ebx . push dword [var] . push str.GETPASSWORD1 . push 0 . push 0 . mov eax, esi . mov ecx, edi . call var . sub ebx, var . je var . dec ebx . je var . jmp var . push dword [var] . push var . push esi . call sub.USER32.DLL_SetDlgItemTextA . mov eax, 1 . jmp var . and di, var . dec di . je var . dec di . je var . jmp var . push var . push var . push var . push esi . call sub.USER32.DLL_GetDlgItemTextA . push 1 . push esi . call sub.USER32.DLL_EndDialog . mov eax, 1 . jmp var . push 0 . push esi . call sub.USER32.DLL_EndDialog . mov eax, 1 . jmp var . xor eax, eax . jmp var . xor eax, eax . pop edi . pop esi . pop ebx . pop ebp . ret var . push ebp . mov ebp, esp
call var . jmp var . cmp ecx, dword [var] . bnd jne var . bnd ret . bnd jmp loc.0041db27 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_alloc.0 . ret . push ebp . mov ebp, esp . push esi . push dword [ebp + 8] . mov esi, ecx . call var . mov dword [esi], vtable.std::bad_array_new_length.0 . mov eax, esi . pop esi . pop ebp . ret 4 . and dword [ecx + 4], 0 . mov eax, ecx . and dword [ecx + 8], 0 . mov dword [ecx + 4], var . mov dword [ecx], vtable.std::bad_array_new_length.0 . ret . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . push ebp . mov ebp, esp . sub esp, var . lea ecx, [var] . call var . push var . lea eax, [var] . push eax . call var . int . jmp var . jmp dword [var] . int . int . int . int . int . int . int . int . int . int . int . int . push var
mov dword [var], eax . mov dword [var], eax . call var . cmp ecx, 2 . mov dword [var], eax . je var . cmp ecx, 2 . cmp esp, var . call var . call var . cmp esp, var . add eax, var . xor eax, eax . ret . xor eax, eax . xor eax, eax . mov dword [ebp - 8], eax . movsd dword es:[edi], dword ptr [esi] . test esi, edi . xor dword [eax], var . invalid . ja var . jnp var . jo var . pushfd . xchg bh, bl . ljmp var:var . shr dword [esp + eax*4 + var], cl . inc esp . add ebx, ebx . push edi . mov ebp, ebx . push esi . push ds . pop ebx . push ebp . xchg eax, ebp . xchg eax, edx . jp var . add dh, byte [edi - var] . add al, var . xor eax, var . sbb eax, ebx . or dh, byte [ebx] . mov esi, var . mov byte [var], al . invalid . xor ah, byte [esi] . enter varffff929d, varffffffa1 . xor dh, bl . pop edi . mov al, var . rcr byte [edx + var], var . sbb eax, dword [ebx - var] . or al, var . inc ebp . sal edx, var . lodsd eax, dword [esi] . or byte [edi], al . xor bh, ch . enter varffff80f0, varffffffa4 . fimul word [eax - var] . inc byte [ebx + var] . mov eax, var
push var . push 0 . push var . call sub.MSVCRT.dll_memset . add esp, var . push 0 . call sub.KERNEL32.dll_GetModuleHandleW . mov dword [var], eax . push 0 . push var . push 0 . call sub.KERNEL32.dll_HeapCreate . mov dword [var], eax . call var . mov eax, var . mov dword [var], eax . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . call var . mov edx, var . lea ecx, [var] . call var . push var . call sub.KERNEL32.dll_GetStdHandle . mov dword [var], eax . mov eax, var . push eax . lea eax, [var] . push eax . xor eax, eax . push eax . push var . push 4 . call var . push dword [var] . call var . push 7 . push var . lea eax, [var] . push eax . push 8 . call var . push dword [var] . call var . push 8 . push var . lea eax, [var] . push eax . push 4 . call var . push var . push var . push 7 . push var . push var . call var
call var . jmp var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], ebx . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov edi, ebx . mov edx, var . mov ecx, esi . xor eax, eax . lock cmpxchg dword [edx], ecx . test eax, eax . je var . cmp eax, esi . jne var . xor esi, esi . inc esi . mov edi, esi . jmp var . push var . call dword [sym.imp.KERNEL32.dll_Sleep] . jmp var . xor esi, esi . inc esi . cmp dword [var], esi . jne var . push var . call sub.msvcrt.dll__amsg_exit . pop ecx . jmp var . cmp dword [var], ebx . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . je var . mov dword [var], var . mov eax, var . jmp var . mov dword [var], esi . cmp dword [var], esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test edi, edi . jne var . xor eax, eax . mov ecx, var . xchg dword [ecx], eax
call var . jmp var . push ebp . mov ebp, esp . sub esp, 8 . mov dword [var], edi . mov dword [var], esi . mov esi, dword [var] . mov edi, dword [var] . mov ecx, dword [var] . shr ecx, 7 . jmp var . lea ebx, [ebx] . movdqa xmm0, xmmword [esi] . movdqa xmm1, xmmword [esi + var] . movdqa xmm2, xmmword [esi + var] . movdqa xmm3, xmmword [esi + var] . movdqa xmmword [edi], xmm0 . movdqa xmmword [edi + var], xmm1 . movdqa xmmword [edi + var], xmm2 . movdqa xmmword [edi + var], xmm3 . movdqa xmm4, xmmword [esi + var] . movdqa xmm5, xmmword [esi + var] . movdqa xmm6, xmmword [esi + var] . movdqa xmm7, xmmword [esi + var] . movdqa xmmword [edi + var], xmm4 . movdqa xmmword [edi + var], xmm5 . movdqa xmmword [edi + var], xmm6 . movdqa xmmword [edi + var], xmm7 . lea esi, [esi + var] . lea edi, [edi + var] . dec ecx . jne var . mov esi, dword [var] . mov edi, dword [var] . mov esp, ebp . pop ebp . ret . push ebp . mov ebp, esp . sub esp, var . mov dword [var], edi . mov dword [var], esi . mov dword [var], ebx . mov ebx, dword [var] . mov eax, ebx . cdq . mov ecx, eax . mov eax, dword [var] . xor ecx, edx . sub ecx, edx . and ecx, var . xor ecx, edx . sub ecx, edx . cdq . mov edi, eax . xor edi, edx . sub edi, edx . and edi, var . xor edi, edx . sub edi, edx . mov edx, ecx . or edx, edi . jne var
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add cl, bh . add eax, dword [esi + var] . adc bh, byte [edi - var] . dec esp . mov esi, var . pop edx . invalid . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax + var], dl . push edx . push ebx . dec edi . dec esi . inc ecx . inc edi . inc ebp . push ebx . xor dword [eax], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . dec esp . xor dword [eax], eax . pop es . inc edx . fmul qword [eax] . adc dword [edi + eax - var], edi . inc edx . xchg eax, edx . popal . pop ds . jb var . xchg dword [eax + var], ecx . aad var . dec ebp . mov esp, var . mov dword [esp + eax*2 + var], esp . lodsd eax, dword [esi] . xor ebx, dword [ecx - var] . or al, 0 . stosb byte es:[edi], al . add byte [eax - var], ah . xchg eax, ebx . add byte [eax], al . add byte [eax], al
push ebp . mov ebp, esp . add esp, var . mov eax, var . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . mov ecx, dword [var] . mov eax, dword [var] . mov eax, dword [eax] . mov edx, dword [var] . call var . mov eax, dword [var] . mov eax, dword [eax] . call var . call var . lea eax, [eax] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . call var . mov eax, 2 . push edi . add eax, 6 . shr eax, 1 . mov ecx, eax . mov eax, ebx . mov edx, ebx . sub esp, ecx . mov dword [esp], edx . xor ecx, ecx . or ecx, 2 . sub esp, 4 . shl ecx, 5 . cmp ecx, var . ja var . sub eax, var . jne var . add ebp, 8 . xor ebx, ecx . sub ecx, 3 . and ecx, var . cmp ebx, esi . je var . add esp, var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx
jmp var . jmp loc.0040a780 . jmp var . jmp var . jmp loc.0040bc50 . jmp var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int
push ebp . push esp . mov eax, esi . push eax . sub eax, esi . mov eax, 5 . dec eax . mov ecx, eax . mov edx, ebx . sub esp, ecx . mov dword [esp], edi . sub esp, ecx . mov dword [esp], edx . sub esp, ecx . jmp var . nop . nop . nop . nop . nop . nop . nop . mov dword [ebp - 4], eax . push ebp . mov ebp, esp . push eax . mov eax, dword [ebp + 8] . mov dword [ebp - 4], eax . call var . mov ecx, dword [ebp - 4] . push ecx . push eax . call var . add esp, var . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . sub esp, var . mov eax, dword [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + 8] . xor esi, esi . cmp eax, 0 . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - var], edx . mov dword [ebp - var], esi . je var . mov eax, dword [ebp - var] . mov ecx, dword [ebp - var] . mov dl, byte [ecx + eax] . mov esi, dword [ebp - var] . mov byte [esi + eax], dl . add eax, 1 . mov edi, dword [ebp - var] . cmp eax, edi . mov dword [ebp - var], eax . jne var . mov eax, dword [ebp - var] . add esp, var . pop esi
mov eax, dword [var] . call var . mov dword [var], eax . push ebp . mov ebp, esp . lea eax, section.p0rWRzt . pop ebp . ret . push ebp . mov ebp, esp . push esi . and esp, var . sub esp, var . mov al, byte [ebp + var] . mov ecx, dword [ebp + var] . mov edx, dword [ebp + var] . mov esi, dword [ebp + 8] . mov dword [esp + var], 0 . mov dword [esp + 8], var . add esi, ecx . mov ah, byte [edx + ecx] . sub ah, al . mov al, 1 . test al, al . mov byte [esp + 7], ah . mov dword [esp], esi . jne var . jmp var . mov eax, dword [esp] . mov cl, byte [esp + 7] . mov byte [eax], cl . lea esp, [ebp - 4] . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push ebx . push esi . and esp, var . sub esp, var . lea eax, [esp + var] . mov dword [esp + var], 0 . mov dword [esp + var], var . mov dword [esp + var], var . mov dword [esp + var], 0 . mov dword [esp + var], var . mov ecx, dword [sym.imp.ADVAPI32.dll_ClearEventLogW] . call ecx . insd dword es:[edi], dx . loop var . clc . adc byte [ecx - var], bh . push es . adc al, var . mov esi, edi . cmpsb byte [esi], byte ptr es:[edi] . invalid . imul edx, dword [edx], var . jno var . cmp ebp, ebx . popal . div dword [eax + var]
push var . call sub.MSVBVM60.DLL_ThunRTMain . add byte [eax], al . add byte [eax], al . add byte [eax], al . xor byte [eax], al . add byte [eax], al . inc eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi + var], bh . jle var . dec ebp . mov eax, var . adc ebx, dword [var] . add byte [eax], al . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ebx + var], dl . outsb dx, byte [esi] . jae var . popaw . arpl word [ecx + var], bp . outsb dx, byte [esi] . je var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx], al . add byte [esi], al . add byte [eax + var], ah . inc eax . add byte [eax], al . add byte [eax], al . add bh, bh . invalid . invalid . invalid . invalid . invalid . invalid . inc dword [eax] . add byte [eax], al . add ah, dl . pop ds . inc eax . add byte [eax + esi*2 + var], bh . add byte [eax], al . call int.00407736 . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esp + edx], cl . inc eax . add byte [ecx], al . add byte [edx], al . add byte [eax + var], ah . inc eax
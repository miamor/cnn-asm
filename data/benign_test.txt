call var . jmp var . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01002387 . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01014a97 . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memmove] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0101d8cd . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__CxxThrowException] . int . int . int . int . int . mov edi, edi
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . jne var . jmp var . pop edi . pop ebx . leave . ret . nop . nop . nop . nop . nop . push var . mov eax, var . call var . mov eax, dword [ebp + var] . xor esi, esi . cmp eax, esi . je var . mov edi, var . push var . mov dword [eax], esi . mov dword [ebp - var], edi . mov dword [ebp - var], esi . mov dword [ebp - 4], esi . call sub.msvcrt.dll_void_____cdecl_operator_new_unsigned_int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01001b77 . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . int . int . int
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov edi, var . push 0 . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . test eax, eax . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test ebx, ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], 0 . jne var . mov eax, dword [sym.imp.msvcrt.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . mov al, byte [esi] . cmp al, var . jbe var . cmp al, var . je var . movzx eax, al . push eax . call dword [sym.imp.msvcrt.dll__ismbblead]
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002da7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var
call var . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebp . mov ebp, esp . push varfffffffe . push var . push var . mov eax, dword fs:[0] . push eax . sub esp, var . mov eax, dword [var] . xor dword [ebp - 8], eax . xor eax, ebp . mov dword [ebp - var], eax . push ebx . push esi . push edi . push eax . lea eax, [ebp - var] . mov dword fs:[0], eax . mov dword [ebp - var], esp . mov ecx, dword [ebp + 8] . mov dword [ebp - var], ecx . mov ecx, dword [ebp + var] . mov dword [ebp - var], ecx . mov esi, dword [ebp + var] . mov ebx, dword [ebp + var] . mov edi, var . mov dword [ebp - var], edi . test esi, esi . je var . mov eax, dword [esi + 8] . test eax, eax . je var . mov edx, dword [eax + 4] . test edx, edx . je var . cmp word [eax], 8 . jb var . push edx . call var . add esp, 4 . test al, al . jne var . mov ecx, dword [ebp - var] . push dword [ebp + var] . push dword [ebp + var] . push ebx . push esi
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . jmp dword [sym.imp.MSVCR100.dll_void___cdecl_operator_delete_void] . push var . push var . call var . xor eax, eax . mov dword [var], eax . mov dword [var], eax . mov dword [var], eax . mov eax, dword [var] . cmp eax, dword [var] . jge var . mov esi, dword [var] . mov ecx, esi . call dword [var] . add esi, dword [var] . mov dword [var], esi . inc dword [var] . jmp var . mov dword [var], 1 . mov dword [var], var . call var . call var . ret var . cmp dword [var], 0 . jne var . push dword [var] . push dword [var] . push dword [var] . push dword [var] . call var . ret . push var . push var . call var . and dword [var], 0 . dec dword [var] . js var . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . call dword [var] . jmp var . mov eax, dword [ebp - var] . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . mov eax, dword [eax] . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . cmp dword [eax], var . je var . mov dword [ebp - var], 0 . mov eax, dword [ebp - var] . ret . call sub.MSVCR100.dll_void___cdecl_terminate_void . mov esp, dword [ebp - var] . mov dword [var], var . call var . ret var . push var . push var . call var . and dword [var], 0
push esi . mov edi, edi . call var . test eax, eax . jge var . mov esi, eax . call var . mov eax, esi . pop esi . ret . mov eax, dword [var] . call eax . jmp var . push edi . pushfd . push ebp . mov ebp, esp . sub esp, var . mov dword [ebp - var], eax . mov dword [ebp - var], ecx . mov dword [ebp - 8], edx . mov dword [ebp - var], ebx . lea ebx, [ebp + 4] . mov dword [ebp - var], esi . mov dword [ebp - var], edi . sub ebx, 4 . mov dword [ebp - var], ebx . mov eax, dword [ebx] . mov dword [ebp - var], eax . mov eax, dword [ebx + var] . test byte [eax + var], 2 . je var . mov ecx, dword [eax + var] . neg ecx . sbb ecx, ecx . xor esi, esi . and ecx, var . cmp dword [eax + var], esi . je var . mov edx, dword [eax + var] . mov edi, dword [eax + 4] . mov edx, dword [edx*4 + var] . imul edx, dword [ebp + edi*4 - var] . jmp var . xor edx, edx . cmp dword [eax + var], esi . je var . mov esi, dword [eax] . mov esi, dword [ebp + esi*4 - var] . mov edi, dword [eax + 8] . add edi, esi . add edi, edx . mov ecx, dword [edi + ecx] . jmp var . mov ecx, dword [eax] . mov ecx, dword [ebp + ecx*4 - var] . mov edx, var . mov dword [ebp - 4], ecx . lea esi, [eax + var] . lea edi, [esi - 1] . cmp edi, edx . jb var . mov eax, dword [var] . mov ecx, dword [var]
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . push dword [var] . push dword [var] . push dword [var] . call var . add esp, var . mov dword [var], eax . cmp dword [var], ebx . jne var . push eax . call dword [sym.imp.msvcrt.dll_exit] . mov dword [var], esi . jmp var . add byte [eax], al . add byte [eax], al . push var . add byte [ecx], al
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . pop ebp . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret . jmp loc.004074c3 . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . mov dx, word [var] . jmp var . cmp cx, dx . je var . add eax, 2 . movzx ecx, word [eax] . test cx, cx . jne var . cmp word [eax], dx . je var . xor eax, eax . pop ebp . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [var] . push ebx . mov ebx, dword [var] . cmp word [ebx], 0 . push edi . mov edi, eax . je var . movzx ecx, word [eax] . test cx, cx . je var . mov edx, ecx . sub eax, ebx . mov ecx, dword [var]
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010073fd . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010042f7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__CxxThrowException] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, ecx . call dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_type_info::_destructor_void] . test byte [ebp + 8], 1 . je var . push esi . call sub.msvcrt.dll_void___cdecl_operator_delete_void . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memmove_s] . int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002b5d . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [esp + var] . mov dword [esp + var], ebp . lea ebp, [esp + var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002d17 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [ebp + 4] . mov dword [var], eax . lea eax, [ebp + 8] . mov dword [var], eax . mov eax, dword [ebp - var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [var] . mov dword [ebp - var], eax . mov eax, dword [var] . mov dword [ebp - var], eax . call dword [sym.imp.KERNEL32.dll_IsDebuggerPresent] . mov dword [var], eax . push 1 . call sub.MSVCR100.dll__crt_debugger_hook . pop ecx . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . cmp dword [var], 0 . jne var . push 1 . call sub.MSVCR100.dll__crt_debugger_hook . pop ecx . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . " . leave . ret . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01004857 . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01003597 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi . push ebp
call var . jmp var . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010046dd . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [section..data] . xor dword [ebp - 4], eax . xor eax, ebp . mov dword [ebp - var], eax . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . xor ecx, ebp . call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push section..data . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01007717 . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010084e7 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov eax, dword [var] . mov ecx, dword [var] . or ecx, eax . mov ecx, dword [var] . jne var . mov eax, dword [var] . mul ecx . ret var . push ebx . mul ecx . mov ebx, eax . mov eax, dword [var] . mul dword [var] . add ebx, eax . mov eax, dword [var] . mul ecx . add edx, ebx . pop ebx
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [section..data] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . je var . test dword [section..data], ebx . je var . mov dword [section..data], esi . not esi . mov dword [var], esi . pop esi . pop edi . pop ebx . leave . ret . mov esi, var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push esi . mov esi, var . mov ecx, esi . call var . push var . mov dword [var], var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01026cbd . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__ftol2_sse] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memmove_s] . int . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__vsnwprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100da67 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__snwprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__snprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_sprintf_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004d07 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var]
call var . jmp var . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0101275c . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int
call var . jmp var . jmp dword [sym.imp.MSVCR80.dll_memcpy] . jmp dword [sym.imp.MSVCR80.dll__purecall] . jmp dword [sym.imp.MSVCR80.dll___CxxFrameHandler3] . cmp ecx, dword [var] . jne var . ret . jmp loc.1000c685 . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0]
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01005a77 . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . int . int . int
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov edi, edi . push ebp
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100761d . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4
call var . jmp var . int . jmp dword [sym.imp.MSVCR80.dll_memcpy] . jmp dword [sym.imp.MSVCR80.dll___CxxFrameHandler3] . cmp ecx, dword [var] . jne var . ret . jmp loc.10012695 . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0]
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010073b7 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__vsnwprintf] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01007fbd . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push section..data . call var . add esp, var
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100d977 . int . int . int . int . int . int . int . int . int . int . int . int
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.API_MS_Win_Core_SysInfo_L1_1_0.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.API_MS_Win_Core_ProcessThreads_L1_1_0.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.API_MS_Win_Core_SysInfo_L1_1_0.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.API_MS_Win_Core_Profile_L1_1_0.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . jne var . jmp var . pop edi . pop ebx . leave . ret . nop . nop . nop . nop . nop . push 4 . mov eax, var . call var . mov edi, dword [ebp + 8] . mov ecx, edi . call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.00413152 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004023 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . mov dword [ebp - var], eax . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . xor ecx, ebp . call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8]
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . push ecx . push ecx . and dword [hObject], 0 . and dword [var], 0 . lea eax, [hObject] . push eax . push 8 . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.ADVAPI32.dll_OpenProcessToken] . test eax, eax . je var . push esi . mov esi, dword [sym.imp.ADVAPI32.dll_GetTokenInformation] . push edi . lea eax, [var] . push eax . push dword [var] . push 0 . push 1 . push dword [hObject] . call esi . push dword [var] . call sub.msvcrt.dll_void_____cdecl_operator_new___unsigned_int . mov edi, eax . pop ecx . test edi, edi . je var . lea eax, [var] . push eax . push dword [var] . push edi . push 1 . push dword [hObject] . call esi . test eax, eax . je var . push var . push dword [edi] . call dword [sym.imp.ADVAPI32.dll_IsWellKnownSid] . mov esi, eax . test esi, esi . je var . push var . call var . pop ecx . push edi . call sub.msvcrt.dll_void___cdecl_operator_delete___void . pop ecx . push dword [hObject] . call dword [sym.imp.KERNEL32.dll_CloseHandle] . mov eax, esi . pop edi . pop esi
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . mov dword [var], eax . movzx ecx, word [eax] . cmp cx, var . jbe var . cmp cx, var . je var
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002e37 . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01003e87 . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov eax, dword [var] . mov ecx, dword [var] . or ecx, eax . mov ecx, dword [var] . jne var . mov eax, dword [var] . mul ecx . ret var . push ebx . mul ecx . mov ebx, eax . mov eax, dword [var] . mul dword [var] . add ebx, eax . mov eax, dword [var] . mul ecx . add edx, ebx . pop ebx . ret var . int . int
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov ecx, dword [var] . mov eax, var . cmp word [ecx], ax
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_free] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . jne var . jmp var . mov dword [var], esi . not esi . mov dword [var], esi . pop esi . pop edi . pop ebx . leave . ret . mov esi, var . jmp var . push 4 . mov eax, var . mov esi, ebx . pop ecx . mov edi, eax . xor ebx, ebx . repe cmpsd dword [esi], dword ptr es:[edi] . jne var . push 4 . mov edi, eax . pop ecx . mov esi, edx . xor eax, eax
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov ecx, dword [var] . mov eax, var . cmp word [ecx], ax
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004e6d . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int
call var . jmp var . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int . int . int . int . int . cmp ecx, dword [var]
0000:0fe3 33ed xor bp, bp . 0000:0fe5 55 push bp . (reloc.KERNEL.INITTASK) . 0000:0fe6 9affff0000 lcall 0 . 0000:0feb 0bc0 or ax, ax . 0000:0fed 745b je var . 0000:0fef 8c06ae01 mov word [var], es . 0000:0ff3 81c10001 add cx, var . 0000:0ff7 7251 jb var . 0000:0ff9 890e8001 mov word [var], cx . 0000:0ffd 89368201 mov word [var], si . 0000:1001 893e8401 mov word [var], di . 0000:1005 891e8601 mov word [var], bx . 0000:1009 8c068801 mov word [var], es . 0000:100d 89168a01 mov word [var], dx . 0000:1011 e83c00 call var . 0000:1014 e85aff call var . 0000:1017 e85cff call var . 0000:101a 33c0 xor ax, ax . 0000:101c 50 push ax . (reloc.KERNEL.WAITEVENT) . 0000:101d 9affff0000 lcall 0 . 0000:1022 ff368401 push word [var] . (reloc.USER.INITAPP) . 0000:1026 9affff0000 lcall 0 . 0000:102b 0bc0 or ax, ax . 0000:102d 741b je var . 0000:102f ff368401 push word [var] . 0000:1033 ff368201 push word [var] . 0000:1037 ff368801 push word [var] . 0000:103b ff368601 push word [var] . 0000:103f ff368a01 push word [var] . 0000:1043 e8aaf6 call var . 0000:1046 50 push ax . 0000:1047 e8d300 call var . 0000:104a b0ff mov al, var . 0000:104c 50 push ax . 0000:104d e8d400 call var . 0000:1050 8c1ed301 mov word [var], ds . 0000:1054 b80035 mov ax, var . 0000:1057 2ef706010901. test word cs:[var], 1 . 0000:105e 7407 je var . 0000:1060 9adb080000 lcall 0 . 0000:1065 eb02 jmp var . 0000:1067 cd21 int var . 0000:1069 891e9a01 mov word [var], bx . 0000:106d 8c069c01 mov word [var], es . 0000:1071 0e push cs . 0000:1072 1f pop ds . 0000:1073 b80025 mov ax, var . 0000:1076 ba2c0b mov dx, var . 0000:1079 2ef706010901. test word cs:[var], 1 . 0000:1080 7407 je var . 0000:1082 9a81090000 lcall 0 . 0000:1087 eb02 jmp var . 0000:1089 cd21 int var . 0000:108b 16 push ss . 0000:108c 1f pop ds . 0000:108d 8b0ee401 mov cx, word [var] . 0000:1091 e32e jcxz var . 0000:1093 8e06ae01 mov es, word [var] . 0000:1097 268b362c00 mov si, word es:[var] . 0000:109c c506e601 lds ax, [var] . 0000:10a0 8cda mov dx, ds . 0000:10a2 33db xor bx, bx . 0000:10a4 36ff1ee201 lcall ss:[var] . 0000:10a9 7305 jae var
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004677 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi
0000:14f0 b430 mov ah, var . 0000:14f2 cd21 int var . 0000:14f4 3c02 cmp al, 2 . 0000:14f6 7302 jae var . 0000:14f8 cd20 int var . 0000:14fa bf0202 mov di, var . 0000:14fd 8b360200 mov si, word [2] . 0000:1501 2bf7 sub si, di . 0000:1503 81fe0010 cmp si, var . 0000:1507 7203 jb var . 0000:1509 be0010 mov si, var . 0000:150c fa cli . 0000:150d 8ed7 mov ss, di . 0000:150f 81c45e0c add sp, var . 0000:1513 fb sti . 0000:1514 7310 jae var . 0000:1516 16 push ss . 0000:1517 1f pop ds . 0000:1518 e8f701 call var . 0000:151b 33c0 xor ax, ax . 0000:151d 50 push ax . 0000:151e e86004 call var . 0000:1521 b8ff4c mov ax, var . 0000:1524 cd21 int var . 0000:1526 83e4fe and sp, var . 0000:1529 3689261009 mov word ss:[var], sp . 0000:152e 3689260c09 mov word ss:[var], sp . 0000:1533 8bc6 mov ax, si . 0000:1535 b104 mov cl, 4 . 0000:1537 d3e0 shl ax, cl . 0000:1539 48 dec ax . 0000:153a 36a30a09 mov word ss:[var], ax . 0000:153e 03f7 add si, di . 0000:1540 89360200 mov word [2], si . 0000:1544 8cc3 mov bx, es . 0000:1546 2bde sub bx, si . 0000:1548 f7db neg bx . 0000:154a b44a mov ah, var . 0000:154c cd21 int var . 0000:154e 368c1e8109 mov word ss:[var], ds . 0000:1553 16 push ss . 0000:1554 07 pop es . 0000:1555 fc cld . 0000:1556 bfca0b mov di, var . 0000:1559 b9600c mov cx, var . 0000:155c 2bcf sub cx, di . 0000:155e 33c0 xor ax, ax . 0000:1560 f3aa rep stosb byte es:[di], al . 0000:1562 16 push ss . 0000:1563 1f pop ds . 0000:1564 e83b00 call var . 0000:1567 16 push ss . 0000:1568 1f pop ds . 0000:1569 e87c03 call var . 0000:156c e8eb01 call var . 0000:156f 33ed xor bp, bp . 0000:1571 ff36a209 push word [var] . 0000:1575 ff36a009 push word [var] . 0000:1579 ff369e09 push word [var] . 0000:157d e82cf3 call var . 0000:1580 50 push ax . 0000:1581 e8e200 call var . 0000:1584 b80202 mov ax, var . 0000:1587 8ed8 mov ds, ax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov dword [var], eax . mov dword [var], ecx . mov dword [var], edx . mov dword [var], ebx . mov dword [var], esi . mov dword [var], edi . mov word [var], ss . mov word [var], cs . mov word [var], ds . mov word [var], es . mov word [var], fs . mov word [var], gs . pushfd . pop dword [var] . mov eax, dword [ebp] . mov dword [var], eax . mov eax, dword [ebp + 4] . mov dword [var], eax . lea eax, [ebp + 8] . mov dword [var], eax . mov eax, dword [ebp - var] . mov dword [var], var . mov eax, dword [var] . mov dword [var], eax . mov dword [var], var . mov dword [var], 1 . mov eax, dword [section..data] . mov dword [ebp - var], eax . mov eax, dword [var] . mov dword [ebp - var], eax . call dword [sym.imp.KERNEL32.dll_IsDebuggerPresent] . mov dword [var], eax . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push 0 . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . push var . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . cmp dword [var], 0 . jne var . push 1 . call sub.MSVCR90.dll__crt_debugger_hook . pop ecx . push var . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . leave . ret . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . push dword [var] . push dword [var] . push dword [var] . call var . jmp var . mov dword [var], esi . jmp var . add byte [eax], al . add byte [eax], al . xor eax, var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [ecx + var], al . adc eax, var . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004397 . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . jmp var . push dword [var] . call var . pop ecx . test eax, eax . je var . push dword [var] . call var . mov esi, eax . pop ecx . test esi, esi . je var . mov eax, esi . pop esi . pop ebp . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . pop ebp . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_free] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi
call var . jmp var . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01002c57 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01003fa7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi
push ebp . mov ebp, esp . push esi . sub esp, 8 . lea esi, [var] . push var . push esi . call var . add esp, 8 . push dword [esi] . call dword [sym.imp.KERNEL32.dll_ExitProcess] . push esi . mov ecx, dword [var] . mov eax, dword [var] . test ecx, ecx . je var . mov edx, dword [var] . mov esi, eax . mov byte [esi], dl . dec ecx . lea esi, [esi + 1] . jne var . pop esi . ret . int . int . int . mov eax, ecx . xor ecx, ecx . mov dword [eax], ecx . mov dword [eax + 4], var . mov dword [eax + var], ecx . mov dword [eax + var], ecx . mov dword [eax + 8], ecx . mov dword [eax + var], ecx . mov dword [eax + var], ecx . ret . int . push ebp . mov ebp, esp . push esi . mov eax, dword [ecx] . mov esi, ecx . test eax, eax . je var . push eax . call dword [sym.imp.KERNEL32.dll_LocalFree] . mov dword [esi], 0 . xor eax, eax . mov dword [esi + 4], var . mov dword [esi + var], eax . mov dword [esi + var], eax . mov dword [esi + 8], eax . mov dword [esi + var], eax . mov dword [esi + var], eax . pop esi . pop ebp . ret . push ebp . mov ebp, esp . push edi . push esi . mov eax, dword [ecx] . mov edi, dword [var]
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_strcat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010067b7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_strcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_sprintf_s] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01005697 . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int
jmp dword [sym.imp.mscoree.dll__CorExeMain] . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov eax, var . jmp var . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov eax, var . jmp var . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov eax, var . jmp var . mov ecx, dword [ebp - var] . jmp dword [sym.imp.MSVCR80.dll_public_virtual:_void___thiscall_std::exception::_destructor_void] . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov eax, var . jmp var . lea ecx, [ebp - var] . jmp var . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov eax, var . jmp var . mov ecx, dword [ebp - var] . add ecx, var . jmp var . mov ecx, dword [ebp - var] . add ecx, var . jmp var . mov ecx, dword [ebp - var] . add ecx, var . jmp var . mov ecx, dword [ebp - var] . add ecx, var . jmp var . mov edx, dword [esp + 8] . lea eax, [edx + var] . mov ecx, dword [edx - var] . xor ecx, eax . call main . mov ecx, dword [edx - 4] . xor ecx, eax . call main . mov eax, var . jmp var . mov ecx, dword [ebp - var] . add ecx, var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_fgetwc] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010044f7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, ecx . call dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_type_info::_destructor_void] . test byte [ebp + 8], 1 . je var . push esi . call var . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . int . int . int . int . int . push var . push var . call var . and dword [var], 0 . dec dword [var] . js var . mov ecx, dword [var] . sub ecx, dword [var] . mov dword [var], ecx . call dword [var] . jmp var . mov eax, dword [ebp - var] . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . mov eax, dword [eax] . mov dword [ebp - var], eax . mov eax, dword [ebp - var] . cmp dword [eax], var . je var . mov dword [ebp - var], 0 . mov eax, dword [ebp - var] . ret . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . mov esp, dword [ebp - var] . mov dword [var], var . call var . ret var . int . int . int . int . int . push var . push var . call var . and dword [var], 0 . mov esi, dword [var]
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01002f17 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100eb27 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push var . push var . call var . mov eax, dword [var] . mov dword [var], eax . cmp eax, var . jne var . push dword [var] . call dword [sym.imp.msvcrt.dll__onexit] . pop ecx . jmp var . push 8 . call sub.msvcrt.dll__lock . pop ecx . and dword [var], 0 . mov eax, dword [var] . mov dword [var], eax . mov eax, dword [var] . mov dword [var], eax . lea eax, [var] . push eax . lea eax, [var] . push eax . push dword [var] . call sub.msvcrt.dll___dllonexit . add esp, var . mov dword [var], eax
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002ef7 . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public:_void___thiscall_exception::constructor_void] . int . int
call var . jmp var . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__purecall] . int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01006c07 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov edi, var . push 0 . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . test eax, eax . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test ebx, ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . jmp var . nop . nop . nop . add byte [eax], al . add byte [eax], al . push edx . xor dword [eax], eax . add dword [edi], esp . add byte gs:[ecx], al . add dword [ebx], esi . add byte [ecx], al . sbb eax, var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.MSVCR100.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.MSVCR100.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . push var . push var . call var . push dword [var] . mov esi, dword [sym.imp.KERNEL32.dll_DecodePointer] . call esi . mov dword [var], eax . cmp eax, var . jne var . push dword [var] . call dword [sym.imp.MSVCR100.dll__onexit] . pop ecx . jmp var . push 8 . call sub.MSVCR100.dll__lock . pop ecx . and dword [var], 0 . push dword [var] . call esi . mov dword [var], eax . push dword [var] . call esi . mov dword [var], eax . lea eax, [var] . push eax . lea eax, [var] . push eax . push dword [var] . mov esi, dword [sym.imp.KERNEL32.dll_EncodePointer] . call esi . push eax . call sub.MSVCR100.dll___dllonexit . add esp, var . mov dword [var], eax . push dword [var] . call esi . mov dword [var], eax . push dword [var] . call esi . mov dword [var], eax . mov dword [var], var . call var . mov eax, dword [var]
call var . jmp var . mov edi, edi . push ebp . mov ebp, esp . pop ebp . jmp var . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . jmp var . push dword [ebp + 8] . call var . pop ecx . test eax, eax . je var . push dword [ebp + 8] . call var . pop ecx . test eax, eax . je var . leave . ret . test byte [var], 1 . mov edi, var . mov esi, var . jne var . or dword [var], 1 . push 1 . lea eax, [ebp - 4] . push eax . mov ecx, edi . mov dword [ebp - 4], var . call var . push var . mov dword [var], esi . call var . pop ecx . push edi . lea ecx, [ebp - var] . call var . push var . lea eax, [ebp - var] . push eax . mov dword [ebp - var], esi . call var . int . push ebp . mov ebp, esp . push edi . push esi . mov esi, dword [var] . mov ecx, dword [var] . mov edi, dword [var] . mov eax, ecx . mov edx, ecx . add eax, esi . cmp edi, esi . jbe var . cmp edi, eax . jb var . cmp ecx, var . jb var
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, ecx . call dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_type_info::_destructor_void] . test byte [ebp + 8], 1 . je var . push esi . call var . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . int . int . int . int . int . int . ├ 6: void sub.msvcrt.dll_free (void *ptr) . jmp dword [sym.imp.msvcrt.dll_free] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__purecall] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_malloc] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01012087 . int . int . int . int . int
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . int . int . cmp cl, var . jae var . cmp cl, var . jae var . shld edx, eax, cl . shl eax, cl . ret . mov edx, eax . xor eax, eax . and cl, var . shl edx, cl . ret . xor eax, eax . xor edx, edx . ret . int . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_floor] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__snwprintf_s] . int . int . int
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov ecx, dword [var] . mov eax, var . cmp word [ecx], ax . je var . xor eax, eax . pop ebp . ret . mov eax, dword [ecx + var] . add eax, ecx . cmp dword [eax], var . jne var
0000:2e10 8be8 mov bp, ax . 0000:2e12 8cc0 mov ax, es . 0000:2e14 051000 add ax, var . 0000:2e17 0e push cs . 0000:2e18 1f pop ds . 0000:2e19 a30400 mov word [4], ax . 0000:2e1c 03060c00 add ax, word [var] . 0000:2e20 8ec0 mov es, ax . 0000:2e22 8b0e0600 mov cx, word [6] . 0000:2e26 8bf9 mov di, cx . 0000:2e28 4f dec di . 0000:2e29 8bf7 mov si, di . 0000:2e2b fd std . 0000:2e2c f3a4 rep movsb byte es:[di], byte ptr [si] . 0000:2e2e 50 push ax . 0000:2e2f b83400 mov ax, var . 0000:2e32 50 push ax . 0000:2e33 cb retf . 0000:2e34 8cc3 mov bx, es . 0000:2e36 8cd8 mov ax, ds . 0000:2e38 48 dec ax . 0000:2e39 8ed8 mov ds, ax . 0000:2e3b 8ec0 mov es, ax . 0000:2e3d bf0f00 mov di, var . 0000:2e40 b91000 mov cx, var . 0000:2e43 b0ff mov al, var . 0000:2e45 f3ae repe scasb al, byte es:[di] . 0000:2e47 47 inc di . 0000:2e48 8bf7 mov si, di . 0000:2e4a 8bc3 mov ax, bx . 0000:2e4c 48 dec ax . 0000:2e4d 8ec0 mov es, ax . 0000:2e4f bf0f00 mov di, var . 0000:2e52 b104 mov cl, 4 . 0000:2e54 8bc6 mov ax, si . 0000:2e56 f7d0 not ax . 0000:2e58 d3e8 shr ax, cl . 0000:2e5a 8cda mov dx, ds . 0000:2e5c 2bd0 sub dx, ax . 0000:2e5e 7304 jae var . 0000:2e60 8cd8 mov ax, ds . 0000:2e62 2bd2 sub dx, dx . 0000:2e64 d3e0 shl ax, cl . 0000:2e66 03f0 add si, ax . 0000:2e68 8eda mov ds, dx . 0000:2e6a 8bc7 mov ax, di . 0000:2e6c f7d0 not ax . 0000:2e6e d3e8 shr ax, cl . 0000:2e70 8cc2 mov dx, es . 0000:2e72 2bd0 sub dx, ax . 0000:2e74 7304 jae var . 0000:2e76 8cc0 mov ax, es . 0000:2e78 2bd2 sub dx, dx . 0000:2e7a d3e0 shl ax, cl . 0000:2e7c 03f8 add di, ax . 0000:2e7e 8ec2 mov es, dx . 0000:2e80 ac lodsb al, byte [si] . 0000:2e81 8ad0 mov dl, al . 0000:2e83 4e dec si . 0000:2e84 ad lodsw ax, word [si] . 0000:2e85 8bc8 mov cx, ax . 0000:2e87 46 inc si . 0000:2e88 8ac2 mov al, dl . 0000:2e8a 24fe and al, var
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010062b7 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . je var . test dword [var], ebx . je var . mov dword [var], esi . not esi . mov dword [var], esi . pop esi . pop edi . pop ebx . leave . ret . mov esi, var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push esi . mov esi, ecx . call sub.MFC42u.dll_CWnd::CWnd . mov dword [esi], var . mov eax, esi . pop esi
push esi . mov edi, edi . call var . test eax, eax . jge var . mov esi, eax . call var . mov eax, esi . pop esi . ret . mov eax, dword [var] . call eax . jmp var . mov edi, edi . push esi . mov esi, dword [sym.imp.KERNEL32.dll_DeleteCriticalSection] . jmp var . dec dword [var] . mov eax, dword [var] . imul eax, eax, var . add eax, var . push eax . call esi . cmp dword [var], 0 . ja var . cmp dword [var], 0 . je var . push var . call esi . and dword [var], 0 . pop esi . ret . sub al, var . a3c3558bec mov dword [var], eax . push ebp . mov ebp, esp . mov edi, edi . lea eax, [var] . add eax, 4 . pop ebp . ret . push ebp . mov edi, edi . mov ebp, esp . push ecx . push ecx . mov eax, dword [ebp + 8] . mov dword [eax], var . mov dword [ebp - 8], eax . mov eax, dword [ebp + var] . push 0 . mov dword [ebp - 4], eax . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . lea eax, [ebp - 8] . push eax . call dword [sym.imp.KERNEL32.dll_UnhandledExceptionFilter] . push 3 . call dword [sym.imp.KERNEL32.dll_GetCurrentProcess] . push eax . call dword [sym.imp.KERNEL32.dll_TerminateProcess] . int . nop . nop . nop
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__vsnwprintf] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memmove_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public:_void___thiscall_exception::constructor_char_const___const_const] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public_virtual:_char_const_____thiscall_exception::what_void_const] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public:_void___thiscall_exception::constructor_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_exception::_destructor_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_public:_void___thiscall_exception::constructor_class_exception_const]
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100ec67 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__itow_s] . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . push var . push var . call var . mov eax, dword [var] . mov dword [var], eax
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__CxxThrowException] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, ecx . call dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_type_info::_destructor_void] . test byte [ebp + 8], 1 . je var . push esi . call var . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_ungetc] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01028297 . int . int . int . int . int . push eax . push dword fs:[0]
0000:36d3 33ed xor bp, bp . 0000:36d5 55 push bp . (reloc.KERNEL.INITTASK) . 0000:36d6 9affff0000 lcall 0 . 0000:36db 0bc0 or ax, ax . 0000:36dd 7465 je var . 0000:36df 8c064006 mov word [var], es . 0000:36e3 81c10001 add cx, var . 0000:36e7 725b jb var . 0000:36e9 890e1005 mov word [var], cx . 0000:36ed 89361205 mov word [var], si . 0000:36f1 893e1405 mov word [var], di . 0000:36f5 891e1605 mov word [var], bx . 0000:36f9 8c061805 mov word [var], es . 0000:36fd 89161a05 mov word [var], dx . (reloc.entry306) . 0000:3701 9affff0000 lcall 0 . (reloc.entry307) . 0000:3706 9affff0000 lcall 0 . (reloc.entry308) . 0000:370b 9affff0000 lcall 0 . 0000:3710 33c0 xor ax, ax . 0000:3712 50 push ax . (reloc.KERNEL.WAITEVENT) . 0000:3713 9affff0000 lcall 0 . 0000:3718 ff361405 push word [var] . (reloc.USER.INITAPP) . 0000:371c 9affff0000 lcall 0 . 0000:3721 0bc0 or ax, ax . 0000:3723 741f je var . 0000:3725 ff361405 push word [var] . 0000:3729 ff361205 push word [var] . 0000:372d ff361805 push word [var] . 0000:3731 ff361605 push word [var] . 0000:3735 ff361a05 push word [var] . (reloc.entry309) . 0000:3739 9affff0000 lcall 0 . 0000:373e 50 push ax . (reloc.entry310) . 0000:373f 9affff0000 lcall 0 . 0000:3744 b0ff mov al, var . 0000:3746 50 push ax . (reloc.entry311) . 0000:3747 9affff0000 lcall 0 . 0000:374c 55 push bp . 0000:374d 8bec mov bp, sp . 0000:374f 8bd7 mov dx, di . 0000:3751 8cd8 mov ax, ds . 0000:3753 8ec0 mov es, ax . 0000:3755 8b7e06 mov di, word [bp + 6] . 0000:3758 33c0 xor ax, ax . 0000:375a b9ffff mov cx, var . 0000:375d f2ae repne scasb al, byte es:[di] . 0000:375f f7d1 not cx . 0000:3761 49 dec cx . 0000:3762 91 xchg ax, cx . 0000:3763 8bfa mov di, dx . 0000:3765 5d pop bp . 0000:3766 cb retf . 0000:3767 008cd890 add byte [si - var], cl . 0000:376b 45 inc bp . 0000:376c 55 push bp . 0000:376d 8bec mov bp, sp . 0000:376f 1e push ds . 0000:3770 8ed8 mov ds, ax . 0000:3772 b439 mov ah, var . 0000:3774 eb0c jmp var . 0000:3776 8cd8 mov ax, ds . 0000:3778 90 nop . 0000:3779 45 inc bp . 0000:377a 55 push bp . 0000:377b 8bec mov bp, sp . 0000:377d 1e push ds
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01001c57 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int
push esi . mov edi, edi . call var . test eax, eax . jge var . mov esi, eax . call var . mov eax, esi . pop esi . ret . mov eax, dword [var] . call eax . jmp var . nop . nop . nop . nop . nop . nop . pop ss . add byte [eax], al . adc byte [esi], al . xor dword [ecx], eax . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax - var], al . ud2b . or byte [eax], dh . add al, 1 . push ebp . mov edi, edi . mov ebp, esp . sub esp, var . mov eax, dword [ebp + 8] . push ebx . add eax, var . push esi . mov dword [ebp - var], eax . mov eax, dword [eax] . mov esi, dword [eax + 4] . push edi . mov edi, dword [eax + 8] . lea ebx, [eax + var] . and esi, edx . and edi, edx . mov dword [ebp - var], esi . mov esi, dword [eax] . lea eax, [ebx - 1] . shr esi, 1 . add edi, var . and esi, edx . cmp eax, ecx . mov dword [ebp - var], edi . mov dword [ebp - var], esi . mov dword [ebp - var], eax . jb var . mov eax, dword [var] . mov edx, dword [var] . imul eax, edx . lea edx, [eax + var] . mov eax, dword [ebp - var] . cmp eax, edx . jae var
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.010071af . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [esp + 4] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01006587 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ebx . push esi . push edi . mov edx, dword [var] . mov eax, dword [var] . mov ecx, dword [var] . push ebp . push edx . push eax . push ecx . push ecx . push var . push dword fs:[0] . mov eax, dword [var] . xor eax, esp . mov dword [var], eax . mov dword fs:[0], esp . mov eax, dword [var] . mov ebx, dword [eax + 8] . mov ecx, dword [var] . xor ebx, dword [ecx] . mov esi, dword [eax + var] . cmp esi, var . je var . mov edx, dword [var] . cmp edx, var . je var . cmp esi, edx . jbe var . lea esi, [esi + esi*2] . lea ebx, [ebx + esi*4 + var] . mov ecx, dword [ebx]
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__vsnprintf] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01009d87 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . int . int . int . int . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_fgetwc] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004477 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01003447 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int
call var . jmp var . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int . int . int . int . int . cmp ecx, dword [var] . jne var
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov edi, var . push 0 . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . test eax, eax . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test ebx, ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], 0 . jne var . mov eax, dword [sym.imp.msvcrt.dll__acmdln] . mov esi, dword [eax] . mov dword [var], esi . mov al, byte [esi] . cmp al, var . jbe var . cmp al, var . je var . movzx eax, al . push eax . call dword [sym.imp.msvcrt.dll__ismbblead]
call var . jmp var . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010020a7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swprintf_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01002db7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_vswprintf_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcscat_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var
call var . jmp var . push var . push var . call var . xor esi, esi . mov dword [var], esi . mov dword [var], esi . call dword [sym.imp.MSVCR120.dll___crtGetShowWindowMode] . movzx ebx, ax . mov dword [var], esi . mov eax, dword fs:[var] . mov edx, dword [eax + 4] . mov edi, esi . mov esi, var . mov ecx, edx . xor eax, eax . lock cmpxchg dword [esi], ecx . test eax, eax . je var . cmp eax, edx . jne var . xor esi, esi . inc esi . mov edi, esi . jmp var . xor esi, esi . inc esi . cmp dword [var], esi . jne var . push var . call sub.MSVCR120.dll__amsg_exit . pop ecx . jmp var . cmp dword [var], 0 . jne var . mov dword [var], esi . push var . push var . call sub.MSVCR120.dll__initterm_e . pop ecx . pop ecx . test eax, eax . je var . mov dword [var], var . mov eax, var . jmp var . mov dword [var], esi . cmp dword [var], esi . jne var . push var . push var . call sub.MSVCR120.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . test edi, edi . jne var . xor eax, eax . mov ecx, var . xchg dword [ecx], eax . cmp dword [var], 0 . je var . push var
call var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . mov eax, dword [var] . and dword [lpSystemTimeAsFileTime], 0 . and dword [var], 0 . push ebx . push edi . mov edi, var . mov ebx, var . cmp eax, edi . jne var . push esi . lea eax, [lpSystemTimeAsFileTime] . push eax . call dword [sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime] . mov esi, dword [var] . xor esi, dword [lpSystemTimeAsFileTime] . call dword [sym.imp.KERNEL32.dll_GetCurrentProcessId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetCurrentThreadId] . xor esi, eax . call dword [sym.imp.KERNEL32.dll_GetTickCount] . xor esi, eax . lea eax, [lpPerformanceCount] . push eax . call dword [sym.imp.KERNEL32.dll_QueryPerformanceCounter] . mov eax, dword [var] . xor eax, dword [lpPerformanceCount] . xor esi, eax . cmp esi, edi . je var . test dword [var], ebx . je var . mov dword [var], esi . not esi . mov dword [var], esi . pop esi . pop edi . pop ebx . leave . ret . mov esi, var . jmp var . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push esi . mov esi, ecx . mov eax, dword [esi]
jmp dword [sym.imp.mscoree.dll__CorExeMain] . int . int . int . int . int . int . int . int . add esi, dword [eax] . add dword [eax], eax . pop es . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], dl . or byte [edi], 0 . add al, var . int . int . int . int . int . add esi, dword [eax] . add dword [eax], eax . pop es . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], dl . add byte [ebp], 0 . add al, var . int . int . int . int . int . add esi, dword [eax] . add dword [eax], eax . pop es . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], dl . or byte [edx], 0 . add al, var . int . int . int . int . int . add esi, dword [eax] . add dword [eax], eax . pop es . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [esi], dl . adc byte [edx], 0 . add al, var . int . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010029c7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [esp + 4] . sub ecx, eax . sbb eax, eax
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov ecx, dword [var] . mov eax, var . cmp word [ecx], ax . je var . xor eax, eax . pop ebp . ret . mov eax, dword [ecx + var]
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . mov dword [var], eax . movzx ecx, word [eax] . cmp cx, var . jbe var . cmp cx, var . je var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__ftol2] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0100c294 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_swscanf_s] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01013fa7 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__purecall] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . int . int . int . int . int . int . push ebx . push esi . mov eax, dword [var] . or eax, eax . jne var . mov ecx, dword [var] . mov eax, dword [var] . xor edx, edx . div ecx . mov ebx, eax . mov eax, dword [var] . div ecx . mov edx, ebx . jmp var . mov ecx, eax
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_free] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__CxxThrowException] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, ecx . call dword [sym.imp.msvcrt.dll_public_virtual:_void___thiscall_type_info::_destructor_void] . test byte [ebp + 8], 1 . je var . push esi . call var . pop ecx . mov eax, esi . pop esi . pop ebp . ret 4 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx
call var . jmp var . cmp ecx, dword [var] . jne var . ret . jmp loc.00405224 . jmp dword [sym.imp.MSVCR80.dll_memset] . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . jmp dword [sym.imp.MSVCR80.dll_memcpy] . jmp dword [sym.imp.MSVCR80.dll___CxxFrameHandler3] . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . mov dword [ebp - var], eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret
call var . jmp var . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01004c27 . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . mov dword [var], eax . movzx ecx, word [eax] . cmp cx, var . jbe var . cmp cx, var . je var
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . push dword [var] . push dword [var] . push dword [var] . call var . jmp var . mov dword [var], esi . jmp var . nop . add byte [eax], al . add byte [eax], al . mov byte [ecx], dl . add byte [ecx], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
jmp dword [sym.imp.mscoree.dll__CorExeMain] . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.010033ad . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new_unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcstok_s] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter]
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var]
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push ebx . xor ebx, ebx . cmp dword [var], ebx . jne var . call var . push ebx . push ebx . push ebx . push ebx . push ebx . mov dword [eax], var . call var . add esp, var . or eax, var . jmp var . mov eax, dword [var] . push esi . mov esi, dword [var] . cmp eax, ebx . je var . cmp esi, ebx . jne var . call var . push ebx . push ebx . push ebx . push ebx . push ebx . mov dword [eax], var . call var . add esp, var . or eax, var . jmp var . mov dword [var], var . mov dword [var], esi . mov dword [var], esi . cmp eax, var . jbe var . mov dword [var], var . jmp var . add eax, eax . mov dword [var], eax . push edi . push dword [var] . lea eax, [var] . push dword [var] . push dword [var] . push eax . call var . add esp, var . mov edi, eax . cmp esi, ebx . je var
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . mov dword [var], eax . movzx ecx, word [eax] . cmp cx, var . jbe var . cmp cx, var . je var
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], reloc.OLEAUT32.dll_CreateErrorInfo . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . mov dword [var], eax . movzx ecx, word [eax] . cmp cx, var . jbe var . cmp cx, var . je var
call var . push eax . call dword [sym.imp.KERNEL32.dll_ExitProcess] . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, dword [var] . push edi . test esi, esi . je var . cmp dword [var], 0 . je var . mov eax, dword [esi + 4] . mov edi, dword [var] . cmp di, word [eax + var] . je var . push dword [esi + var] . push dword [var] . push dword [var] . push 0 . push eax . push dword [esi] . call var . test eax, eax . je var . push dword [esi + 4] . push edi . call var . test eax, eax . je var . push dword [esi + var] . push edi . push dword [var] . push dword [var] . push dword [var] . push dword [var] . push dword [var] . push dword [esi + 4] . call var . test eax, eax . je var . mov ecx, dword [esi + 4] . mov edx, dword [ecx + var] . add edx, dword [ecx + var] . mov eax, dword [esi] . cmp dword [eax + var], edx . jb var . mov edx, dword [eax + var] . add edx, dword [eax + var] . add edx, dword [ecx + var] . add edx, dword [ecx + var] . add edx, dword [ecx + var] . add edx, dword [eax + var] . add edx, dword [eax + var] . add edx, dword [eax + var] . cmp dword [eax + var], edx . jb var
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.01005987 . int . int . int . int . int . int . int . int . int . int . int . int . int . push ecx . lea ecx, [var] . sub ecx, eax . sbb eax, eax . not eax . and ecx, eax . mov eax, esp . and eax, var . cmp ecx, eax . jb var . mov eax, ecx . pop ecx . xchg eax, esp . mov eax, dword [eax] . mov dword [esp], eax . ret . sub eax, var . test dword [eax], eax . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var
call var . jmp var . jmp dword [sym.imp.MSVCR80.dll_void___cdecl_operator_delete_void] . cmp ecx, dword [var] . jne var . ret . jmp loc.0046b3b5 . int . jmp dword [sym.imp.MSVCR80.dll_memset] . jmp dword [sym.imp.MSVCR80.dll__CxxThrowException] . push ebx . mov bl, byte [esp + 8] . test bl, 2 . push esi . mov esi, ecx . je var . push edi . push sub.MSVCR80.dll_public:_void___thiscall_type_info::_type_info_dtor_internal_method_void . lea edi, [esi - 4] . push dword [edi] . push var . push esi . call var . test bl, 1 . je var . push edi . call sub.MSVCR80.dll_void___cdecl_operator_delete_void . pop ecx . mov eax, edi . pop edi . jmp var . call sub.MSVCR80.dll_public:_void___thiscall_type_info::_type_info_dtor_internal_method_void . test bl, 1 . je var . push esi . call sub.MSVCR80.dll_void___cdecl_operator_delete_void . pop ecx . mov eax, esi . pop esi . pop ebx . ret 4 . int . jmp dword [sym.imp.MSVCR80.dll___CxxFrameHandler3] . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var]
call var . jmp var . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + var] . push dword [ebp + 8] . push var . push var . call sub.msvcrt.dll__except_handler4_common . add esp, var . pop ebp . ret . int . int . int . int
call var . jmp var . int . int . int . int . int . cmp ecx, dword [section..data] . jne var . ret 0 . jmp loc.01001c07 . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memset] . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int
call var . push var . push var . call var . xor ebx, ebx . mov dword [var], ebx . mov dword [var], ebx . lea eax, [lpStartupInfo] . push eax . call dword [sym.imp.KERNEL32.dll_GetStartupInfoW] . mov dword [var], var . mov dword [var], 1 . mov eax, dword fs:[var] . mov esi, dword [eax + 4] . mov dword [var], ebx . mov edi, var . push ebx . push esi . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedCompareExchange] . cmp eax, ebx . jne var . xor esi, esi . inc esi . mov eax, dword [var] . cmp eax, esi . je var . mov eax, dword [var] . test eax, eax . jne var . mov dword [var], esi . push var . push var . call var . pop ecx . pop ecx . test eax, eax . jne var . mov eax, dword [var] . cmp eax, esi . jne var . push var . push var . call sub.msvcrt.dll__initterm . pop ecx . pop ecx . mov dword [var], 2 . cmp dword [var], ebx . jne var . push ebx . push edi . call dword [sym.imp.KERNEL32.dll_InterlockedExchange] . cmp dword [var], ebx . jne var . mov eax, dword [sym.imp.msvcrt.dll__wcmdln] . cmp dword [eax], ebx . je var . mov eax, dword [eax] . nop . nop . nop . nop . nop . nop
call var . jmp var . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov eax, dword [ebp + 8] . mov eax, dword [eax] . cmp dword [eax], var . jne var . cmp dword [eax + var], 3 . jne var . mov eax, dword [eax + var] . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . je var . cmp eax, var . jne var . call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void] . xor eax, eax . pop ebp . ret 4 . int . int . int . int . int . push var . call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter] . xor eax, eax . ret . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll__XcptFilter] . int . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . mov ecx, dword [var] . mov eax, var . cmp word [ecx], ax . je var . xor eax, eax . pop ebp . ret . mov eax, dword [ecx + var] . add eax, ecx . cmp dword [eax], var . jne var
call var . push var . mov eax, var . call var . pop ecx . jmp var . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . nop . nop . nop . nop . nop . mov edi, edi . push ebp . mov ebp, esp . push esi . mov esi, eax . cmp esi, dword [var] . jae var . mov eax, dword [esi] . test eax, eax . jne var . add esi, 4 . jmp var . pop esi . pop ebp . ret . nop . nop . nop . nop . push ebx . add byte [edi], ch . add byte [eax + eax + var], dh . add byte [ecx], ah . jb var . add byte gs:[eax + eax + var], bl . add byte [ecx], ch . arpl word [eax], ax . jb var . outsd dx, dword [esi] . add byte [ebx], dh . outsd dx, dword [esi] . add byte [esi], ah . je var . pop esp . add byte [edi], dl . imul eax, dword [eax], var . outsd dx, dword [esi] . add byte [edi], dh . jae var . and byte [eax], al . push ebx . add byte [ebx], ah . jb var . imul eax, dword [eax], var . and byte [eax], al . dec eax . add byte [edi], ch . jae var . je var
call var . jmp var . mov eax, dword [var] . push ebx . xor ebx, ebx . inc ebx . push esi . cmp eax, ebx . je var . test eax, eax . jne var . push var . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . mov esi, eax . test esi, esi . jne var . mov esi, ebx . jmp var . push var . push esi . call dword [sym.imp.KERNEL32.dll_GetProcAddress] . test eax, eax . je var . push var . push esi . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_GetProcAddress] . test eax, eax . je var . mov dword [var], eax . mov ecx, esi . mov edx, var . xor eax, eax . lock cmpxchg dword [edx], ecx . test eax, eax . jne var . cmp esi, ebx . je var . cmp eax, ebx . je var . mov al, bl . jmp var . xor al, al . pop esi . pop ebx . ret . call var . test al, al . je var . push esi . mov esi, dword [var] . mov ecx, esi . push var . call dword [section..00cfg] . call esi . pop esi . ret . mov edx, var . jmp var . pause . mov eax, dword [var] . test eax, eax . jne var . xor ecx, ecx
call var . jmp var . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_free] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_memcpy_s] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_wcsncpy_s] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi
call var . jmp var . mov eax, dword [var] . push ebx . xor ebx, ebx . inc ebx . push esi . cmp eax, ebx . je var . test eax, eax . jne var . push var . call dword [sym.imp.KERNEL32.dll_GetModuleHandleW] . mov esi, eax . test esi, esi . jne var . mov esi, ebx . jmp var . push var . push esi . call dword [sym.imp.KERNEL32.dll_GetProcAddress] . test eax, eax . je var . push var . push esi . mov dword [var], eax . call dword [sym.imp.KERNEL32.dll_GetProcAddress] . test eax, eax . je var . mov dword [var], eax . mov ecx, esi . mov edx, var . xor eax, eax . lock cmpxchg dword [edx], ecx . test eax, eax . jne var . cmp esi, ebx . je var . cmp eax, ebx . je var . mov al, bl . jmp var . xor al, al . pop esi . pop ebx . ret . call var . test al, al . je var . push esi . mov esi, dword [var] . mov ecx, esi . push var . call dword [section..00cfg] . call esi . pop esi . ret . mov edx, var . jmp var . pause . mov eax, dword [var] . test eax, eax . jne var . xor ecx, ecx
mov edi, edi . push ebp . mov ebp, esp . sub esp, var . push esi . call var . push var . mov eax, var . call var . mov eax, var . mov dword [esp], var . call var . pop ecx . lea eax, [lpStartupInfo] . xor esi, esi . push eax . mov dword [var], esi . call dword [sym.imp.KERNEL32.dll_GetStartupInfoA] . test byte [var], 1 . je var . movzx eax, word [var] . push eax . push esi . push esi . push esi . call dword [sym.imp.KERNEL32.dll_GetModuleHandleA] . push eax . call main . mov esi, eax . push var . mov eax, var . call var . mov eax, var . mov dword [esp], var . call var . pop ecx . push esi . call dword [sym.imp.KERNEL32.dll_ExitProcess] . int . push var . pop eax . jmp var . nop . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . add byte [eax], al . nop . nop . nop . nop . nop
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void_____cdecl_operator_new___unsigned_int] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll___CxxFrameHandler3] . int . int . int . int . int . cmp ecx, dword [var] . jne var . ret 0 . jmp loc.0104fafc . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi . push edi . mov dword [eax], ebp . mov ebp, eax . mov eax, dword [var] . xor eax, ebp . push eax . push dword [ebp - 4] . mov dword [ebp - 4], var . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . int . int . int . int . int . push eax . push dword fs:[0] . lea eax, [var] . sub esp, dword [var] . push ebx . push esi
call var . jmp var . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete_void] . int . int . int . int . int . int . jmp dword [sym.imp.msvcrt.dll_void___cdecl_operator_delete___void] . int . int . int . int . int . int . int . int . push var . push dword fs:[0] . mov eax, dword [var] . mov dword [var], ebp . lea ebp, [var] . sub esp, eax . push ebx . push esi . push edi . mov eax, dword [var] . xor dword [ebp - 4], eax . xor eax, ebp . push eax . mov dword [ebp - var], esp . push dword [ebp - 8] . mov eax, dword [ebp - 4] . mov dword [ebp - 4], var . mov dword [ebp - 8], eax . lea eax, [ebp - var] . mov dword fs:[0], eax . ret . mov ecx, dword [var] . mov dword fs:[0], ecx . pop ecx . pop edi . pop edi . pop esi . pop ebx . mov esp, ebp . pop ebp . push ecx . ret . int . int . int . int . int . mov edi, edi . push ebp . mov ebp, esp . push dword [ebp + var]